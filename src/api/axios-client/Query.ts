//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions  } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import { Client as ClientClass } from '../axios-client';
import { createClient, getClientFactory } from './helpers';

export const Client = () => getClientFactory()(ClientClass);
import type { AxiosRequestConfig } from 'axios';

export type ArticlesGETQueryParameters = {
  articleId: number | undefined;
  frontendId: number | undefined;
  title: string | undefined;
  isProofread: boolean | undefined;
  siteSectionId: number | undefined;
  createdFrom: number | undefined;
  createdTo: number | undefined;
  author: string | undefined;
  state: Types.EnumArticleState | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type ArticlesPOSTMutationParameters = {
  subTypeId: number | undefined ; 
  frontendId: number | undefined ; 
  localeId: number | undefined ; 
  siteSectionIds: number[] | undefined ; 
  title: string | undefined ; 
  teaser: string | undefined ; 
  content: string | undefined ; 
  headlineImgFile: Types.FileParameter | undefined ; 
  headlineImageText: string | undefined ; 
  squareHeadlineImgFile: Types.FileParameter | undefined ; 
  isPublished: boolean | undefined ; 
  publishedAt: number | undefined ; 
  isFeatured: boolean | undefined ; 
  isSectionSticky: boolean | undefined ; 
  timeSpent: number | undefined ; 
  playerIds: number[] | undefined ; 
  teamIds: number[] | undefined ; 
  tournamentIds: number[] | undefined ; 
  quickPoll_Question: string | undefined ; 
  quickPoll_Options: string[] | undefined ; 
};

export type ArticlesGET2QueryParameters = {
  id: number;
};

export type ArticlesPATCHMutationParameters = {
  id: number | undefined ; 
  subTypeId: number | undefined ; 
  frontendId: number | undefined ; 
  localeId: number | undefined ; 
  siteSectionIds: number[] | undefined ; 
  title: string | undefined ; 
  teaser: string | undefined ; 
  content: string | undefined ; 
  headlineImgFile: Types.FileParameter | undefined ; 
  headlineImageText: string | undefined ; 
  squareHeadlineImgFile: Types.FileParameter | undefined ; 
  isPublished: boolean | undefined ; 
  publishedAt: number | undefined ; 
  isProofread: boolean | undefined ; 
  timeSpentProofreading: number | undefined ; 
  isFeatured: boolean | undefined ; 
  isSectionSticky: boolean | undefined ; 
  timeSpent: number | undefined ; 
  isClearAllPlayers: boolean | undefined ; 
  playerIds: number[] | undefined ; 
  isClearAllTeams: boolean | undefined ; 
  teamIds: number[] | undefined ; 
  isClearAllTournaments: boolean | undefined ; 
  tournamentIds: number[] | undefined ; 
  quickPoll_Question: string | undefined ; 
  quickPoll_Options: string[] | undefined ; 
};

export type LoginQueryParameters = {
  api_version: string | undefined;
};

export type RegisterQueryParameters = {
  api_version: string | undefined;
};

export type LogoutGETQueryParameters = {
  api_version: string | undefined;
};

export type OauthCallbackQueryParameters = {
  code: string | undefined;
  locale: string | undefined;
  state: string | undefined;
  userState: string | undefined;
  api_version: string | undefined;
};

export type BroadcasttalentsGETQueryParameters = {
  nickName: string | undefined;
  name: string | undefined;
  gameId: number | undefined;
  languageId: number | undefined;
  countryId: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type BroadcasttalentsPOSTMutationParameters = {
  name: string | undefined ; 
  firstName: string | undefined ; 
  lastName: string | undefined ; 
  countryId: number | undefined ; 
  languageId: number | undefined ; 
  type: Types.EnumBroadcastTalentType | undefined ; 
  isActive: boolean | undefined ; 
  about: string | undefined ; 
  gender: number | undefined ; 
  dateOfBirth: Date | undefined ; 
  primaryGameId: number | undefined ; 
  profileImage: Types.FileParameter | undefined ; 
  headerImage: Types.FileParameter | undefined ; 
  playerId: number | undefined ; 
  personalStreamId: number | undefined ; 
  website: string | undefined ; 
  facebook: string | undefined ; 
  twitter: string | undefined ; 
  youtube: string | undefined ; 
};

export type BroadcasttalentsGET2QueryParameters = {
  id: number;
};

export type BroadcasttalentsPATCHMutationParameters = {
  id: number | undefined ; 
  name: string | undefined ; 
  firstName: string | undefined ; 
  lastName: string | undefined ; 
  countryId: number | undefined ; 
  languageId: number | undefined ; 
  type: Types.EnumBroadcastTalentType | undefined ; 
  isActive: boolean | undefined ; 
  about: string | undefined ; 
  gender: number | undefined ; 
  dateOfBirth: Date | undefined ; 
  primaryGameId: number | undefined ; 
  profileImage: Types.FileParameter | undefined ; 
  headerImage: Types.FileParameter | undefined ; 
  playerId: number | undefined ; 
  personalStreamId: number | undefined ; 
  website: string | undefined ; 
  facebook: string | undefined ; 
  twitter: string | undefined ; 
  youtube: string | undefined ; 
};

export type MediaItemsGETQueryParameters = {
  id: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type EnumretQueryParameters = {
  api_version: string | undefined;
};

export type CrewFoldersGETQueryParameters = {
  parentId: number | undefined;
  uploadType: string | undefined;
  sort: Types.EnumFieldSort | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type CrewFoldersPOSTMutationParameters = {
  parentId: number | undefined ; 
  folderName: string | undefined ; 
};

export type CrewFilesGETQueryParameters = {
  folderId: number;
  fileName: string | undefined;
  uploader: string | undefined;
  uploadedFrom: number | undefined;
  uploadedTo: number | undefined;
  nameSort: Types.EnumFieldSort | undefined;
  uploadedSort: Types.EnumFieldSort | undefined;
  uploaderSort: Types.EnumFieldSort | undefined;
  sizeSort: Types.EnumFieldSort | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type CrewFilesPOSTMutationParameters = {
  folderId: number | undefined ; 
  fileName: string | undefined ; 
  file: Types.FileParameter | undefined ; 
};

export type CrewFoldersPATCHMutationParameters = {
  id: number | undefined ; 
  parentId: number | undefined ; 
  name: string | undefined ; 
};

export type FuzzyFoldersQueryParameters = {
  folderId: number;
  fuzzyName: string;
  maxCount: number | undefined;
};

export type CrewFilesPATCHMutationParameters = {
  fileId: number | undefined ; 
  folderId: number | undefined ; 
  fileName: string | undefined ; 
};

export type FrontendSiteSectionsGETQueryParameters = {
  id: number;
};

export type FuncsPOSTMutationParameters = {
  funcId: number | undefined ; 
  name: string | undefined ; 
  code: string | undefined ; 
  type: Types.EnumFuncType | undefined ; 
  parentId: number | undefined ; 
  position: number | undefined ; 
  url: string | undefined ; 
  icon: string | undefined ; 
};

export type FuncsGET2QueryParameters = {
  id: number;
};

export type FuncsPATCHMutationParameters = {
  funcId: number | undefined ; 
  name: string | undefined ; 
  code: string | undefined ; 
  type: Types.EnumFuncType | undefined ; 
  parentId: number | undefined ; 
  position: number | undefined ; 
  state: Types.EnumState | undefined ; 
  url: string | undefined ; 
  icon: string | undefined ; 
};

export type FuzzyQueryParameters = {
  fuzzyPrefix: string | undefined;
  maxCount: number | undefined;
};

export type GameRegionsGETQueryParameters = {
  gameId: number | undefined;
  regionName: string | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type GameRegionsGET2QueryParameters = {
  id: number;
};

export type TranslationsGETQueryParameters = {
  id: number;
};

export type GamesGETQueryParameters = {
  gameName: string | undefined;
  isLegacy: boolean | undefined;
  hasPlayerRankings: boolean | undefined;
  hasTeamRankings: boolean | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type GamesPOSTMutationParameters = {
  name: string | undefined ; 
  hasPlayerRankings: boolean | undefined ; 
  hasTeamRankings: boolean | undefined ; 
  hasStreams: boolean | undefined ; 
  gridId: number | undefined ; 
  steamAppId: number | undefined ; 
  twitchGameId: number | undefined ; 
  iconImageFile: Types.FileParameter | undefined ; 
  isLegacy: boolean | undefined ; 
  recommendedReplayCount: number | undefined ; 
};

export type GamesGET2QueryParameters = {
  id: number;
};

export type IdMutationParameters = {
  gameId: number | undefined ; 
  name: string | undefined ; 
  hasPlayerRankings: boolean | undefined ; 
  hasTeamRankings: boolean | undefined ; 
  hasStreams: boolean | undefined ; 
  gridId: number | undefined ; 
  steamAppId: number | undefined ; 
  twitchGameId: number | undefined ; 
  iconImageFile: Types.FileParameter | undefined ; 
  isLegacy: boolean | undefined ; 
  recommendedReplayCount: number | undefined ; 
};

export type Fuzzy2QueryParameters = {
  fuzzyPrefix: string | undefined;
  maxCount: number | undefined;
};

export type GamesidesGETQueryParameters = {
  name: string | undefined;
  gameId: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type GamesidesPOSTMutationParameters = {
  name: string | undefined ; 
  iconFile: Types.FileParameter | undefined ; 
  gameId: number | undefined ; 
};

export type GamesidesGET2QueryParameters = {
  id: number;
};

export type GamesidesPATCHMutationParameters = {
  id: number | undefined ; 
  name: string | undefined ; 
  iconFile: Types.FileParameter | undefined ; 
  gameId: number | undefined ; 
};

export type TranslationsGET2QueryParameters = {
  id: number;
};

export type GroupsGETQueryParameters = {
  groupIds: number[] | undefined;
  remark: string | undefined;
  frontendIds: number[] | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type GroupsGET2QueryParameters = {
  id: number;
};

export type UsersGETQueryParameters = {
  id: number;
};

export type FuzzyUsersQueryParameters = {
  id: number;
  fuzzyPrefix: string;
  maxCount: number | undefined;
};

export type HeroesGETQueryParameters = {
  name: string | undefined;
  title: string | undefined;
  gameId: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type HeroesPOSTMutationParameters = {
  name: string | undefined ; 
  gameId: number | undefined ; 
  title: string | undefined ; 
  referredToBy: number | undefined ; 
  tagline: string | undefined ; 
  description: string | undefined ; 
  imageFile: Types.FileParameter | undefined ; 
  iconFile: Types.FileParameter | undefined ; 
};

export type HeroesGET2QueryParameters = {
  id: number;
};

export type HeroesPATCHMutationParameters = {
  id: number | undefined ; 
  name: string | undefined ; 
  gameId: number | undefined ; 
  title: string | undefined ; 
  referredToBy: number | undefined ; 
  tagline: string | undefined ; 
  description: string | undefined ; 
  imageFile: Types.FileParameter | undefined ; 
  iconFile: Types.FileParameter | undefined ; 
};

export type TranslationsGET3QueryParameters = {
  id: number;
};

export type ApiLogsQueryParameters = {
  from: number | undefined;
  to: number | undefined;
  prefix: string | undefined;
  httpStatusCode: number | undefined;
  ip: string | undefined;
  path: string | undefined;
  content: string | undefined;
  serverName: string | undefined;
  traceId: string | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type ApiLogs2QueryParameters = {
  id: number;
};

export type SystemLogsQueryParameters = {
  from: number | undefined;
  to: number | undefined;
  prefix: string | undefined;
  serverName: string | undefined;
  logger: string | undefined;
  method: string | undefined;
  logLevel: Types.LogLevel | undefined;
  traceId: string | undefined;
  keyword: string | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type SystemLogs2QueryParameters = {
  id: number;
};

export type MapsGETQueryParameters = {
  name: string | undefined;
  gameId: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type MapsPOSTMutationParameters = {
  name: string | undefined ; 
  imageFile: Types.FileParameter | undefined ; 
  gameId: number | undefined ; 
};

export type MapsGET2QueryParameters = {
  id: number;
};

export type MapsPATCHMutationParameters = {
  id: number | undefined ; 
  name: string | undefined ; 
  imageFile: Types.FileParameter | undefined ; 
  gameId: number | undefined ; 
};

export type TranslationsGET4QueryParameters = {
  id: number;
};

export type StreamsGETQueryParameters = {
  title: string | undefined;
  creator: string | undefined;
  platformId: Types.EnumPlatform | undefined;
  streamId: string | undefined;
  gameId: number | undefined;
  isLive: boolean | undefined;
  createdFrom: number | undefined;
  createdTo: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type StreamsPOSTMutationParameters = {
  platform: Types.EnumPlatform | undefined ; 
  streamId: string | undefined ; 
  streamUrl: string | undefined ; 
  screenCapFile: Types.FileParameter | undefined ; 
  gameId: number | undefined ; 
  languageId: number | undefined ; 
  isEventStream: boolean | undefined ; 
  isProPlayer: boolean | undefined ; 
  isCelebCaster: boolean | undefined ; 
  nextBroadcastAt: number | undefined ; 
  title: string | undefined ; 
  isFeatured: boolean | undefined ; 
  description: string | undefined ; 
  tags: string[] | undefined ; 
};

export type StreamsGET2QueryParameters = {
  id: number;
};

export type StreamsPATCHMutationParameters = {
  id: number | undefined ; 
  platform: Types.EnumPlatform | undefined ; 
  streamId: string | undefined ; 
  streamUrl: string | undefined ; 
  screenCapFile: Types.FileParameter | undefined ; 
  gameId: number | undefined ; 
  languageId: number | undefined ; 
  isEventStream: boolean | undefined ; 
  isProPlayer: boolean | undefined ; 
  isCelebCaster: boolean | undefined ; 
  nextBroadcastAt: number | undefined ; 
  title: string | undefined ; 
  isFeatured: boolean | undefined ; 
  description: string | undefined ; 
  tags: Types.ModStreamTag[] | undefined ; 
};

export type FuzzyStreamsQueryParameters = {
  fuzzyPrefix: string | undefined;
  maxCount: number | undefined;
};

export type FuzzyVideosQueryParameters = {
  fuzzyPrefix: string | undefined;
  maxCount: number | undefined;
};

export type VodsGETQueryParameters = {
  vodId: number | undefined;
  title: string | undefined;
  hostId: number | undefined;
  hostVideoId: string | undefined;
  siteSectionIds: number[] | undefined;
  createdFrom: number | undefined;
  createdTo: number | undefined;
  creator: string | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type VodsGET2QueryParameters = {
  id: number;
};

export type DownloadCsvQueryParameters = {
  pageSize: number | undefined;
  vodId: number | undefined;
  title: string | undefined;
  hostId: number | undefined;
  hostVideoId: string | undefined;
  siteSectionIds: number[] | undefined;
  createdFrom: number | undefined;
  createdTo: number | undefined;
  creator: string | undefined;
  pageNo: number | undefined;
};

export type ModesGETQueryParameters = {
  name: string | undefined;
  abbreviation: string | undefined;
  gameId: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type ModesGET2QueryParameters = {
  id: number;
};

export type TranslationsGET5QueryParameters = {
  id: number;
};

export type MessagingNotificationTemplatesGETQueryParameters = {
  frontendId: number | undefined;
  notificationTemplateType: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type MessagingNotificationTemplatesGET2QueryParameters = {
  id: number;
};

export type MessagingOnesignalAppsGETQueryParameters = {
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type MessagingOnesignalAppsGET2QueryParameters = {
  id: number;
};

export type ProxyQueryParameters = {
  url: string | undefined;
};

export type ServersGETQueryParameters = {
  gameId: number | undefined;
};

export type PagesGETQueryParameters = {
  title: string | undefined;
  frontendId: number | undefined;
  author: string | undefined;
  pageId: number | undefined;
  updatedFrom: number | undefined;
  updatedTo: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type PagesGET2QueryParameters = {
  id: number;
};

export type PlayersGETQueryParameters = {
  id: number | undefined;
  nickName: string | undefined;
  firstName: string | undefined;
  lastName: string | undefined;
  primaryGameId: number | undefined;
  countryId: number | undefined;
  createdAtFrom: number | undefined;
  createdAtTo: number | undefined;
  gameAccount: string | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type PlayersPOSTMutationParameters = {
  userId: number | undefined ; 
  isActive: boolean | undefined ; 
  nickName: string | undefined ; 
  firstName: string | undefined ; 
  lastName: string | undefined ; 
  gender: Types.EnumGender | undefined ; 
  dateOfBirth: Date | undefined ; 
  countryId: number | undefined ; 
  initialRating: number | undefined ; 
  primaryGameId: number | undefined ; 
  image: Types.FileParameter | undefined ; 
  descriptions: string | undefined ; 
  faceBook: string | undefined ; 
  twitter: string | undefined ; 
  youtube: string | undefined ; 
};

export type PlayersGET2QueryParameters = {
  id: number;
};

export type PlayersPATCHMutationParameters = {
  playerId: number | undefined ; 
  userId: number | undefined ; 
  isActive: boolean | undefined ; 
  nickName: string | undefined ; 
  firstName: string | undefined ; 
  lastName: string | undefined ; 
  gender: Types.EnumGender | undefined ; 
  dateOfBirth: Date | undefined ; 
  countryId: number | undefined ; 
  primaryGameId: number | undefined ; 
  image: Types.FileParameter | undefined ; 
  isRemoveImage: boolean | undefined ; 
  descriptions: string | undefined ; 
  faceBook: string | undefined ; 
  twitter: string | undefined ; 
  youtube: string | undefined ; 
};

export type Fuzzy3QueryParameters = {
  fuzzyPrefix: string;
  maxCount: number | undefined;
};

export type UsersGET2QueryParameters = {
  id: number;
};

export type MediaItemsGET2QueryParameters = {
  playerid: number;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type UsersGET3QueryParameters = {
  id: number;
};

export type RolesGETQueryParameters = {
  roleIds: number[] | undefined;
  groupIds: number[] | undefined;
  frontendIds: number[] | undefined;
  remark: string | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type RolesGET2QueryParameters = {
  id: number;
};

export type Templates2QueryParameters = {
  id: number;
};

export type ServersGET2QueryParameters = {
  name: string | undefined;
  gameId: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type ServersPOSTMutationParameters = {
  name: string | undefined ; 
  gameId: number | undefined ; 
};

export type ServersGET3QueryParameters = {
  id: number;
};

export type ServersPATCHMutationParameters = {
  id: number | undefined ; 
  name: string | undefined ; 
  isFrozen: boolean | undefined ; 
  gameId: number | undefined ; 
};

export type SiteSectionsGET2QueryParameters = {
  filters_Id: number | undefined;
  filters_Name: string | undefined;
  filters_GameName: string | undefined;
  filters_Hidden: boolean | undefined;
  sorts_Id: Types.EnumFieldSort | undefined;
  sorts_GameName: Types.EnumFieldSort | undefined;
  sorts_Name: Types.EnumFieldSort | undefined;
  sorts_Hidden: Types.EnumFieldSort | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type SiteSectionsPOSTMutationParameters = {
  gameId: number | undefined ; 
  name: string | undefined ; 
  hidden: boolean | undefined ; 
  position: number | undefined ; 
  headerImage: Types.FileParameter | undefined ; 
  backGroundImage: Types.FileParameter | undefined ; 
  iconImage: Types.FileParameter | undefined ; 
  logoImage: Types.FileParameter | undefined ; 
};

export type SiteSectionsGET3QueryParameters = {
  id: number;
};

export type SiteSectionsPATCHMutationParameters = {
  id: number | undefined ; 
  gameId: number | undefined ; 
  name: string | undefined ; 
  hidden: boolean | undefined ; 
  position: number | undefined ; 
  headerImage: Types.FileParameter | undefined ; 
  backGroundImage: Types.FileParameter | undefined ; 
  iconImage: Types.FileParameter | undefined ; 
  logoImage: Types.FileParameter | undefined ; 
};

export type SponsorsGETQueryParameters = {
  name: string | undefined;
  website: string | undefined;
  creator: string | undefined;
  updatedFrom: number | undefined;
  updatedTo: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type SponsorsPOSTMutationParameters = {
  name: string | undefined ; 
  description: string | undefined ; 
  imageFile: Types.FileParameter | undefined ; 
  url: string | undefined ; 
};

export type SponsorsGET2QueryParameters = {
  id: number;
};

export type SponsorsPATCHMutationParameters = {
  id: number | undefined ; 
  name: string | undefined ; 
  description: string | undefined ; 
  imageFile: Types.FileParameter | undefined ; 
  url: string | undefined ; 
};

export type TeamsGETQueryParameters = {
  teamName: string | undefined;
  teamId: number | undefined;
  playerId: number | undefined;
  gameId: number | undefined;
  countryId: number | undefined;
  updatedAtFrom: number | undefined;
  updatedAtTo: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type TeamsPOSTMutationParameters = {
  teamName: string | undefined ; 
  teamTag: string | undefined ; 
  gameId: number | undefined ; 
  countryId: number | undefined ; 
  image: Types.FileParameter | undefined ; 
  description: string | undefined ; 
  initialRating: number | undefined ; 
  excludeRankings: boolean | undefined ; 
  facebook: string | undefined ; 
  twitter: string | undefined ; 
  youtube: string | undefined ; 
};

export type TeamsGET2QueryParameters = {
  id: number;
};

export type TeamsPATCHMutationParameters = {
  teamId: number | undefined ; 
  teamName: string | undefined ; 
  teamTag: string | undefined ; 
  ownerId: number | undefined ; 
  captainId: number | undefined ; 
  manageId: number | undefined ; 
  excludedRankings: boolean | undefined ; 
  image: Types.FileParameter | undefined ; 
  isRemoveImage: boolean | undefined ; 
  gameId: number | undefined ; 
  countryId: number | undefined ; 
  description: string | undefined ; 
  facebook: string | undefined ; 
  twitter: string | undefined ; 
  youtube: string | undefined ; 
};

export type TeamPlayersGETQueryParameters = {
  teamid: number;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type TeamPlayersPOSTMutationParameters = {
  playerId: number | undefined ; 
  joinedAt: number | undefined ; 
  isHidden: boolean | undefined ; 
};

export type TeamPlayersGET2QueryParameters = {
  teamid: number;
  teamplayerid: number;
};

export type TeamPlayersPATCHMutationParameters = {
  teamPlayerId: number | undefined ; 
  teamId: number | undefined ; 
  joinDate: number | undefined ; 
  leaveDate: number | undefined ; 
  isHidden: boolean | undefined ; 
};

export type Fuzzy4QueryParameters = {
  fuzzyPrefix: string;
  maxCount: number | undefined;
};

export type GameAccountsGETQueryParameters = {
  playerId: number;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type GameAccountsPOSTMutationParameters = {
  playerId: number | undefined ; 
  gameId: number | undefined ; 
  serverId: number | undefined ; 
  gameAccountName: string | undefined ; 
};

export type GameAccountsGET2QueryParameters = {
  id: number;
};

export type Fuzzy5QueryParameters = {
  fuzzyPrefix: string;
  maxCount: number | undefined;
};

export type UsersGET4QueryParameters = {
  filters_UserName: string | undefined;
  filters_UserTypeId: number | undefined;
  filters_FrontEndIds: number[] | undefined;
  filters_Groups: number[] | undefined;
  filters_Roles: number[] | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type UsersPOSTMutationParameters = {
  userName: string | undefined ; 
  email: string | undefined ; 
  password: string | undefined ; 
  lastName: string | undefined ; 
  firstName: string | undefined ; 
  userTypeId: number | undefined ; 
  groupIds: number[] | undefined ; 
  roleIds: number[] | undefined ; 
  gender: Types.EnumGender | undefined ; 
  dateOfBirth: Date | undefined ; 
  city: string | undefined ; 
  countryId: number | undefined ; 
  aboutMe: string | undefined ; 
  avatarImage: Types.FileParameter | undefined ; 
};

export type UsersGET5QueryParameters = {
  id: number;
};

export type UsersPATCHMutationParameters = {
  userId: number | undefined ; 
  userName: string | undefined ; 
  email: string | undefined ; 
  password: string | undefined ; 
  lastName: string | undefined ; 
  firstName: string | undefined ; 
  userTypeId: number | undefined ; 
  groupIds: number[] | undefined ; 
  roleIds: number[] | undefined ; 
  gender: Types.EnumGender | undefined ; 
  dateOfBirth: Date | undefined ; 
  city: string | undefined ; 
  countryId: number | undefined ; 
  aboutMe: string | undefined ; 
  avatarImage: Types.FileParameter | undefined ; 
};

export type Fuzzy6QueryParameters = {
  fuzzyPrefix: string;
  maxCount: number | undefined;
};

export type VenuesGETQueryParameters = {
  name: string | undefined;
  countryId: number | undefined;
  pageNo: number | undefined;
  pageSize: number | undefined;
};

export type VenuesPOSTMutationParameters = {
  name: string | undefined ; 
  countryId: number | undefined ; 
  city: string | undefined ; 
  address: string | undefined ; 
  coordinates: string | undefined ; 
  imageFile: Types.FileParameter | undefined ; 
};

export type VenuesGET2QueryParameters = {
  id: number;
};

export type VenuesPATCHMutationParameters = {
  id: number | undefined ; 
  name: string | undefined ; 
  countryId: number | undefined ; 
  city: string | undefined ; 
  address: string | undefined ; 
  coordinates: string | undefined ; 
  imageFile: Types.FileParameter | undefined ; 
};

    
export function typesUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/articles/types";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let typesDefaultOptions: UseQueryOptions<Types.GetArticleTypesRespApiRespBase, unknown, Types.GetArticleTypesRespApiRespBase> = {
  queryFn: __types,
};
export function getTypesDefaultOptions(): UseQueryOptions<Types.GetArticleTypesRespApiRespBase, unknown, Types.GetArticleTypesRespApiRespBase> {
  return typesDefaultOptions;
};
export function setTypesDefaultOptions(options: UseQueryOptions<Types.GetArticleTypesRespApiRespBase, unknown, Types.GetArticleTypesRespApiRespBase>) {
  typesDefaultOptions = options;
}

export function typesQueryKey(): QueryKey;
export function typesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'types',
    ]);
}
function __types() {
  return Client().types(
    );
}

/**
 * Get all article types and subtypes
 * @return Error
 */
export function useTypesQuery<TSelectData = Types.GetArticleTypesRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetArticleTypesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTypesQuery<TSelectData = Types.GetArticleTypesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetArticleTypesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetArticleTypesRespApiRespBase, TError, TSelectData>({
    queryFn: __types,
    queryKey: typesQueryKey(),
    ...typesDefaultOptions as unknown as UseQueryOptions<Types.GetArticleTypesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get all article types and subtypes
 * @return Error
 */
export function setTypesData(queryClient: QueryClient, updater: (data: Types.GetArticleTypesRespApiRespBase | undefined) => Types.GetArticleTypesRespApiRespBase, ) {
  queryClient.setQueryData(typesQueryKey(),
    updater
  );
}

/**
 * Get all article types and subtypes
 * @return Error
 */
export function setTypesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetArticleTypesRespApiRespBase | undefined) => Types.GetArticleTypesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function articlesGETUrl(articleId: number | undefined, frontendId: number | undefined, title: string | undefined, isProofread: boolean | undefined, siteSectionId: number | undefined, createdFrom: number | undefined, createdTo: number | undefined, author: string | undefined, state: Types.EnumArticleState | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/articles?";
if (articleId === null)
    throw new Error("The parameter 'articleId' cannot be null.");
else if (articleId !== undefined)
    url_ += "ArticleId=" + encodeURIComponent("" + articleId) + "&";
if (frontendId === null)
    throw new Error("The parameter 'frontendId' cannot be null.");
else if (frontendId !== undefined)
    url_ += "FrontendId=" + encodeURIComponent("" + frontendId) + "&";
if (title === null)
    throw new Error("The parameter 'title' cannot be null.");
else if (title !== undefined)
    url_ += "Title=" + encodeURIComponent("" + title) + "&";
if (isProofread === null)
    throw new Error("The parameter 'isProofread' cannot be null.");
else if (isProofread !== undefined)
    url_ += "IsProofread=" + encodeURIComponent("" + isProofread) + "&";
if (siteSectionId === null)
    throw new Error("The parameter 'siteSectionId' cannot be null.");
else if (siteSectionId !== undefined)
    url_ += "SiteSectionId=" + encodeURIComponent("" + siteSectionId) + "&";
if (createdFrom === null)
    throw new Error("The parameter 'createdFrom' cannot be null.");
else if (createdFrom !== undefined)
    url_ += "CreatedFrom=" + encodeURIComponent("" + createdFrom) + "&";
if (createdTo === null)
    throw new Error("The parameter 'createdTo' cannot be null.");
else if (createdTo !== undefined)
    url_ += "CreatedTo=" + encodeURIComponent("" + createdTo) + "&";
if (author === null)
    throw new Error("The parameter 'author' cannot be null.");
else if (author !== undefined)
    url_ += "Author=" + encodeURIComponent("" + author) + "&";
if (state === null)
    throw new Error("The parameter 'state' cannot be null.");
else if (state !== undefined)
    url_ += "State=" + encodeURIComponent("" + state) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let articlesGETDefaultOptions: UseQueryOptions<Types.GetArticlesRespApiRespBase, unknown, Types.GetArticlesRespApiRespBase> = {
  queryFn: __articlesGET,
};
export function getArticlesGETDefaultOptions(): UseQueryOptions<Types.GetArticlesRespApiRespBase, unknown, Types.GetArticlesRespApiRespBase> {
  return articlesGETDefaultOptions;
};
export function setArticlesGETDefaultOptions(options: UseQueryOptions<Types.GetArticlesRespApiRespBase, unknown, Types.GetArticlesRespApiRespBase>) {
  articlesGETDefaultOptions = options;
}

export function articlesGETQueryKey(dto: ArticlesGETQueryParameters): QueryKey;
export function articlesGETQueryKey(articleId: number | undefined, frontendId: number | undefined, title: string | undefined, isProofread: boolean | undefined, siteSectionId: number | undefined, createdFrom: number | undefined, createdTo: number | undefined, author: string | undefined, state: Types.EnumArticleState | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function articlesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { articleId, frontendId, title, isProofread, siteSectionId, createdFrom, createdTo, author, state, pageNo, pageSize,  } = params[0] as ArticlesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'articlesGET',
        articleId as any,
        frontendId as any,
        title as any,
        isProofread as any,
        siteSectionId as any,
        createdFrom as any,
        createdTo as any,
        author as any,
        state as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'articlesGET',
        ...params
      ]);
  }
}
function __articlesGET(context: QueryFunctionContext) {
  return Client().articlesGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as boolean | undefined,       context.queryKey[6] as number | undefined,       context.queryKey[7] as number | undefined,       context.queryKey[8] as number | undefined,       context.queryKey[9] as string | undefined,       context.queryKey[10] as Types.EnumArticleState | undefined,       context.queryKey[11] as number | undefined,       context.queryKey[12] as number | undefined    );
}

export function useArticlesGETQuery<TSelectData = Types.GetArticlesRespApiRespBase, TError = unknown>(dto: ArticlesGETQueryParameters, options?: UseQueryOptions<Types.GetArticlesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get articles by condition
 * @param articleId (optional) Article Id for troubleshooting
 * @param frontendId (optional) Frontend id
null: All
 * @param title (optional) Article title
 * @param isProofread (optional) Is Proofread
 * @param siteSectionId (optional) Site Section Id
null: All
 * @param createdFrom (optional) Created From
 * @param createdTo (optional) Created To
 * @param author (optional) Creator user name
 * @param state (optional) Article state
Published: 1
Unpublished: 2
Deleted: 3
Featured: 4
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useArticlesGETQuery<TSelectData = Types.GetArticlesRespApiRespBase, TError = unknown>(articleId: number | undefined, frontendId: number | undefined, title: string | undefined, isProofread: boolean | undefined, siteSectionId: number | undefined, createdFrom: number | undefined, createdTo: number | undefined, author: string | undefined, state: Types.EnumArticleState | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetArticlesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useArticlesGETQuery<TSelectData = Types.GetArticlesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetArticlesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let articleId: any = undefined;
  let frontendId: any = undefined;
  let title: any = undefined;
  let isProofread: any = undefined;
  let siteSectionId: any = undefined;
  let createdFrom: any = undefined;
  let createdTo: any = undefined;
  let author: any = undefined;
  let state: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ articleId, frontendId, title, isProofread, siteSectionId, createdFrom, createdTo, author, state, pageNo, pageSize,  } = params[0] as ArticlesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [articleId, frontendId, title, isProofread, siteSectionId, createdFrom, createdTo, author, state, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetArticlesRespApiRespBase, TError, TSelectData>({
    queryFn: __articlesGET,
    queryKey: articlesGETQueryKey(articleId, frontendId, title, isProofread, siteSectionId, createdFrom, createdTo, author, state, pageNo, pageSize),
    ...articlesGETDefaultOptions as unknown as UseQueryOptions<Types.GetArticlesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get articles by condition
 * @param articleId (optional) Article Id for troubleshooting
 * @param frontendId (optional) Frontend id
null: All
 * @param title (optional) Article title
 * @param isProofread (optional) Is Proofread
 * @param siteSectionId (optional) Site Section Id
null: All
 * @param createdFrom (optional) Created From
 * @param createdTo (optional) Created To
 * @param author (optional) Creator user name
 * @param state (optional) Article state
Published: 1
Unpublished: 2
Deleted: 3
Featured: 4
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setArticlesGETData(queryClient: QueryClient, updater: (data: Types.GetArticlesRespApiRespBase | undefined) => Types.GetArticlesRespApiRespBase, articleId: number | undefined, frontendId: number | undefined, title: string | undefined, isProofread: boolean | undefined, siteSectionId: number | undefined, createdFrom: number | undefined, createdTo: number | undefined, author: string | undefined, state: Types.EnumArticleState | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(articlesGETQueryKey(articleId, frontendId, title, isProofread, siteSectionId, createdFrom, createdTo, author, state, pageNo, pageSize),
    updater
  );
}

/**
 * Get articles by condition
 * @param articleId (optional) Article Id for troubleshooting
 * @param frontendId (optional) Frontend id
null: All
 * @param title (optional) Article title
 * @param isProofread (optional) Is Proofread
 * @param siteSectionId (optional) Site Section Id
null: All
 * @param createdFrom (optional) Created From
 * @param createdTo (optional) Created To
 * @param author (optional) Creator user name
 * @param state (optional) Article state
Published: 1
Unpublished: 2
Deleted: 3
Featured: 4
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setArticlesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetArticlesRespApiRespBase | undefined) => Types.GetArticlesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function articlesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/articles";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function articlesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'articlesPOST',
    ]);
}

/**
 * Add new article
 * @param subTypeId (optional) Article SubtypeId
 * @param frontendId (optional) Article frontend id
 * @param localeId (optional) Article locale id
 * @param siteSectionIds (optional) Article site sections
 * @param title (optional) Article title
 * @param teaser (optional) Article Teaser
 * @param content (optional) Article content
 * @param headlineImgFile (optional) Headline image file
 * @param headlineImageText (optional) Headline image text
 * @param squareHeadlineImgFile (optional) Square headline image file
 * @param isPublished (optional) Is published
 * @param publishedAt (optional) Published At
 * @param isFeatured (optional) Is featured
 * @param isSectionSticky (optional) Is section sticky
 * @param timeSpent (optional) Time spent
 * @param playerIds (optional) Related players
 * @param teamIds (optional) Related teams
 * @param tournamentIds (optional) Related tournaments
 * @param quickPoll_Question (optional) Questions
 * @param quickPoll_Options (optional) Options
 * @return Error
 */
export function useArticlesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddArticleRespApiRespBase, unknown, ArticlesPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddArticleRespApiRespBase, unknown, ArticlesPOSTMutationParameters, TContext> {
  const key = articlesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((articlesPOSTMutationParameters: ArticlesPOSTMutationParameters) => Client().articlesPOST(articlesPOSTMutationParameters.subTypeId, articlesPOSTMutationParameters.frontendId, articlesPOSTMutationParameters.localeId, articlesPOSTMutationParameters.siteSectionIds, articlesPOSTMutationParameters.title, articlesPOSTMutationParameters.teaser, articlesPOSTMutationParameters.content, articlesPOSTMutationParameters.headlineImgFile, articlesPOSTMutationParameters.headlineImageText, articlesPOSTMutationParameters.squareHeadlineImgFile, articlesPOSTMutationParameters.isPublished, articlesPOSTMutationParameters.publishedAt, articlesPOSTMutationParameters.isFeatured, articlesPOSTMutationParameters.isSectionSticky, articlesPOSTMutationParameters.timeSpent, articlesPOSTMutationParameters.playerIds, articlesPOSTMutationParameters.teamIds, articlesPOSTMutationParameters.tournamentIds, articlesPOSTMutationParameters.quickPoll_Question, articlesPOSTMutationParameters.quickPoll_Options), {...options, mutationKey: key});
}
  
    
export function articlesGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/articles/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let articlesGET2DefaultOptions: UseQueryOptions<Types.GetArticleRespApiRespBase, unknown, Types.GetArticleRespApiRespBase> = {
  queryFn: __articlesGET2,
};
export function getArticlesGET2DefaultOptions(): UseQueryOptions<Types.GetArticleRespApiRespBase, unknown, Types.GetArticleRespApiRespBase> {
  return articlesGET2DefaultOptions;
};
export function setArticlesGET2DefaultOptions(options: UseQueryOptions<Types.GetArticleRespApiRespBase, unknown, Types.GetArticleRespApiRespBase>) {
  articlesGET2DefaultOptions = options;
}

export function articlesGET2QueryKey(id: number): QueryKey;
export function articlesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ArticlesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'articlesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'articlesGET2',
        ...params
      ]);
  }
}
function __articlesGET2(context: QueryFunctionContext) {
  return Client().articlesGET2(
      context.queryKey[2] as number    );
}

export function useArticlesGET2Query<TSelectData = Types.GetArticleRespApiRespBase, TError = unknown>(dto: ArticlesGET2QueryParameters, options?: UseQueryOptions<Types.GetArticleRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get article
 * @param id ArticleId
 * @return Error
 */
export function useArticlesGET2Query<TSelectData = Types.GetArticleRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetArticleRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useArticlesGET2Query<TSelectData = Types.GetArticleRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetArticleRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ArticlesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetArticleRespApiRespBase, TError, TSelectData>({
    queryFn: __articlesGET2,
    queryKey: articlesGET2QueryKey(id),
    ...articlesGET2DefaultOptions as unknown as UseQueryOptions<Types.GetArticleRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get article
 * @param id ArticleId
 * @return Error
 */
export function setArticlesGET2Data(queryClient: QueryClient, updater: (data: Types.GetArticleRespApiRespBase | undefined) => Types.GetArticleRespApiRespBase, id: number) {
  queryClient.setQueryData(articlesGET2QueryKey(id),
    updater
  );
}

/**
 * Get article
 * @param id ArticleId
 * @return Error
 */
export function setArticlesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetArticleRespApiRespBase | undefined) => Types.GetArticleRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function articlesPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/articles/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function articlesPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'articlesPATCH',
      id as any,
    ]);
}

/**
 * Modify article
 * @param id ArticleId
 * @param id (optional) Article id
 * @param subTypeId (optional) Article SubtypeId
 * @param frontendId (optional) Article frontend id
 * @param localeId (optional) Article locale id
 * @param siteSectionIds (optional) Article site sections
 * @param title (optional) Article title
 * @param teaser (optional) Article teaser
 * @param content (optional) Article content
 * @param headlineImgFile (optional) Headline image file
 * @param headlineImageText (optional) Headline image text
 * @param squareHeadlineImgFile (optional) Square headline image file
 * @param isPublished (optional) Is published
 * @param publishedAt (optional) Published At
 * @param isProofread (optional) Is proofread
 * @param timeSpentProofreading (optional) Time spent for proofreading
 * @param isFeatured (optional) Is featured
 * @param isSectionSticky (optional) Is section sticky
 * @param timeSpent (optional) Time spent
 * @param isClearAllPlayers (optional) Is Clear All Players
 * @param playerIds (optional) Related players
 * @param isClearAllTeams (optional) Is Clear All Teams
 * @param teamIds (optional) Related teams
 * @param isClearAllTournaments (optional) Is Clear All Tournaments
 * @param tournamentIds (optional) Related tournaments
 * @param quickPoll_Question (optional) Questions
 * @param quickPoll_Options (optional) Options
 * @return Error
 */
export function useArticlesPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModArticleRespApiRespBase, unknown, ArticlesPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModArticleRespApiRespBase, unknown, ArticlesPATCHMutationParameters, TContext> {
  const key = articlesPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((articlesPATCHMutationParameters: ArticlesPATCHMutationParameters) => Client().articlesPATCH(id, articlesPATCHMutationParameters.id, articlesPATCHMutationParameters.subTypeId, articlesPATCHMutationParameters.frontendId, articlesPATCHMutationParameters.localeId, articlesPATCHMutationParameters.siteSectionIds, articlesPATCHMutationParameters.title, articlesPATCHMutationParameters.teaser, articlesPATCHMutationParameters.content, articlesPATCHMutationParameters.headlineImgFile, articlesPATCHMutationParameters.headlineImageText, articlesPATCHMutationParameters.squareHeadlineImgFile, articlesPATCHMutationParameters.isPublished, articlesPATCHMutationParameters.publishedAt, articlesPATCHMutationParameters.isProofread, articlesPATCHMutationParameters.timeSpentProofreading, articlesPATCHMutationParameters.isFeatured, articlesPATCHMutationParameters.isSectionSticky, articlesPATCHMutationParameters.timeSpent, articlesPATCHMutationParameters.isClearAllPlayers, articlesPATCHMutationParameters.playerIds, articlesPATCHMutationParameters.isClearAllTeams, articlesPATCHMutationParameters.teamIds, articlesPATCHMutationParameters.isClearAllTournaments, articlesPATCHMutationParameters.tournamentIds, articlesPATCHMutationParameters.quickPoll_Question, articlesPATCHMutationParameters.quickPoll_Options), {...options, mutationKey: key});
}
  
    
export function articlesDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/articles/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function articlesDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'articlesDELETE',
      id as any,
    ]);
}

/**
 * Delete article
 * @param id ArticleId
 * @return Error
 */
export function useArticlesDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelArticleRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelArticleRespApiRespBase, unknown, void, TContext> {
  const key = articlesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().articlesDELETE(id), {...options, mutationKey: key});
}
  
    
export function loginUrl(api_version: string | undefined): string {
  let url_ = getBaseUrl() + "/login?";
if (api_version === null)
    throw new Error("The parameter 'api_version' cannot be null.");
else if (api_version !== undefined)
    url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let loginDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __login,
};
export function getLoginDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return loginDefaultOptions;
};
export function setLoginDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  loginDefaultOptions = options;
}

export function loginQueryKey(api_version: string | undefined): QueryKey;
export function loginQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { api_version,  } = params[0] as LoginQueryParameters;

    return trimArrayEnd([
        'Client',
        'login',
        api_version as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'login',
        ...params
      ]);
  }
}
function __login(context: QueryFunctionContext) {
  return Client().login(
      context.queryKey[2] as string | undefined    );
}

export function useLoginQuery<TSelectData = void, TError = unknown>(dto: LoginQueryParameters, options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Login
 * @param api_version (optional) 
 * @return Success
 */
export function useLoginQuery<TSelectData = void, TError = unknown>(api_version: string | undefined, options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useLoginQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let api_version: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ api_version,  } = params[0] as LoginQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [api_version, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __login,
    queryKey: loginQueryKey(api_version),
    ...loginDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * Login
 * @param api_version (optional) 
 * @return Success
 */
export function setLoginData(queryClient: QueryClient, updater: (data: void | undefined) => void, api_version: string | undefined) {
  queryClient.setQueryData(loginQueryKey(api_version),
    updater
  );
}

/**
 * Login
 * @param api_version (optional) 
 * @return Success
 */
export function setLoginDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function registerUrl(api_version: string | undefined): string {
  let url_ = getBaseUrl() + "/register?";
if (api_version === null)
    throw new Error("The parameter 'api_version' cannot be null.");
else if (api_version !== undefined)
    url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let registerDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __register,
};
export function getRegisterDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return registerDefaultOptions;
};
export function setRegisterDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  registerDefaultOptions = options;
}

export function registerQueryKey(api_version: string | undefined): QueryKey;
export function registerQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { api_version,  } = params[0] as RegisterQueryParameters;

    return trimArrayEnd([
        'Client',
        'register',
        api_version as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'register',
        ...params
      ]);
  }
}
function __register(context: QueryFunctionContext) {
  return Client().register(
      context.queryKey[2] as string | undefined    );
}

export function useRegisterQuery<TSelectData = void, TError = unknown>(dto: RegisterQueryParameters, options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Register
 * @param api_version (optional) 
 * @return Success
 */
export function useRegisterQuery<TSelectData = void, TError = unknown>(api_version: string | undefined, options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useRegisterQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let api_version: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ api_version,  } = params[0] as RegisterQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [api_version, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __register,
    queryKey: registerQueryKey(api_version),
    ...registerDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * Register
 * @param api_version (optional) 
 * @return Success
 */
export function setRegisterData(queryClient: QueryClient, updater: (data: void | undefined) => void, api_version: string | undefined) {
  queryClient.setQueryData(registerQueryKey(api_version),
    updater
  );
}

/**
 * Register
 * @param api_version (optional) 
 * @return Success
 */
export function setRegisterDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function logoutGETUrl(api_version: string | undefined): string {
  let url_ = getBaseUrl() + "/logout?";
if (api_version === null)
    throw new Error("The parameter 'api_version' cannot be null.");
else if (api_version !== undefined)
    url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let logoutGETDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __logoutGET,
};
export function getLogoutGETDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return logoutGETDefaultOptions;
};
export function setLogoutGETDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  logoutGETDefaultOptions = options;
}

export function logoutGETQueryKey(api_version: string | undefined): QueryKey;
export function logoutGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { api_version,  } = params[0] as LogoutGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'logoutGET',
        api_version as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'logoutGET',
        ...params
      ]);
  }
}
function __logoutGET(context: QueryFunctionContext) {
  return Client().logoutGET(
      context.queryKey[2] as string | undefined    );
}

export function useLogoutGETQuery<TSelectData = void, TError = unknown>(dto: LogoutGETQueryParameters, options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param api_version (optional) 
 * @return Success
 */
export function useLogoutGETQuery<TSelectData = void, TError = unknown>(api_version: string | undefined, options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useLogoutGETQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let api_version: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ api_version,  } = params[0] as LogoutGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [api_version, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __logoutGET,
    queryKey: logoutGETQueryKey(api_version),
    ...logoutGETDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * @param api_version (optional) 
 * @return Success
 */
export function setLogoutGETData(queryClient: QueryClient, updater: (data: void | undefined) => void, api_version: string | undefined) {
  queryClient.setQueryData(logoutGETQueryKey(api_version),
    updater
  );
}

/**
 * @param api_version (optional) 
 * @return Success
 */
export function setLogoutGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function oauthCallbackUrl(code: string | undefined, locale: string | undefined, state: string | undefined, userState: string | undefined, api_version: string | undefined): string {
  let url_ = getBaseUrl() + "/oauth-callback?";
if (code === null)
    throw new Error("The parameter 'code' cannot be null.");
else if (code !== undefined)
    url_ += "Code=" + encodeURIComponent("" + code) + "&";
if (locale === null)
    throw new Error("The parameter 'locale' cannot be null.");
else if (locale !== undefined)
    url_ += "Locale=" + encodeURIComponent("" + locale) + "&";
if (state === null)
    throw new Error("The parameter 'state' cannot be null.");
else if (state !== undefined)
    url_ += "State=" + encodeURIComponent("" + state) + "&";
if (userState === null)
    throw new Error("The parameter 'userState' cannot be null.");
else if (userState !== undefined)
    url_ += "UserState=" + encodeURIComponent("" + userState) + "&";
if (api_version === null)
    throw new Error("The parameter 'api_version' cannot be null.");
else if (api_version !== undefined)
    url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let oauthCallbackDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __oauthCallback,
};
export function getOauthCallbackDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return oauthCallbackDefaultOptions;
};
export function setOauthCallbackDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  oauthCallbackDefaultOptions = options;
}

export function oauthCallbackQueryKey(dto: OauthCallbackQueryParameters): QueryKey;
export function oauthCallbackQueryKey(code: string | undefined, locale: string | undefined, state: string | undefined, userState: string | undefined, api_version: string | undefined): QueryKey;
export function oauthCallbackQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { code, locale, state, userState, api_version,  } = params[0] as OauthCallbackQueryParameters;

    return trimArrayEnd([
        'Client',
        'oauthCallback',
        code as any,
        locale as any,
        state as any,
        userState as any,
        api_version as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'oauthCallback',
        ...params
      ]);
  }
}
function __oauthCallback(context: QueryFunctionContext) {
  return Client().oauthCallback(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as string | undefined    );
}

export function useOauthCallbackQuery<TSelectData = void, TError = unknown>(dto: OauthCallbackQueryParameters, options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param code (optional) 
 * @param locale (optional) 
 * @param state (optional) 
 * @param userState (optional) 
 * @param api_version (optional) 
 * @return Success
 */
export function useOauthCallbackQuery<TSelectData = void, TError = unknown>(code: string | undefined, locale: string | undefined, state: string | undefined, userState: string | undefined, api_version: string | undefined, options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useOauthCallbackQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let code: any = undefined;
  let locale: any = undefined;
  let state: any = undefined;
  let userState: any = undefined;
  let api_version: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ code, locale, state, userState, api_version,  } = params[0] as OauthCallbackQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [code, locale, state, userState, api_version, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __oauthCallback,
    queryKey: oauthCallbackQueryKey(code, locale, state, userState, api_version),
    ...oauthCallbackDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * @param code (optional) 
 * @param locale (optional) 
 * @param state (optional) 
 * @param userState (optional) 
 * @param api_version (optional) 
 * @return Success
 */
export function setOauthCallbackData(queryClient: QueryClient, updater: (data: void | undefined) => void, code: string | undefined, locale: string | undefined, state: string | undefined, userState: string | undefined, api_version: string | undefined) {
  queryClient.setQueryData(oauthCallbackQueryKey(code, locale, state, userState, api_version),
    updater
  );
}

/**
 * @param code (optional) 
 * @param locale (optional) 
 * @param state (optional) 
 * @param userState (optional) 
 * @param api_version (optional) 
 * @return Success
 */
export function setOauthCallbackDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function broadcasttalentsGETUrl(nickName: string | undefined, name: string | undefined, gameId: number | undefined, languageId: number | undefined, countryId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/broadcasttalents?";
if (nickName === null)
    throw new Error("The parameter 'nickName' cannot be null.");
else if (nickName !== undefined)
    url_ += "NickName=" + encodeURIComponent("" + nickName) + "&";
if (name === null)
    throw new Error("The parameter 'name' cannot be null.");
else if (name !== undefined)
    url_ += "Name=" + encodeURIComponent("" + name) + "&";
if (gameId === null)
    throw new Error("The parameter 'gameId' cannot be null.");
else if (gameId !== undefined)
    url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
if (languageId === null)
    throw new Error("The parameter 'languageId' cannot be null.");
else if (languageId !== undefined)
    url_ += "LanguageId=" + encodeURIComponent("" + languageId) + "&";
if (countryId === null)
    throw new Error("The parameter 'countryId' cannot be null.");
else if (countryId !== undefined)
    url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let broadcasttalentsGETDefaultOptions: UseQueryOptions<Types.GetBroadcastTalentsRespApiRespBase, unknown, Types.GetBroadcastTalentsRespApiRespBase> = {
  queryFn: __broadcasttalentsGET,
};
export function getBroadcasttalentsGETDefaultOptions(): UseQueryOptions<Types.GetBroadcastTalentsRespApiRespBase, unknown, Types.GetBroadcastTalentsRespApiRespBase> {
  return broadcasttalentsGETDefaultOptions;
};
export function setBroadcasttalentsGETDefaultOptions(options: UseQueryOptions<Types.GetBroadcastTalentsRespApiRespBase, unknown, Types.GetBroadcastTalentsRespApiRespBase>) {
  broadcasttalentsGETDefaultOptions = options;
}

export function broadcasttalentsGETQueryKey(dto: BroadcasttalentsGETQueryParameters): QueryKey;
export function broadcasttalentsGETQueryKey(nickName: string | undefined, name: string | undefined, gameId: number | undefined, languageId: number | undefined, countryId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function broadcasttalentsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { nickName, name, gameId, languageId, countryId, pageNo, pageSize,  } = params[0] as BroadcasttalentsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'broadcasttalentsGET',
        nickName as any,
        name as any,
        gameId as any,
        languageId as any,
        countryId as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'broadcasttalentsGET',
        ...params
      ]);
  }
}
function __broadcasttalentsGET(context: QueryFunctionContext) {
  return Client().broadcasttalentsGET(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as number | undefined,       context.queryKey[7] as number | undefined,       context.queryKey[8] as number | undefined    );
}

export function useBroadcasttalentsGETQuery<TSelectData = Types.GetBroadcastTalentsRespApiRespBase, TError = unknown>(dto: BroadcasttalentsGETQueryParameters, options?: UseQueryOptions<Types.GetBroadcastTalentsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get broadcast talents by condition
 * @param nickName (optional) Name
 * @param name (optional) FirstName/LastName
 * @param gameId (optional) Primary game Id
 * @param languageId (optional) LanguageId
 * @param countryId (optional) CountryId
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useBroadcasttalentsGETQuery<TSelectData = Types.GetBroadcastTalentsRespApiRespBase, TError = unknown>(nickName: string | undefined, name: string | undefined, gameId: number | undefined, languageId: number | undefined, countryId: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetBroadcastTalentsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useBroadcasttalentsGETQuery<TSelectData = Types.GetBroadcastTalentsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetBroadcastTalentsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let nickName: any = undefined;
  let name: any = undefined;
  let gameId: any = undefined;
  let languageId: any = undefined;
  let countryId: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ nickName, name, gameId, languageId, countryId, pageNo, pageSize,  } = params[0] as BroadcasttalentsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [nickName, name, gameId, languageId, countryId, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetBroadcastTalentsRespApiRespBase, TError, TSelectData>({
    queryFn: __broadcasttalentsGET,
    queryKey: broadcasttalentsGETQueryKey(nickName, name, gameId, languageId, countryId, pageNo, pageSize),
    ...broadcasttalentsGETDefaultOptions as unknown as UseQueryOptions<Types.GetBroadcastTalentsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get broadcast talents by condition
 * @param nickName (optional) Name
 * @param name (optional) FirstName/LastName
 * @param gameId (optional) Primary game Id
 * @param languageId (optional) LanguageId
 * @param countryId (optional) CountryId
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setBroadcasttalentsGETData(queryClient: QueryClient, updater: (data: Types.GetBroadcastTalentsRespApiRespBase | undefined) => Types.GetBroadcastTalentsRespApiRespBase, nickName: string | undefined, name: string | undefined, gameId: number | undefined, languageId: number | undefined, countryId: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(broadcasttalentsGETQueryKey(nickName, name, gameId, languageId, countryId, pageNo, pageSize),
    updater
  );
}

/**
 * Get broadcast talents by condition
 * @param nickName (optional) Name
 * @param name (optional) FirstName/LastName
 * @param gameId (optional) Primary game Id
 * @param languageId (optional) LanguageId
 * @param countryId (optional) CountryId
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setBroadcasttalentsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetBroadcastTalentsRespApiRespBase | undefined) => Types.GetBroadcastTalentsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function broadcasttalentsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/broadcasttalents";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function broadcasttalentsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'broadcasttalentsPOST',
    ]);
}

/**
 * Add new broadcast talent
 * @param name (optional) Name
 * @param firstName (optional) First Name
 * @param lastName (optional) Last Name
 * @param countryId (optional) Country Id
 * @param languageId (optional) Language Id
 * @param type (optional) 
 * @param isActive (optional) IsActive
 * @param about (optional) About
 * @param gender (optional) Gender (Male=0/Female=1)
 * @param dateOfBirth (optional) DateOfBirth (ex:2022-12-01)
 * @param primaryGameId (optional) Primary Game Id
 * @param profileImage (optional) Profile Image
 * @param headerImage (optional) Header Image
 * @param playerId (optional) Player Id
 * @param personalStreamId (optional) Person Stream Id
 * @param website (optional) WebSite
 * @param facebook (optional) Facebook
 * @param twitter (optional) Twitter
 * @param youtube (optional) Youtube
 * @return Error
 */
export function useBroadcasttalentsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddBroadcastTalentRespApiRespBase, unknown, BroadcasttalentsPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddBroadcastTalentRespApiRespBase, unknown, BroadcasttalentsPOSTMutationParameters, TContext> {
  const key = broadcasttalentsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((broadcasttalentsPOSTMutationParameters: BroadcasttalentsPOSTMutationParameters) => Client().broadcasttalentsPOST(broadcasttalentsPOSTMutationParameters.name, broadcasttalentsPOSTMutationParameters.firstName, broadcasttalentsPOSTMutationParameters.lastName, broadcasttalentsPOSTMutationParameters.countryId, broadcasttalentsPOSTMutationParameters.languageId, broadcasttalentsPOSTMutationParameters.type, broadcasttalentsPOSTMutationParameters.isActive, broadcasttalentsPOSTMutationParameters.about, broadcasttalentsPOSTMutationParameters.gender, broadcasttalentsPOSTMutationParameters.dateOfBirth, broadcasttalentsPOSTMutationParameters.primaryGameId, broadcasttalentsPOSTMutationParameters.profileImage, broadcasttalentsPOSTMutationParameters.headerImage, broadcasttalentsPOSTMutationParameters.playerId, broadcasttalentsPOSTMutationParameters.personalStreamId, broadcasttalentsPOSTMutationParameters.website, broadcasttalentsPOSTMutationParameters.facebook, broadcasttalentsPOSTMutationParameters.twitter, broadcasttalentsPOSTMutationParameters.youtube), {...options, mutationKey: key});
}
  
    
export function broadcasttalentsGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/broadcasttalents/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let broadcasttalentsGET2DefaultOptions: UseQueryOptions<Types.GetBroadcastTalentRespApiRespBase, unknown, Types.GetBroadcastTalentRespApiRespBase> = {
  queryFn: __broadcasttalentsGET2,
};
export function getBroadcasttalentsGET2DefaultOptions(): UseQueryOptions<Types.GetBroadcastTalentRespApiRespBase, unknown, Types.GetBroadcastTalentRespApiRespBase> {
  return broadcasttalentsGET2DefaultOptions;
};
export function setBroadcasttalentsGET2DefaultOptions(options: UseQueryOptions<Types.GetBroadcastTalentRespApiRespBase, unknown, Types.GetBroadcastTalentRespApiRespBase>) {
  broadcasttalentsGET2DefaultOptions = options;
}

export function broadcasttalentsGET2QueryKey(id: number): QueryKey;
export function broadcasttalentsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as BroadcasttalentsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'broadcasttalentsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'broadcasttalentsGET2',
        ...params
      ]);
  }
}
function __broadcasttalentsGET2(context: QueryFunctionContext) {
  return Client().broadcasttalentsGET2(
      context.queryKey[2] as number    );
}

export function useBroadcasttalentsGET2Query<TSelectData = Types.GetBroadcastTalentRespApiRespBase, TError = unknown>(dto: BroadcasttalentsGET2QueryParameters, options?: UseQueryOptions<Types.GetBroadcastTalentRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get broadcast talent
 * @param id Broadcast Talent Id
 * @return Error
 */
export function useBroadcasttalentsGET2Query<TSelectData = Types.GetBroadcastTalentRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetBroadcastTalentRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useBroadcasttalentsGET2Query<TSelectData = Types.GetBroadcastTalentRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetBroadcastTalentRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as BroadcasttalentsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetBroadcastTalentRespApiRespBase, TError, TSelectData>({
    queryFn: __broadcasttalentsGET2,
    queryKey: broadcasttalentsGET2QueryKey(id),
    ...broadcasttalentsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetBroadcastTalentRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get broadcast talent
 * @param id Broadcast Talent Id
 * @return Error
 */
export function setBroadcasttalentsGET2Data(queryClient: QueryClient, updater: (data: Types.GetBroadcastTalentRespApiRespBase | undefined) => Types.GetBroadcastTalentRespApiRespBase, id: number) {
  queryClient.setQueryData(broadcasttalentsGET2QueryKey(id),
    updater
  );
}

/**
 * Get broadcast talent
 * @param id Broadcast Talent Id
 * @return Error
 */
export function setBroadcasttalentsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetBroadcastTalentRespApiRespBase | undefined) => Types.GetBroadcastTalentRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function broadcasttalentsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/broadcasttalents/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function broadcasttalentsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'broadcasttalentsPATCH',
      id as any,
    ]);
}

/**
 * Modify broadcast talent
 * @param id Broadcast Talent Id
 * @param id (optional) Broadcast Talent Id
 * @param name (optional) Name
 * @param firstName (optional) First Name
 * @param lastName (optional) Last Name
 * @param countryId (optional) Country Id
 * @param languageId (optional) Language Id
 * @param type (optional) 
 * @param isActive (optional) IsActive
 * @param about (optional) About
 * @param gender (optional) Gender (Male=0/Female=1)
 * @param dateOfBirth (optional) DateOfBirth (ex:2022-12-01)
 * @param primaryGameId (optional) Primary Game Id
 * @param profileImage (optional) Profile Image
 * @param headerImage (optional) Header Image
 * @param playerId (optional) Player Id
 * @param personalStreamId (optional) Person Stream Id
 * @param website (optional) Website
 * @param facebook (optional) Facebook
 * @param twitter (optional) Twitter
 * @param youtube (optional) Youtube
 * @return Error
 */
export function useBroadcasttalentsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModBroadcastTalentRespApiRespBase, unknown, BroadcasttalentsPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModBroadcastTalentRespApiRespBase, unknown, BroadcasttalentsPATCHMutationParameters, TContext> {
  const key = broadcasttalentsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((broadcasttalentsPATCHMutationParameters: BroadcasttalentsPATCHMutationParameters) => Client().broadcasttalentsPATCH(id, broadcasttalentsPATCHMutationParameters.id, broadcasttalentsPATCHMutationParameters.name, broadcasttalentsPATCHMutationParameters.firstName, broadcasttalentsPATCHMutationParameters.lastName, broadcasttalentsPATCHMutationParameters.countryId, broadcasttalentsPATCHMutationParameters.languageId, broadcasttalentsPATCHMutationParameters.type, broadcasttalentsPATCHMutationParameters.isActive, broadcasttalentsPATCHMutationParameters.about, broadcasttalentsPATCHMutationParameters.gender, broadcasttalentsPATCHMutationParameters.dateOfBirth, broadcasttalentsPATCHMutationParameters.primaryGameId, broadcasttalentsPATCHMutationParameters.profileImage, broadcasttalentsPATCHMutationParameters.headerImage, broadcasttalentsPATCHMutationParameters.playerId, broadcasttalentsPATCHMutationParameters.personalStreamId, broadcasttalentsPATCHMutationParameters.website, broadcasttalentsPATCHMutationParameters.facebook, broadcasttalentsPATCHMutationParameters.twitter, broadcasttalentsPATCHMutationParameters.youtube), {...options, mutationKey: key});
}
  
    
export function broadcasttalentsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/broadcasttalents/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function broadcasttalentsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'broadcasttalentsDELETE',
      id as any,
    ]);
}

/**
 * Delete broadcast talent
 * @param id Broadcast Talent Id
 * @return Error
 */
export function useBroadcasttalentsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelBroadcastTalentRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelBroadcastTalentRespApiRespBase, unknown, void, TContext> {
  const key = broadcasttalentsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().broadcasttalentsDELETE(id), {...options, mutationKey: key});
}
  
    
export function mediaItemsGETUrl(id: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/broadcasttalents/media-items?";
if (id === null)
    throw new Error("The parameter 'id' cannot be null.");
else if (id !== undefined)
    url_ += "Id=" + encodeURIComponent("" + id) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let mediaItemsGETDefaultOptions: UseQueryOptions<Types.GetMediaItemsRespApiRespBase, unknown, Types.GetMediaItemsRespApiRespBase> = {
  queryFn: __mediaItemsGET,
};
export function getMediaItemsGETDefaultOptions(): UseQueryOptions<Types.GetMediaItemsRespApiRespBase, unknown, Types.GetMediaItemsRespApiRespBase> {
  return mediaItemsGETDefaultOptions;
};
export function setMediaItemsGETDefaultOptions(options: UseQueryOptions<Types.GetMediaItemsRespApiRespBase, unknown, Types.GetMediaItemsRespApiRespBase>) {
  mediaItemsGETDefaultOptions = options;
}

export function mediaItemsGETQueryKey(dto: MediaItemsGETQueryParameters): QueryKey;
export function mediaItemsGETQueryKey(id: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function mediaItemsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, pageNo, pageSize,  } = params[0] as MediaItemsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'mediaItemsGET',
        id as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'mediaItemsGET',
        ...params
      ]);
  }
}
function __mediaItemsGET(context: QueryFunctionContext) {
  return Client().mediaItemsGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined    );
}

export function useMediaItemsGETQuery<TSelectData = Types.GetMediaItemsRespApiRespBase, TError = unknown>(dto: MediaItemsGETQueryParameters, options?: UseQueryOptions<Types.GetMediaItemsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get broadcast talents Media items
 * @param id (optional) Broadcast Talent Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useMediaItemsGETQuery<TSelectData = Types.GetMediaItemsRespApiRespBase, TError = unknown>(id: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetMediaItemsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMediaItemsGETQuery<TSelectData = Types.GetMediaItemsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetMediaItemsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, pageNo, pageSize,  } = params[0] as MediaItemsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetMediaItemsRespApiRespBase, TError, TSelectData>({
    queryFn: __mediaItemsGET,
    queryKey: mediaItemsGETQueryKey(id, pageNo, pageSize),
    ...mediaItemsGETDefaultOptions as unknown as UseQueryOptions<Types.GetMediaItemsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get broadcast talents Media items
 * @param id (optional) Broadcast Talent Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setMediaItemsGETData(queryClient: QueryClient, updater: (data: Types.GetMediaItemsRespApiRespBase | undefined) => Types.GetMediaItemsRespApiRespBase, id: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(mediaItemsGETQueryKey(id, pageNo, pageSize),
    updater
  );
}

/**
 * Get broadcast talents Media items
 * @param id (optional) Broadcast Talent Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setMediaItemsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetMediaItemsRespApiRespBase | undefined) => Types.GetMediaItemsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function mediaItemsPOSTUrl(broadcastTalentId: number, mediaItems: number[]): string {
  let url_ = getBaseUrl() + "/api/v4/broadcasttalents/media-items?";
  if (broadcastTalentId === undefined || broadcastTalentId === null)
    throw new Error("The parameter 'broadcastTalentId' must be defined and cannot be null.");
  else
    url_ += "BroadcastTalentId=" + encodeURIComponent("" + broadcastTalentId) + "&";
  if (mediaItems === undefined || mediaItems === null)
    throw new Error("The parameter 'mediaItems' must be defined and cannot be null.");
  else
    mediaItems && mediaItems.forEach(item => { url_ += "MediaItems=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function mediaItemsPOSTMutationKey(broadcastTalentId: number, mediaItems: number[]): MutationKey {
  return trimArrayEnd([
      'Client',
      'mediaItemsPOST',
      broadcastTalentId as any,
      mediaItems as any,
    ]);
}

/**
 * Add broadcast talent new Media items
 * @param broadcastTalentId Broadcast Talent Id
 * @param mediaItems Media item Ids
 * @return Error
 */
export function useMediaItemsPOSTMutation<TContext>(broadcastTalentId: number, mediaItems: number[], options?: Omit<UseMutationOptions<Types.AddMediaItemsRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddMediaItemsRespApiRespBase, unknown, void, TContext> {
  const key = mediaItemsPOSTMutationKey(broadcastTalentId, mediaItems);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().mediaItemsPOST(broadcastTalentId, mediaItems), {...options, mutationKey: key});
}
  
    
export function mediaItemsDELETEUrl(broadcastid: number, mediaitemid: number): string {
  let url_ = getBaseUrl() + "/api/v4/broadcasttalents/{broadcastid}/media-items/{mediaitemid}";
if (broadcastid === undefined || broadcastid === null)
  throw new Error("The parameter 'broadcastid' must be defined.");
url_ = url_.replace("{broadcastid}", encodeURIComponent("" + broadcastid));
if (mediaitemid === undefined || mediaitemid === null)
  throw new Error("The parameter 'mediaitemid' must be defined.");
url_ = url_.replace("{mediaitemid}", encodeURIComponent("" + mediaitemid));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function mediaItemsDELETEMutationKey(broadcastid: number, mediaitemid: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'mediaItemsDELETE',
      broadcastid as any,
      mediaitemid as any,
    ]);
}

/**
 * Delete broadcast talent Media item
 * @param broadcastid Broadcast Talent Id
 * @param mediaitemid Media Item Id
 * @return Error
 */
export function useMediaItemsDELETEMutation<TContext>(broadcastid: number, mediaitemid: number, options?: Omit<UseMutationOptions<Types.DelMediaItemRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelMediaItemRespApiRespBase, unknown, void, TContext> {
  const key = mediaItemsDELETEMutationKey(broadcastid, mediaitemid);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().mediaItemsDELETE(broadcastid, mediaitemid), {...options, mutationKey: key});
}
  
    
export function enumretUrl(api_version: string | undefined): string {
  let url_ = getBaseUrl() + "/enumret?";
if (api_version === null)
    throw new Error("The parameter 'api_version' cannot be null.");
else if (api_version !== undefined)
    url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let enumretDefaultOptions: UseQueryOptions<Types.Int32StringDictionaryApiRespBase, unknown, Types.Int32StringDictionaryApiRespBase> = {
  queryFn: __enumret,
};
export function getEnumretDefaultOptions(): UseQueryOptions<Types.Int32StringDictionaryApiRespBase, unknown, Types.Int32StringDictionaryApiRespBase> {
  return enumretDefaultOptions;
};
export function setEnumretDefaultOptions(options: UseQueryOptions<Types.Int32StringDictionaryApiRespBase, unknown, Types.Int32StringDictionaryApiRespBase>) {
  enumretDefaultOptions = options;
}

export function enumretQueryKey(api_version: string | undefined): QueryKey;
export function enumretQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { api_version,  } = params[0] as EnumretQueryParameters;

    return trimArrayEnd([
        'Client',
        'enumret',
        api_version as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'enumret',
        ...params
      ]);
  }
}
function __enumret(context: QueryFunctionContext) {
  return Client().enumret(
      context.queryKey[2] as string | undefined    );
}

export function useEnumretQuery<TSelectData = Types.Int32StringDictionaryApiRespBase, TError = unknown>(dto: EnumretQueryParameters, options?: UseQueryOptions<Types.Int32StringDictionaryApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get EnumRet List
 * @param api_version (optional) 
 * @return Success
 */
export function useEnumretQuery<TSelectData = Types.Int32StringDictionaryApiRespBase, TError = unknown>(api_version: string | undefined, options?: UseQueryOptions<Types.Int32StringDictionaryApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useEnumretQuery<TSelectData = Types.Int32StringDictionaryApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Int32StringDictionaryApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let api_version: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ api_version,  } = params[0] as EnumretQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [api_version, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.Int32StringDictionaryApiRespBase, TError, TSelectData>({
    queryFn: __enumret,
    queryKey: enumretQueryKey(api_version),
    ...enumretDefaultOptions as unknown as UseQueryOptions<Types.Int32StringDictionaryApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get EnumRet List
 * @param api_version (optional) 
 * @return Success
 */
export function setEnumretData(queryClient: QueryClient, updater: (data: Types.Int32StringDictionaryApiRespBase | undefined) => Types.Int32StringDictionaryApiRespBase, api_version: string | undefined) {
  queryClient.setQueryData(enumretQueryKey(api_version),
    updater
  );
}

/**
 * Get EnumRet List
 * @param api_version (optional) 
 * @return Success
 */
export function setEnumretDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Int32StringDictionaryApiRespBase | undefined) => Types.Int32StringDictionaryApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function crewFoldersGETUrl(parentId: number | undefined, uploadType: string | undefined, sort: Types.EnumFieldSort | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/files/crew-folders?";
if (parentId === null)
    throw new Error("The parameter 'parentId' cannot be null.");
else if (parentId !== undefined)
    url_ += "ParentId=" + encodeURIComponent("" + parentId) + "&";
if (uploadType === null)
    throw new Error("The parameter 'uploadType' cannot be null.");
else if (uploadType !== undefined)
    url_ += "UploadType=" + encodeURIComponent("" + uploadType) + "&";
if (sort === null)
    throw new Error("The parameter 'sort' cannot be null.");
else if (sort !== undefined)
    url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let crewFoldersGETDefaultOptions: UseQueryOptions<Types.GetCrewFoldersRespApiRespBase, unknown, Types.GetCrewFoldersRespApiRespBase> = {
  queryFn: __crewFoldersGET,
};
export function getCrewFoldersGETDefaultOptions(): UseQueryOptions<Types.GetCrewFoldersRespApiRespBase, unknown, Types.GetCrewFoldersRespApiRespBase> {
  return crewFoldersGETDefaultOptions;
};
export function setCrewFoldersGETDefaultOptions(options: UseQueryOptions<Types.GetCrewFoldersRespApiRespBase, unknown, Types.GetCrewFoldersRespApiRespBase>) {
  crewFoldersGETDefaultOptions = options;
}

export function crewFoldersGETQueryKey(dto: CrewFoldersGETQueryParameters): QueryKey;
export function crewFoldersGETQueryKey(parentId: number | undefined, uploadType: string | undefined, sort: Types.EnumFieldSort | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function crewFoldersGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { parentId, uploadType, sort, pageNo, pageSize,  } = params[0] as CrewFoldersGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'crewFoldersGET',
        parentId as any,
        uploadType as any,
        sort as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'crewFoldersGET',
        ...params
      ]);
  }
}
function __crewFoldersGET(context: QueryFunctionContext) {
  return Client().crewFoldersGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as Types.EnumFieldSort | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as number | undefined    );
}

export function useCrewFoldersGETQuery<TSelectData = Types.GetCrewFoldersRespApiRespBase, TError = unknown>(dto: CrewFoldersGETQueryParameters, options?: UseQueryOptions<Types.GetCrewFoldersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get folders
 * @param parentId (optional) 
 * @param uploadType (optional) 
 * @param sort (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useCrewFoldersGETQuery<TSelectData = Types.GetCrewFoldersRespApiRespBase, TError = unknown>(parentId: number | undefined, uploadType: string | undefined, sort: Types.EnumFieldSort | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetCrewFoldersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useCrewFoldersGETQuery<TSelectData = Types.GetCrewFoldersRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetCrewFoldersRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let parentId: any = undefined;
  let uploadType: any = undefined;
  let sort: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ parentId, uploadType, sort, pageNo, pageSize,  } = params[0] as CrewFoldersGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [parentId, uploadType, sort, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetCrewFoldersRespApiRespBase, TError, TSelectData>({
    queryFn: __crewFoldersGET,
    queryKey: crewFoldersGETQueryKey(parentId, uploadType, sort, pageNo, pageSize),
    ...crewFoldersGETDefaultOptions as unknown as UseQueryOptions<Types.GetCrewFoldersRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get folders
 * @param parentId (optional) 
 * @param uploadType (optional) 
 * @param sort (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setCrewFoldersGETData(queryClient: QueryClient, updater: (data: Types.GetCrewFoldersRespApiRespBase | undefined) => Types.GetCrewFoldersRespApiRespBase, parentId: number | undefined, uploadType: string | undefined, sort: Types.EnumFieldSort | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(crewFoldersGETQueryKey(parentId, uploadType, sort, pageNo, pageSize),
    updater
  );
}

/**
 * Get folders
 * @param parentId (optional) 
 * @param uploadType (optional) 
 * @param sort (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setCrewFoldersGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetCrewFoldersRespApiRespBase | undefined) => Types.GetCrewFoldersRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function crewFoldersPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/files/crew-folders";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function crewFoldersPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'crewFoldersPOST',
    ]);
}

/**
 * Add folder
 * @param parentId (optional) 
 * @param folderName (optional) 
 * @return Error
 */
export function useCrewFoldersPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddFolderRespApiRespBase, unknown, CrewFoldersPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddFolderRespApiRespBase, unknown, CrewFoldersPOSTMutationParameters, TContext> {
  const key = crewFoldersPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((crewFoldersPOSTMutationParameters: CrewFoldersPOSTMutationParameters) => Client().crewFoldersPOST(crewFoldersPOSTMutationParameters.parentId, crewFoldersPOSTMutationParameters.folderName), {...options, mutationKey: key});
}
  
    
export function crewFilesGETUrl(folderId: number, fileName: string | undefined, uploader: string | undefined, uploadedFrom: number | undefined, uploadedTo: number | undefined, nameSort: Types.EnumFieldSort | undefined, uploadedSort: Types.EnumFieldSort | undefined, uploaderSort: Types.EnumFieldSort | undefined, sizeSort: Types.EnumFieldSort | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/files/crew-files?";
  if (folderId === undefined || folderId === null)
    throw new Error("The parameter 'folderId' must be defined and cannot be null.");
  else
    url_ += "FolderId=" + encodeURIComponent("" + folderId) + "&";
if (fileName === null)
    throw new Error("The parameter 'fileName' cannot be null.");
else if (fileName !== undefined)
    url_ += "FileName=" + encodeURIComponent("" + fileName) + "&";
if (uploader === null)
    throw new Error("The parameter 'uploader' cannot be null.");
else if (uploader !== undefined)
    url_ += "Uploader=" + encodeURIComponent("" + uploader) + "&";
if (uploadedFrom === null)
    throw new Error("The parameter 'uploadedFrom' cannot be null.");
else if (uploadedFrom !== undefined)
    url_ += "UploadedFrom=" + encodeURIComponent("" + uploadedFrom) + "&";
if (uploadedTo === null)
    throw new Error("The parameter 'uploadedTo' cannot be null.");
else if (uploadedTo !== undefined)
    url_ += "UploadedTo=" + encodeURIComponent("" + uploadedTo) + "&";
if (nameSort === null)
    throw new Error("The parameter 'nameSort' cannot be null.");
else if (nameSort !== undefined)
    url_ += "NameSort=" + encodeURIComponent("" + nameSort) + "&";
if (uploadedSort === null)
    throw new Error("The parameter 'uploadedSort' cannot be null.");
else if (uploadedSort !== undefined)
    url_ += "UploadedSort=" + encodeURIComponent("" + uploadedSort) + "&";
if (uploaderSort === null)
    throw new Error("The parameter 'uploaderSort' cannot be null.");
else if (uploaderSort !== undefined)
    url_ += "UploaderSort=" + encodeURIComponent("" + uploaderSort) + "&";
if (sizeSort === null)
    throw new Error("The parameter 'sizeSort' cannot be null.");
else if (sizeSort !== undefined)
    url_ += "SizeSort=" + encodeURIComponent("" + sizeSort) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let crewFilesGETDefaultOptions: UseQueryOptions<Types.GetCrewFilesRespApiRespBase, unknown, Types.GetCrewFilesRespApiRespBase> = {
  queryFn: __crewFilesGET,
};
export function getCrewFilesGETDefaultOptions(): UseQueryOptions<Types.GetCrewFilesRespApiRespBase, unknown, Types.GetCrewFilesRespApiRespBase> {
  return crewFilesGETDefaultOptions;
};
export function setCrewFilesGETDefaultOptions(options: UseQueryOptions<Types.GetCrewFilesRespApiRespBase, unknown, Types.GetCrewFilesRespApiRespBase>) {
  crewFilesGETDefaultOptions = options;
}

export function crewFilesGETQueryKey(dto: CrewFilesGETQueryParameters): QueryKey;
export function crewFilesGETQueryKey(folderId: number, fileName: string | undefined, uploader: string | undefined, uploadedFrom: number | undefined, uploadedTo: number | undefined, nameSort: Types.EnumFieldSort | undefined, uploadedSort: Types.EnumFieldSort | undefined, uploaderSort: Types.EnumFieldSort | undefined, sizeSort: Types.EnumFieldSort | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function crewFilesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { folderId, fileName, uploader, uploadedFrom, uploadedTo, nameSort, uploadedSort, uploaderSort, sizeSort, pageNo, pageSize,  } = params[0] as CrewFilesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'crewFilesGET',
        folderId as any,
        fileName as any,
        uploader as any,
        uploadedFrom as any,
        uploadedTo as any,
        nameSort as any,
        uploadedSort as any,
        uploaderSort as any,
        sizeSort as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'crewFilesGET',
        ...params
      ]);
  }
}
function __crewFilesGET(context: QueryFunctionContext) {
  return Client().crewFilesGET(
      context.queryKey[2] as number,       context.queryKey[3] as string | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as number | undefined,       context.queryKey[7] as Types.EnumFieldSort | undefined,       context.queryKey[8] as Types.EnumFieldSort | undefined,       context.queryKey[9] as Types.EnumFieldSort | undefined,       context.queryKey[10] as Types.EnumFieldSort | undefined,       context.queryKey[11] as number | undefined,       context.queryKey[12] as number | undefined    );
}

export function useCrewFilesGETQuery<TSelectData = Types.GetCrewFilesRespApiRespBase, TError = unknown>(dto: CrewFilesGETQueryParameters, options?: UseQueryOptions<Types.GetCrewFilesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get files
 * @param fileName (optional) 
 * @param uploader (optional) 
 * @param uploadedFrom (optional) 
 * @param uploadedTo (optional) 
 * @param nameSort (optional) 
 * @param uploadedSort (optional) 
 * @param uploaderSort (optional) 
 * @param sizeSort (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useCrewFilesGETQuery<TSelectData = Types.GetCrewFilesRespApiRespBase, TError = unknown>(folderId: number, fileName: string | undefined, uploader: string | undefined, uploadedFrom: number | undefined, uploadedTo: number | undefined, nameSort: Types.EnumFieldSort | undefined, uploadedSort: Types.EnumFieldSort | undefined, uploaderSort: Types.EnumFieldSort | undefined, sizeSort: Types.EnumFieldSort | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetCrewFilesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useCrewFilesGETQuery<TSelectData = Types.GetCrewFilesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetCrewFilesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let folderId: any = undefined;
  let fileName: any = undefined;
  let uploader: any = undefined;
  let uploadedFrom: any = undefined;
  let uploadedTo: any = undefined;
  let nameSort: any = undefined;
  let uploadedSort: any = undefined;
  let uploaderSort: any = undefined;
  let sizeSort: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ folderId, fileName, uploader, uploadedFrom, uploadedTo, nameSort, uploadedSort, uploaderSort, sizeSort, pageNo, pageSize,  } = params[0] as CrewFilesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [folderId, fileName, uploader, uploadedFrom, uploadedTo, nameSort, uploadedSort, uploaderSort, sizeSort, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetCrewFilesRespApiRespBase, TError, TSelectData>({
    queryFn: __crewFilesGET,
    queryKey: crewFilesGETQueryKey(folderId, fileName, uploader, uploadedFrom, uploadedTo, nameSort, uploadedSort, uploaderSort, sizeSort, pageNo, pageSize),
    ...crewFilesGETDefaultOptions as unknown as UseQueryOptions<Types.GetCrewFilesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get files
 * @param fileName (optional) 
 * @param uploader (optional) 
 * @param uploadedFrom (optional) 
 * @param uploadedTo (optional) 
 * @param nameSort (optional) 
 * @param uploadedSort (optional) 
 * @param uploaderSort (optional) 
 * @param sizeSort (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setCrewFilesGETData(queryClient: QueryClient, updater: (data: Types.GetCrewFilesRespApiRespBase | undefined) => Types.GetCrewFilesRespApiRespBase, folderId: number, fileName: string | undefined, uploader: string | undefined, uploadedFrom: number | undefined, uploadedTo: number | undefined, nameSort: Types.EnumFieldSort | undefined, uploadedSort: Types.EnumFieldSort | undefined, uploaderSort: Types.EnumFieldSort | undefined, sizeSort: Types.EnumFieldSort | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(crewFilesGETQueryKey(folderId, fileName, uploader, uploadedFrom, uploadedTo, nameSort, uploadedSort, uploaderSort, sizeSort, pageNo, pageSize),
    updater
  );
}

/**
 * Get files
 * @param fileName (optional) 
 * @param uploader (optional) 
 * @param uploadedFrom (optional) 
 * @param uploadedTo (optional) 
 * @param nameSort (optional) 
 * @param uploadedSort (optional) 
 * @param uploaderSort (optional) 
 * @param sizeSort (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setCrewFilesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetCrewFilesRespApiRespBase | undefined) => Types.GetCrewFilesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function crewFilesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/files/crew-files";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function crewFilesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'crewFilesPOST',
    ]);
}

/**
 * add crew file
 * @param folderId (optional) 
 * @param fileName (optional) 
 * @param file (optional) 
 * @return Error
 */
export function useCrewFilesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddFileRespApiRespBase, unknown, CrewFilesPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddFileRespApiRespBase, unknown, CrewFilesPOSTMutationParameters, TContext> {
  const key = crewFilesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((crewFilesPOSTMutationParameters: CrewFilesPOSTMutationParameters) => Client().crewFilesPOST(crewFilesPOSTMutationParameters.folderId, crewFilesPOSTMutationParameters.fileName, crewFilesPOSTMutationParameters.file), {...options, mutationKey: key});
}
  
    
export function crewFoldersPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/files/crew-folders/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function crewFoldersPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'crewFoldersPATCH',
      id as any,
    ]);
}

/**
 * Modify folder
 * @param id FolderId
 * @param id (optional) 
 * @param parentId (optional) 
 * @param name (optional) 
 * @return Error
 */
export function useCrewFoldersPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModFolderRespApiRespBase, unknown, CrewFoldersPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModFolderRespApiRespBase, unknown, CrewFoldersPATCHMutationParameters, TContext> {
  const key = crewFoldersPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((crewFoldersPATCHMutationParameters: CrewFoldersPATCHMutationParameters) => Client().crewFoldersPATCH(id, crewFoldersPATCHMutationParameters.id, crewFoldersPATCHMutationParameters.parentId, crewFoldersPATCHMutationParameters.name), {...options, mutationKey: key});
}
  
    
export function crewFoldersDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/files/crew-folders/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function crewFoldersDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'crewFoldersDELETE',
      id as any,
    ]);
}

/**
 * Delete folder
 * @param id FolderId
 * @return Error
 */
export function useCrewFoldersDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelFolderRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelFolderRespApiRespBase, unknown, void, TContext> {
  const key = crewFoldersDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().crewFoldersDELETE(id), {...options, mutationKey: key});
}
  
    
export function fuzzyFoldersUrl(folderId: number, fuzzyName: string, maxCount: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/files/fuzzy-folders?";
  if (folderId === undefined || folderId === null)
    throw new Error("The parameter 'folderId' must be defined and cannot be null.");
  else
    url_ += "FolderId=" + encodeURIComponent("" + folderId) + "&";
  if (fuzzyName === undefined || fuzzyName === null)
    throw new Error("The parameter 'fuzzyName' must be defined and cannot be null.");
  else
    url_ += "FuzzyName=" + encodeURIComponent("" + fuzzyName) + "&";
if (maxCount === null)
    throw new Error("The parameter 'maxCount' cannot be null.");
else if (maxCount !== undefined)
    url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let fuzzyFoldersDefaultOptions: UseQueryOptions<Types.GetFuzzyFoldersRespApiRespBase, unknown, Types.GetFuzzyFoldersRespApiRespBase> = {
  queryFn: __fuzzyFolders,
};
export function getFuzzyFoldersDefaultOptions(): UseQueryOptions<Types.GetFuzzyFoldersRespApiRespBase, unknown, Types.GetFuzzyFoldersRespApiRespBase> {
  return fuzzyFoldersDefaultOptions;
};
export function setFuzzyFoldersDefaultOptions(options: UseQueryOptions<Types.GetFuzzyFoldersRespApiRespBase, unknown, Types.GetFuzzyFoldersRespApiRespBase>) {
  fuzzyFoldersDefaultOptions = options;
}

export function fuzzyFoldersQueryKey(dto: FuzzyFoldersQueryParameters): QueryKey;
export function fuzzyFoldersQueryKey(folderId: number, fuzzyName: string, maxCount: number | undefined): QueryKey;
export function fuzzyFoldersQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { folderId, fuzzyName, maxCount,  } = params[0] as FuzzyFoldersQueryParameters;

    return trimArrayEnd([
        'Client',
        'fuzzyFolders',
        folderId as any,
        fuzzyName as any,
        maxCount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'fuzzyFolders',
        ...params
      ]);
  }
}
function __fuzzyFolders(context: QueryFunctionContext) {
  return Client().fuzzyFolders(
      context.queryKey[2] as number,       context.queryKey[3] as string,       context.queryKey[4] as number | undefined    );
}

export function useFuzzyFoldersQuery<TSelectData = Types.GetFuzzyFoldersRespApiRespBase, TError = unknown>(dto: FuzzyFoldersQueryParameters, options?: UseQueryOptions<Types.GetFuzzyFoldersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get fuzzy folders
 * @param maxCount (optional) 
 * @return Error
 */
export function useFuzzyFoldersQuery<TSelectData = Types.GetFuzzyFoldersRespApiRespBase, TError = unknown>(folderId: number, fuzzyName: string, maxCount: number | undefined, options?: UseQueryOptions<Types.GetFuzzyFoldersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFuzzyFoldersQuery<TSelectData = Types.GetFuzzyFoldersRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuzzyFoldersRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let folderId: any = undefined;
  let fuzzyName: any = undefined;
  let maxCount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ folderId, fuzzyName, maxCount,  } = params[0] as FuzzyFoldersQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [folderId, fuzzyName, maxCount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuzzyFoldersRespApiRespBase, TError, TSelectData>({
    queryFn: __fuzzyFolders,
    queryKey: fuzzyFoldersQueryKey(folderId, fuzzyName, maxCount),
    ...fuzzyFoldersDefaultOptions as unknown as UseQueryOptions<Types.GetFuzzyFoldersRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get fuzzy folders
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzyFoldersData(queryClient: QueryClient, updater: (data: Types.GetFuzzyFoldersRespApiRespBase | undefined) => Types.GetFuzzyFoldersRespApiRespBase, folderId: number, fuzzyName: string, maxCount: number | undefined) {
  queryClient.setQueryData(fuzzyFoldersQueryKey(folderId, fuzzyName, maxCount),
    updater
  );
}

/**
 * Get fuzzy folders
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzyFoldersDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuzzyFoldersRespApiRespBase | undefined) => Types.GetFuzzyFoldersRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function crewFilesPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/files/crew-files/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function crewFilesPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'crewFilesPATCH',
      id as any,
    ]);
}

/**
 * Modify file
 * @param id FileId
 * @param fileId (optional) 
 * @param folderId (optional) 
 * @param fileName (optional) 
 * @return Error
 */
export function useCrewFilesPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModFileRespApiRespBase, unknown, CrewFilesPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModFileRespApiRespBase, unknown, CrewFilesPATCHMutationParameters, TContext> {
  const key = crewFilesPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((crewFilesPATCHMutationParameters: CrewFilesPATCHMutationParameters) => Client().crewFilesPATCH(id, crewFilesPATCHMutationParameters.fileId, crewFilesPATCHMutationParameters.folderId, crewFilesPATCHMutationParameters.fileName), {...options, mutationKey: key});
}
  
    
export function crewFilesDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/files/crew-files/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function crewFilesDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'crewFilesDELETE',
      id as any,
    ]);
}

/**
 * Delete file
 * @param id FileId
 * @return Error
 */
export function useCrewFilesDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelFileRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelFileRespApiRespBase, unknown, void, TContext> {
  const key = crewFilesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().crewFilesDELETE(id), {...options, mutationKey: key});
}
  
    
export function frontendSiteSectionsGETUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/frontend-site-sections/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let frontendSiteSectionsGETDefaultOptions: UseQueryOptions<Types.GetFrontendSiteSectionsRespApiRespBase, unknown, Types.GetFrontendSiteSectionsRespApiRespBase> = {
  queryFn: __frontendSiteSectionsGET,
};
export function getFrontendSiteSectionsGETDefaultOptions(): UseQueryOptions<Types.GetFrontendSiteSectionsRespApiRespBase, unknown, Types.GetFrontendSiteSectionsRespApiRespBase> {
  return frontendSiteSectionsGETDefaultOptions;
};
export function setFrontendSiteSectionsGETDefaultOptions(options: UseQueryOptions<Types.GetFrontendSiteSectionsRespApiRespBase, unknown, Types.GetFrontendSiteSectionsRespApiRespBase>) {
  frontendSiteSectionsGETDefaultOptions = options;
}

export function frontendSiteSectionsGETQueryKey(id: number): QueryKey;
export function frontendSiteSectionsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as FrontendSiteSectionsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'frontendSiteSectionsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'frontendSiteSectionsGET',
        ...params
      ]);
  }
}
function __frontendSiteSectionsGET(context: QueryFunctionContext) {
  return Client().frontendSiteSectionsGET(
      context.queryKey[2] as number    );
}

export function useFrontendSiteSectionsGETQuery<TSelectData = Types.GetFrontendSiteSectionsRespApiRespBase, TError = unknown>(dto: FrontendSiteSectionsGETQueryParameters, options?: UseQueryOptions<Types.GetFrontendSiteSectionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get frontend site sections
 * @param id FrontendId
 * @return Error
 */
export function useFrontendSiteSectionsGETQuery<TSelectData = Types.GetFrontendSiteSectionsRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetFrontendSiteSectionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFrontendSiteSectionsGETQuery<TSelectData = Types.GetFrontendSiteSectionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFrontendSiteSectionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as FrontendSiteSectionsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFrontendSiteSectionsRespApiRespBase, TError, TSelectData>({
    queryFn: __frontendSiteSectionsGET,
    queryKey: frontendSiteSectionsGETQueryKey(id),
    ...frontendSiteSectionsGETDefaultOptions as unknown as UseQueryOptions<Types.GetFrontendSiteSectionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get frontend site sections
 * @param id FrontendId
 * @return Error
 */
export function setFrontendSiteSectionsGETData(queryClient: QueryClient, updater: (data: Types.GetFrontendSiteSectionsRespApiRespBase | undefined) => Types.GetFrontendSiteSectionsRespApiRespBase, id: number) {
  queryClient.setQueryData(frontendSiteSectionsGETQueryKey(id),
    updater
  );
}

/**
 * Get frontend site sections
 * @param id FrontendId
 * @return Error
 */
export function setFrontendSiteSectionsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFrontendSiteSectionsRespApiRespBase | undefined) => Types.GetFrontendSiteSectionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function frontendSiteSectionsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/frontend-site-sections";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function frontendSiteSectionsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'frontendSiteSectionsPOST',
    ]);
}

/**
 * Add frontend site sections
 * @param body (optional) Request
 * @return Error
 */
export function useFrontendSiteSectionsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddFrontendSiteSectionsRespApiRespBase, unknown, Types.AddFrontendSiteSectionsReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddFrontendSiteSectionsRespApiRespBase, unknown, Types.AddFrontendSiteSectionsReq, TContext> {
  const key = frontendSiteSectionsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.AddFrontendSiteSectionsReq) => Client().frontendSiteSectionsPOST(body), {...options, mutationKey: key});
}
  
    
export function frontendSiteSectionsPATCHUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/frontend-site-sections";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function frontendSiteSectionsPATCHMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'frontendSiteSectionsPATCH',
    ]);
}

/**
 * Modify frontend site section
 * @param body (optional) Request
 * @return Error
 */
export function useFrontendSiteSectionsPATCHMutation<TContext>(options?: Omit<UseMutationOptions<Types.ModFrontendSiteSectionRespApiRespBase, unknown, Types.ModFrontendSiteSectionReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModFrontendSiteSectionRespApiRespBase, unknown, Types.ModFrontendSiteSectionReq, TContext> {
  const key = frontendSiteSectionsPATCHMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModFrontendSiteSectionReq) => Client().frontendSiteSectionsPATCH(body), {...options, mutationKey: key});
}
  
    
export function frontendSiteSectionsDELETEUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/frontend-site-sections";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function frontendSiteSectionsDELETEMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'frontendSiteSectionsDELETE',
    ]);
}

/**
 * Delete frontend site section
 * @param body (optional) Request
 * @return Error
 */
export function useFrontendSiteSectionsDELETEMutation<TContext>(options?: Omit<UseMutationOptions<Types.DelFrontendSiteSectionRespApiRespBase, unknown, Types.DelFrontendSiteSectionReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelFrontendSiteSectionRespApiRespBase, unknown, Types.DelFrontendSiteSectionReq, TContext> {
  const key = frontendSiteSectionsDELETEMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.DelFrontendSiteSectionReq) => Client().frontendSiteSectionsDELETE(body), {...options, mutationKey: key});
}
  
    
export function types2Url(): string {
  let url_ = getBaseUrl() + "/api/v4/funcs/types";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let types2DefaultOptions: UseQueryOptions<Types.GetFuncTypesRespApiRespBase, unknown, Types.GetFuncTypesRespApiRespBase> = {
  queryFn: __types2,
};
export function getTypes2DefaultOptions(): UseQueryOptions<Types.GetFuncTypesRespApiRespBase, unknown, Types.GetFuncTypesRespApiRespBase> {
  return types2DefaultOptions;
};
export function setTypes2DefaultOptions(options: UseQueryOptions<Types.GetFuncTypesRespApiRespBase, unknown, Types.GetFuncTypesRespApiRespBase>) {
  types2DefaultOptions = options;
}

export function types2QueryKey(): QueryKey;
export function types2QueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'types2',
    ]);
}
function __types2() {
  return Client().types2(
    );
}

/**
 * Get Func Types
 * @return Error
 */
export function useTypes2Query<TSelectData = Types.GetFuncTypesRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetFuncTypesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTypes2Query<TSelectData = Types.GetFuncTypesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuncTypesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuncTypesRespApiRespBase, TError, TSelectData>({
    queryFn: __types2,
    queryKey: types2QueryKey(),
    ...types2DefaultOptions as unknown as UseQueryOptions<Types.GetFuncTypesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Func Types
 * @return Error
 */
export function setTypes2Data(queryClient: QueryClient, updater: (data: Types.GetFuncTypesRespApiRespBase | undefined) => Types.GetFuncTypesRespApiRespBase, ) {
  queryClient.setQueryData(types2QueryKey(),
    updater
  );
}

/**
 * Get Func Types
 * @return Error
 */
export function setTypes2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuncTypesRespApiRespBase | undefined) => Types.GetFuncTypesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function optionsUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/funcs/options";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let optionsDefaultOptions: UseQueryOptions<Types.GetFuncOptionsRespApiRespBase, unknown, Types.GetFuncOptionsRespApiRespBase> = {
  queryFn: __options,
};
export function getOptionsDefaultOptions(): UseQueryOptions<Types.GetFuncOptionsRespApiRespBase, unknown, Types.GetFuncOptionsRespApiRespBase> {
  return optionsDefaultOptions;
};
export function setOptionsDefaultOptions(options: UseQueryOptions<Types.GetFuncOptionsRespApiRespBase, unknown, Types.GetFuncOptionsRespApiRespBase>) {
  optionsDefaultOptions = options;
}

export function optionsQueryKey(): QueryKey;
export function optionsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'options',
    ]);
}
function __options() {
  return Client().options(
    );
}

/**
 * Get Func Options
 * @return Error
 */
export function useOptionsQuery<TSelectData = Types.GetFuncOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetFuncOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useOptionsQuery<TSelectData = Types.GetFuncOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuncOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuncOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __options,
    queryKey: optionsQueryKey(),
    ...optionsDefaultOptions as unknown as UseQueryOptions<Types.GetFuncOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Func Options
 * @return Error
 */
export function setOptionsData(queryClient: QueryClient, updater: (data: Types.GetFuncOptionsRespApiRespBase | undefined) => Types.GetFuncOptionsRespApiRespBase, ) {
  queryClient.setQueryData(optionsQueryKey(),
    updater
  );
}

/**
 * Get Func Options
 * @return Error
 */
export function setOptionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuncOptionsRespApiRespBase | undefined) => Types.GetFuncOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function funcsGETUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/funcs";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let funcsGETDefaultOptions: UseQueryOptions<Types.GetFuncsRespApiRespBase, unknown, Types.GetFuncsRespApiRespBase> = {
  queryFn: __funcsGET,
};
export function getFuncsGETDefaultOptions(): UseQueryOptions<Types.GetFuncsRespApiRespBase, unknown, Types.GetFuncsRespApiRespBase> {
  return funcsGETDefaultOptions;
};
export function setFuncsGETDefaultOptions(options: UseQueryOptions<Types.GetFuncsRespApiRespBase, unknown, Types.GetFuncsRespApiRespBase>) {
  funcsGETDefaultOptions = options;
}

export function funcsGETQueryKey(): QueryKey;
export function funcsGETQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'funcsGET',
    ]);
}
function __funcsGET() {
  return Client().funcsGET(
    );
}

/**
 * Get Funcs
 * @return Error
 */
export function useFuncsGETQuery<TSelectData = Types.GetFuncsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetFuncsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFuncsGETQuery<TSelectData = Types.GetFuncsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuncsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuncsRespApiRespBase, TError, TSelectData>({
    queryFn: __funcsGET,
    queryKey: funcsGETQueryKey(),
    ...funcsGETDefaultOptions as unknown as UseQueryOptions<Types.GetFuncsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Funcs
 * @return Error
 */
export function setFuncsGETData(queryClient: QueryClient, updater: (data: Types.GetFuncsRespApiRespBase | undefined) => Types.GetFuncsRespApiRespBase, ) {
  queryClient.setQueryData(funcsGETQueryKey(),
    updater
  );
}

/**
 * Get Funcs
 * @return Error
 */
export function setFuncsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuncsRespApiRespBase | undefined) => Types.GetFuncsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function funcsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/funcs";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function funcsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'funcsPOST',
    ]);
}

/**
 * Add Func
 * @param funcId (optional) Func id
 * @param name (optional) Func name
 * @param code (optional) Func code
 * @param type (optional) 
 * @param parentId (optional) Parent func id
 * @param position (optional) Func position
 * @param url (optional) Func url
 * @param icon (optional) Func icon
 * @return Error
 */
export function useFuncsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddFuncRespApiRespBase, unknown, FuncsPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddFuncRespApiRespBase, unknown, FuncsPOSTMutationParameters, TContext> {
  const key = funcsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((funcsPOSTMutationParameters: FuncsPOSTMutationParameters) => Client().funcsPOST(funcsPOSTMutationParameters.funcId, funcsPOSTMutationParameters.name, funcsPOSTMutationParameters.code, funcsPOSTMutationParameters.type, funcsPOSTMutationParameters.parentId, funcsPOSTMutationParameters.position, funcsPOSTMutationParameters.url, funcsPOSTMutationParameters.icon), {...options, mutationKey: key});
}
  
    
export function funcsGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/funcs/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let funcsGET2DefaultOptions: UseQueryOptions<Types.GetFuncRespApiRespBase, unknown, Types.GetFuncRespApiRespBase> = {
  queryFn: __funcsGET2,
};
export function getFuncsGET2DefaultOptions(): UseQueryOptions<Types.GetFuncRespApiRespBase, unknown, Types.GetFuncRespApiRespBase> {
  return funcsGET2DefaultOptions;
};
export function setFuncsGET2DefaultOptions(options: UseQueryOptions<Types.GetFuncRespApiRespBase, unknown, Types.GetFuncRespApiRespBase>) {
  funcsGET2DefaultOptions = options;
}

export function funcsGET2QueryKey(id: number): QueryKey;
export function funcsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as FuncsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'funcsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'funcsGET2',
        ...params
      ]);
  }
}
function __funcsGET2(context: QueryFunctionContext) {
  return Client().funcsGET2(
      context.queryKey[2] as number    );
}

export function useFuncsGET2Query<TSelectData = Types.GetFuncRespApiRespBase, TError = unknown>(dto: FuncsGET2QueryParameters, options?: UseQueryOptions<Types.GetFuncRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get Func
 * @param id FuncId
 * @return Error
 */
export function useFuncsGET2Query<TSelectData = Types.GetFuncRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetFuncRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFuncsGET2Query<TSelectData = Types.GetFuncRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuncRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as FuncsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuncRespApiRespBase, TError, TSelectData>({
    queryFn: __funcsGET2,
    queryKey: funcsGET2QueryKey(id),
    ...funcsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetFuncRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Func
 * @param id FuncId
 * @return Error
 */
export function setFuncsGET2Data(queryClient: QueryClient, updater: (data: Types.GetFuncRespApiRespBase | undefined) => Types.GetFuncRespApiRespBase, id: number) {
  queryClient.setQueryData(funcsGET2QueryKey(id),
    updater
  );
}

/**
 * Get Func
 * @param id FuncId
 * @return Error
 */
export function setFuncsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuncRespApiRespBase | undefined) => Types.GetFuncRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function funcsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/funcs/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function funcsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'funcsPATCH',
      id as any,
    ]);
}

/**
 * Modify Func
 * @param id FuncId
 * @param funcId (optional) Func id
 * @param name (optional) Func name
 * @param code (optional) Func code
 * @param type (optional) 
 * @param parentId (optional) Parent func id
 * @param position (optional) Func position
 * @param state (optional) 
 * @param url (optional) Func url
 * @param icon (optional) Func icon
 * @return Error
 */
export function useFuncsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModFuncRespApiRespBase, unknown, FuncsPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModFuncRespApiRespBase, unknown, FuncsPATCHMutationParameters, TContext> {
  const key = funcsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((funcsPATCHMutationParameters: FuncsPATCHMutationParameters) => Client().funcsPATCH(id, funcsPATCHMutationParameters.funcId, funcsPATCHMutationParameters.name, funcsPATCHMutationParameters.code, funcsPATCHMutationParameters.type, funcsPATCHMutationParameters.parentId, funcsPATCHMutationParameters.position, funcsPATCHMutationParameters.state, funcsPATCHMutationParameters.url, funcsPATCHMutationParameters.icon), {...options, mutationKey: key});
}
  
    
export function funcsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/funcs/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function funcsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'funcsDELETE',
      id as any,
    ]);
}

/**
 * Delete Func
 * @param id FuncId
 * @return Error
 */
export function useFuncsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelFuncRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelFuncRespApiRespBase, unknown, void, TContext> {
  const key = funcsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().funcsDELETE(id), {...options, mutationKey: key});
}
  
    
export function fuzzyUrl(fuzzyPrefix: string | undefined, maxCount: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/gameraces/fuzzy?";
if (fuzzyPrefix === null)
    throw new Error("The parameter 'fuzzyPrefix' cannot be null.");
else if (fuzzyPrefix !== undefined)
    url_ += "FuzzyPrefix=" + encodeURIComponent("" + fuzzyPrefix) + "&";
if (maxCount === null)
    throw new Error("The parameter 'maxCount' cannot be null.");
else if (maxCount !== undefined)
    url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let fuzzyDefaultOptions: UseQueryOptions<Types.GetFuzzyGameRaceRespApiRespBase, unknown, Types.GetFuzzyGameRaceRespApiRespBase> = {
  queryFn: __fuzzy,
};
export function getFuzzyDefaultOptions(): UseQueryOptions<Types.GetFuzzyGameRaceRespApiRespBase, unknown, Types.GetFuzzyGameRaceRespApiRespBase> {
  return fuzzyDefaultOptions;
};
export function setFuzzyDefaultOptions(options: UseQueryOptions<Types.GetFuzzyGameRaceRespApiRespBase, unknown, Types.GetFuzzyGameRaceRespApiRespBase>) {
  fuzzyDefaultOptions = options;
}

export function fuzzyQueryKey(dto: FuzzyQueryParameters): QueryKey;
export function fuzzyQueryKey(fuzzyPrefix: string | undefined, maxCount: number | undefined): QueryKey;
export function fuzzyQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { fuzzyPrefix, maxCount,  } = params[0] as FuzzyQueryParameters;

    return trimArrayEnd([
        'Client',
        'fuzzy',
        fuzzyPrefix as any,
        maxCount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'fuzzy',
        ...params
      ]);
  }
}
function __fuzzy(context: QueryFunctionContext) {
  return Client().fuzzy(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined    );
}

export function useFuzzyQuery<TSelectData = Types.GetFuzzyGameRaceRespApiRespBase, TError = unknown>(dto: FuzzyQueryParameters, options?: UseQueryOptions<Types.GetFuzzyGameRaceRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get fuzzy gameRaces
 * @param fuzzyPrefix (optional) if FuzzyPrefix = null will get list of all GameRaces
 * @param maxCount (optional) 
 * @return Error
 */
export function useFuzzyQuery<TSelectData = Types.GetFuzzyGameRaceRespApiRespBase, TError = unknown>(fuzzyPrefix: string | undefined, maxCount: number | undefined, options?: UseQueryOptions<Types.GetFuzzyGameRaceRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFuzzyQuery<TSelectData = Types.GetFuzzyGameRaceRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuzzyGameRaceRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let fuzzyPrefix: any = undefined;
  let maxCount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ fuzzyPrefix, maxCount,  } = params[0] as FuzzyQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [fuzzyPrefix, maxCount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuzzyGameRaceRespApiRespBase, TError, TSelectData>({
    queryFn: __fuzzy,
    queryKey: fuzzyQueryKey(fuzzyPrefix, maxCount),
    ...fuzzyDefaultOptions as unknown as UseQueryOptions<Types.GetFuzzyGameRaceRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get fuzzy gameRaces
 * @param fuzzyPrefix (optional) if FuzzyPrefix = null will get list of all GameRaces
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzyData(queryClient: QueryClient, updater: (data: Types.GetFuzzyGameRaceRespApiRespBase | undefined) => Types.GetFuzzyGameRaceRespApiRespBase, fuzzyPrefix: string | undefined, maxCount: number | undefined) {
  queryClient.setQueryData(fuzzyQueryKey(fuzzyPrefix, maxCount),
    updater
  );
}

/**
 * Get fuzzy gameRaces
 * @param fuzzyPrefix (optional) if FuzzyPrefix = null will get list of all GameRaces
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzyDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuzzyGameRaceRespApiRespBase | undefined) => Types.GetFuzzyGameRaceRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gameRegionsGETUrl(gameId: number | undefined, regionName: string | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/game-regions?";
if (gameId === null)
    throw new Error("The parameter 'gameId' cannot be null.");
else if (gameId !== undefined)
    url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
if (regionName === null)
    throw new Error("The parameter 'regionName' cannot be null.");
else if (regionName !== undefined)
    url_ += "RegionName=" + encodeURIComponent("" + regionName) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let gameRegionsGETDefaultOptions: UseQueryOptions<Types.GetGameRegionsResp, unknown, Types.GetGameRegionsResp> = {
  queryFn: __gameRegionsGET,
};
export function getGameRegionsGETDefaultOptions(): UseQueryOptions<Types.GetGameRegionsResp, unknown, Types.GetGameRegionsResp> {
  return gameRegionsGETDefaultOptions;
};
export function setGameRegionsGETDefaultOptions(options: UseQueryOptions<Types.GetGameRegionsResp, unknown, Types.GetGameRegionsResp>) {
  gameRegionsGETDefaultOptions = options;
}

export function gameRegionsGETQueryKey(dto: GameRegionsGETQueryParameters): QueryKey;
export function gameRegionsGETQueryKey(gameId: number | undefined, regionName: string | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function gameRegionsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { gameId, regionName, pageNo, pageSize,  } = params[0] as GameRegionsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'gameRegionsGET',
        gameId as any,
        regionName as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'gameRegionsGET',
        ...params
      ]);
  }
}
function __gameRegionsGET(context: QueryFunctionContext) {
  return Client().gameRegionsGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as number | undefined    );
}

export function useGameRegionsGETQuery<TSelectData = Types.GetGameRegionsResp, TError = unknown>(dto: GameRegionsGETQueryParameters, options?: UseQueryOptions<Types.GetGameRegionsResp, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get game regions
 * @param gameId (optional) Game id
 * @param regionName (optional) Region name
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useGameRegionsGETQuery<TSelectData = Types.GetGameRegionsResp, TError = unknown>(gameId: number | undefined, regionName: string | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetGameRegionsResp, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGameRegionsGETQuery<TSelectData = Types.GetGameRegionsResp, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGameRegionsResp, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let gameId: any = undefined;
  let regionName: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ gameId, regionName, pageNo, pageSize,  } = params[0] as GameRegionsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [gameId, regionName, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGameRegionsResp, TError, TSelectData>({
    queryFn: __gameRegionsGET,
    queryKey: gameRegionsGETQueryKey(gameId, regionName, pageNo, pageSize),
    ...gameRegionsGETDefaultOptions as unknown as UseQueryOptions<Types.GetGameRegionsResp, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get game regions
 * @param gameId (optional) Game id
 * @param regionName (optional) Region name
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setGameRegionsGETData(queryClient: QueryClient, updater: (data: Types.GetGameRegionsResp | undefined) => Types.GetGameRegionsResp, gameId: number | undefined, regionName: string | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(gameRegionsGETQueryKey(gameId, regionName, pageNo, pageSize),
    updater
  );
}

/**
 * Get game regions
 * @param gameId (optional) Game id
 * @param regionName (optional) Region name
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setGameRegionsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGameRegionsResp | undefined) => Types.GetGameRegionsResp) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gameRegionsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/game-regions";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function gameRegionsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'gameRegionsPOST',
    ]);
}

/**
 * Add game region
 * @param body (optional) 
 * @return Error
 */
export function useGameRegionsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddGameRegionResp, unknown, Types.AddGameRegionReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddGameRegionResp, unknown, Types.AddGameRegionReq, TContext> {
  const key = gameRegionsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.AddGameRegionReq) => Client().gameRegionsPOST(body), {...options, mutationKey: key});
}
  
    
export function gameRegionsGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/game-regions/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let gameRegionsGET2DefaultOptions: UseQueryOptions<Types.GetGameRegionResp, unknown, Types.GetGameRegionResp> = {
  queryFn: __gameRegionsGET2,
};
export function getGameRegionsGET2DefaultOptions(): UseQueryOptions<Types.GetGameRegionResp, unknown, Types.GetGameRegionResp> {
  return gameRegionsGET2DefaultOptions;
};
export function setGameRegionsGET2DefaultOptions(options: UseQueryOptions<Types.GetGameRegionResp, unknown, Types.GetGameRegionResp>) {
  gameRegionsGET2DefaultOptions = options;
}

export function gameRegionsGET2QueryKey(id: number): QueryKey;
export function gameRegionsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GameRegionsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'gameRegionsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'gameRegionsGET2',
        ...params
      ]);
  }
}
function __gameRegionsGET2(context: QueryFunctionContext) {
  return Client().gameRegionsGET2(
      context.queryKey[2] as number    );
}

export function useGameRegionsGET2Query<TSelectData = Types.GetGameRegionResp, TError = unknown>(dto: GameRegionsGET2QueryParameters, options?: UseQueryOptions<Types.GetGameRegionResp, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get game region detail
 * @return Error
 */
export function useGameRegionsGET2Query<TSelectData = Types.GetGameRegionResp, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetGameRegionResp, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGameRegionsGET2Query<TSelectData = Types.GetGameRegionResp, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGameRegionResp, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GameRegionsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGameRegionResp, TError, TSelectData>({
    queryFn: __gameRegionsGET2,
    queryKey: gameRegionsGET2QueryKey(id),
    ...gameRegionsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetGameRegionResp, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get game region detail
 * @return Error
 */
export function setGameRegionsGET2Data(queryClient: QueryClient, updater: (data: Types.GetGameRegionResp | undefined) => Types.GetGameRegionResp, id: number) {
  queryClient.setQueryData(gameRegionsGET2QueryKey(id),
    updater
  );
}

/**
 * Get game region detail
 * @return Error
 */
export function setGameRegionsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGameRegionResp | undefined) => Types.GetGameRegionResp) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gameRegionsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/game-regions/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function gameRegionsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'gameRegionsPATCH',
      id as any,
    ]);
}

/**
 * Modify game region
 * @param body (optional) 
 * @return Error
 */
export function useGameRegionsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModGameRegionResp, unknown, Types.ModGameRegionReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModGameRegionResp, unknown, Types.ModGameRegionReq, TContext> {
  const key = gameRegionsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModGameRegionReq) => Client().gameRegionsPATCH(id, body), {...options, mutationKey: key});
}
  
    
export function gameRegionsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/game-regions/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function gameRegionsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'gameRegionsDELETE',
      id as any,
    ]);
}

/**
 * Delete game region
 * @return Error
 */
export function useGameRegionsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelGameRegionResp, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelGameRegionResp, unknown, void, TContext> {
  const key = gameRegionsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().gameRegionsDELETE(id), {...options, mutationKey: key});
}
  
    
export function translationsGETUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/game-regions/{id}/translations";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let translationsGETDefaultOptions: UseQueryOptions<Types.GetGameRegionTranslationResp, unknown, Types.GetGameRegionTranslationResp> = {
  queryFn: __translationsGET,
};
export function getTranslationsGETDefaultOptions(): UseQueryOptions<Types.GetGameRegionTranslationResp, unknown, Types.GetGameRegionTranslationResp> {
  return translationsGETDefaultOptions;
};
export function setTranslationsGETDefaultOptions(options: UseQueryOptions<Types.GetGameRegionTranslationResp, unknown, Types.GetGameRegionTranslationResp>) {
  translationsGETDefaultOptions = options;
}

export function translationsGETQueryKey(id: number): QueryKey;
export function translationsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as TranslationsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'translationsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'translationsGET',
        ...params
      ]);
  }
}
function __translationsGET(context: QueryFunctionContext) {
  return Client().translationsGET(
      context.queryKey[2] as number    );
}

export function useTranslationsGETQuery<TSelectData = Types.GetGameRegionTranslationResp, TError = unknown>(dto: TranslationsGETQueryParameters, options?: UseQueryOptions<Types.GetGameRegionTranslationResp, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get game region translations
 * @return Error
 */
export function useTranslationsGETQuery<TSelectData = Types.GetGameRegionTranslationResp, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetGameRegionTranslationResp, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTranslationsGETQuery<TSelectData = Types.GetGameRegionTranslationResp, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGameRegionTranslationResp, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as TranslationsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGameRegionTranslationResp, TError, TSelectData>({
    queryFn: __translationsGET,
    queryKey: translationsGETQueryKey(id),
    ...translationsGETDefaultOptions as unknown as UseQueryOptions<Types.GetGameRegionTranslationResp, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get game region translations
 * @return Error
 */
export function setTranslationsGETData(queryClient: QueryClient, updater: (data: Types.GetGameRegionTranslationResp | undefined) => Types.GetGameRegionTranslationResp, id: number) {
  queryClient.setQueryData(translationsGETQueryKey(id),
    updater
  );
}

/**
 * Get game region translations
 * @return Error
 */
export function setTranslationsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGameRegionTranslationResp | undefined) => Types.GetGameRegionTranslationResp) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function translationsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/game-regions/{id}/translations";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function translationsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'translationsPATCH',
      id as any,
    ]);
}

/**
 * Modify game region translation
 * @param body (optional) 
 * @return Error
 */
export function useTranslationsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModGameRegionTranslationRespApiRespBase, unknown, Types.ModGameRegionTranslationReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModGameRegionTranslationRespApiRespBase, unknown, Types.ModGameRegionTranslationReq, TContext> {
  const key = translationsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModGameRegionTranslationReq) => Client().translationsPATCH(id, body), {...options, mutationKey: key});
}
  
    
export function gamesGETUrl(gameName: string | undefined, isLegacy: boolean | undefined, hasPlayerRankings: boolean | undefined, hasTeamRankings: boolean | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/games?";
if (gameName === null)
    throw new Error("The parameter 'gameName' cannot be null.");
else if (gameName !== undefined)
    url_ += "GameName=" + encodeURIComponent("" + gameName) + "&";
if (isLegacy === null)
    throw new Error("The parameter 'isLegacy' cannot be null.");
else if (isLegacy !== undefined)
    url_ += "IsLegacy=" + encodeURIComponent("" + isLegacy) + "&";
if (hasPlayerRankings === null)
    throw new Error("The parameter 'hasPlayerRankings' cannot be null.");
else if (hasPlayerRankings !== undefined)
    url_ += "HasPlayerRankings=" + encodeURIComponent("" + hasPlayerRankings) + "&";
if (hasTeamRankings === null)
    throw new Error("The parameter 'hasTeamRankings' cannot be null.");
else if (hasTeamRankings !== undefined)
    url_ += "HasTeamRankings=" + encodeURIComponent("" + hasTeamRankings) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let gamesGETDefaultOptions: UseQueryOptions<Types.GetGamesRespApiRespBase, unknown, Types.GetGamesRespApiRespBase> = {
  queryFn: __gamesGET,
};
export function getGamesGETDefaultOptions(): UseQueryOptions<Types.GetGamesRespApiRespBase, unknown, Types.GetGamesRespApiRespBase> {
  return gamesGETDefaultOptions;
};
export function setGamesGETDefaultOptions(options: UseQueryOptions<Types.GetGamesRespApiRespBase, unknown, Types.GetGamesRespApiRespBase>) {
  gamesGETDefaultOptions = options;
}

export function gamesGETQueryKey(dto: GamesGETQueryParameters): QueryKey;
export function gamesGETQueryKey(gameName: string | undefined, isLegacy: boolean | undefined, hasPlayerRankings: boolean | undefined, hasTeamRankings: boolean | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function gamesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { gameName, isLegacy, hasPlayerRankings, hasTeamRankings, pageNo, pageSize,  } = params[0] as GamesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'gamesGET',
        gameName as any,
        isLegacy as any,
        hasPlayerRankings as any,
        hasTeamRankings as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'gamesGET',
        ...params
      ]);
  }
}
function __gamesGET(context: QueryFunctionContext) {
  return Client().gamesGET(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as boolean | undefined,       context.queryKey[4] as boolean | undefined,       context.queryKey[5] as boolean | undefined,       context.queryKey[6] as number | undefined,       context.queryKey[7] as number | undefined    );
}

export function useGamesGETQuery<TSelectData = Types.GetGamesRespApiRespBase, TError = unknown>(dto: GamesGETQueryParameters, options?: UseQueryOptions<Types.GetGamesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get games by condition
 * @param gameName (optional) Game name
 * @param isLegacy (optional) Is legacy
 * @param hasPlayerRankings (optional) Has player rankings
 * @param hasTeamRankings (optional) Has team rankings
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useGamesGETQuery<TSelectData = Types.GetGamesRespApiRespBase, TError = unknown>(gameName: string | undefined, isLegacy: boolean | undefined, hasPlayerRankings: boolean | undefined, hasTeamRankings: boolean | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetGamesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGamesGETQuery<TSelectData = Types.GetGamesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGamesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let gameName: any = undefined;
  let isLegacy: any = undefined;
  let hasPlayerRankings: any = undefined;
  let hasTeamRankings: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ gameName, isLegacy, hasPlayerRankings, hasTeamRankings, pageNo, pageSize,  } = params[0] as GamesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [gameName, isLegacy, hasPlayerRankings, hasTeamRankings, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGamesRespApiRespBase, TError, TSelectData>({
    queryFn: __gamesGET,
    queryKey: gamesGETQueryKey(gameName, isLegacy, hasPlayerRankings, hasTeamRankings, pageNo, pageSize),
    ...gamesGETDefaultOptions as unknown as UseQueryOptions<Types.GetGamesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get games by condition
 * @param gameName (optional) Game name
 * @param isLegacy (optional) Is legacy
 * @param hasPlayerRankings (optional) Has player rankings
 * @param hasTeamRankings (optional) Has team rankings
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setGamesGETData(queryClient: QueryClient, updater: (data: Types.GetGamesRespApiRespBase | undefined) => Types.GetGamesRespApiRespBase, gameName: string | undefined, isLegacy: boolean | undefined, hasPlayerRankings: boolean | undefined, hasTeamRankings: boolean | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(gamesGETQueryKey(gameName, isLegacy, hasPlayerRankings, hasTeamRankings, pageNo, pageSize),
    updater
  );
}

/**
 * Get games by condition
 * @param gameName (optional) Game name
 * @param isLegacy (optional) Is legacy
 * @param hasPlayerRankings (optional) Has player rankings
 * @param hasTeamRankings (optional) Has team rankings
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setGamesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGamesRespApiRespBase | undefined) => Types.GetGamesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gamesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/games";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function gamesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'gamesPOST',
    ]);
}

/**
 * Add game
 * @param name (optional) Game name
 * @param hasPlayerRankings (optional) Has player rankings
 * @param hasTeamRankings (optional) Has team rankings
 * @param hasStreams (optional) Has streams
 * @param gridId (optional) Grid id
 * @param steamAppId (optional) Steam app id
 * @param twitchGameId (optional) Twitch game id
 * @param iconImageFile (optional) Icon image file
 * @param isLegacy (optional) Is legacy
 * @param recommendedReplayCount (optional) Recommended replay count
 * @return Error
 */
export function useGamesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddGameRespApiRespBase, unknown, GamesPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddGameRespApiRespBase, unknown, GamesPOSTMutationParameters, TContext> {
  const key = gamesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((gamesPOSTMutationParameters: GamesPOSTMutationParameters) => Client().gamesPOST(gamesPOSTMutationParameters.name, gamesPOSTMutationParameters.hasPlayerRankings, gamesPOSTMutationParameters.hasTeamRankings, gamesPOSTMutationParameters.hasStreams, gamesPOSTMutationParameters.gridId, gamesPOSTMutationParameters.steamAppId, gamesPOSTMutationParameters.twitchGameId, gamesPOSTMutationParameters.iconImageFile, gamesPOSTMutationParameters.isLegacy, gamesPOSTMutationParameters.recommendedReplayCount), {...options, mutationKey: key});
}
  
    
export function gamesGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/games/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let gamesGET2DefaultOptions: UseQueryOptions<Types.GetGameRespApiRespBase, unknown, Types.GetGameRespApiRespBase> = {
  queryFn: __gamesGET2,
};
export function getGamesGET2DefaultOptions(): UseQueryOptions<Types.GetGameRespApiRespBase, unknown, Types.GetGameRespApiRespBase> {
  return gamesGET2DefaultOptions;
};
export function setGamesGET2DefaultOptions(options: UseQueryOptions<Types.GetGameRespApiRespBase, unknown, Types.GetGameRespApiRespBase>) {
  gamesGET2DefaultOptions = options;
}

export function gamesGET2QueryKey(id: number): QueryKey;
export function gamesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GamesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'gamesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'gamesGET2',
        ...params
      ]);
  }
}
function __gamesGET2(context: QueryFunctionContext) {
  return Client().gamesGET2(
      context.queryKey[2] as number    );
}

export function useGamesGET2Query<TSelectData = Types.GetGameRespApiRespBase, TError = unknown>(dto: GamesGET2QueryParameters, options?: UseQueryOptions<Types.GetGameRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get game
 * @param id GameId
 * @return Error
 */
export function useGamesGET2Query<TSelectData = Types.GetGameRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetGameRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGamesGET2Query<TSelectData = Types.GetGameRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGameRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GamesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGameRespApiRespBase, TError, TSelectData>({
    queryFn: __gamesGET2,
    queryKey: gamesGET2QueryKey(id),
    ...gamesGET2DefaultOptions as unknown as UseQueryOptions<Types.GetGameRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get game
 * @param id GameId
 * @return Error
 */
export function setGamesGET2Data(queryClient: QueryClient, updater: (data: Types.GetGameRespApiRespBase | undefined) => Types.GetGameRespApiRespBase, id: number) {
  queryClient.setQueryData(gamesGET2QueryKey(id),
    updater
  );
}

/**
 * Get game
 * @param id GameId
 * @return Error
 */
export function setGamesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGameRespApiRespBase | undefined) => Types.GetGameRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gamesDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/games/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function gamesDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'gamesDELETE',
      id as any,
    ]);
}

/**
 * Delete game
 * @param id GameId
 * @return Error
 */
export function useGamesDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelGameRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelGameRespApiRespBase, unknown, void, TContext> {
  const key = gamesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().gamesDELETE(id), {...options, mutationKey: key});
}
  
    
export function idUrl(id: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/games/id?";
if (id === null)
    throw new Error("The parameter 'id' cannot be null.");
else if (id !== undefined)
    url_ += "id=" + encodeURIComponent("" + id) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function idMutationKey(id: number | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'id',
      id as any,
    ]);
}

/**
 * Modify game
 * @param id (optional) GameId
 * @param gameId (optional) Game id
 * @param name (optional) Game name
 * @param hasPlayerRankings (optional) Has player rankings
 * @param hasTeamRankings (optional) Has team rankings
 * @param hasStreams (optional) Has streams
 * @param gridId (optional) Grid id
 * @param steamAppId (optional) Steam app id
 * @param twitchGameId (optional) Twitch game id
 * @param iconImageFile (optional) Icon image file
 * @param isLegacy (optional) Is legacy
 * @param recommendedReplayCount (optional) Recommended replay count
 * @return Error
 */
export function useIdMutation<TContext>(id: number | undefined, options?: Omit<UseMutationOptions<Types.ModGameRespApiRespBase, unknown, IdMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModGameRespApiRespBase, unknown, IdMutationParameters, TContext> {
  const key = idMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((idMutationParameters: IdMutationParameters) => Client().id(id, idMutationParameters.gameId, idMutationParameters.name, idMutationParameters.hasPlayerRankings, idMutationParameters.hasTeamRankings, idMutationParameters.hasStreams, idMutationParameters.gridId, idMutationParameters.steamAppId, idMutationParameters.twitchGameId, idMutationParameters.iconImageFile, idMutationParameters.isLegacy, idMutationParameters.recommendedReplayCount), {...options, mutationKey: key});
}
  
    
export function translationsPATCH2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/games/{id}/translations";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function translationsPATCH2MutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'translationsPATCH2',
      id as any,
    ]);
}

/**
 * Modify game translations
 * @param body (optional) 
 * @return Error
 */
export function useTranslationsPATCH2Mutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModGameTranslationsRespApiRespBase, unknown, Types.ModGameTranslationsReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModGameTranslationsRespApiRespBase, unknown, Types.ModGameTranslationsReq, TContext> {
  const key = translationsPATCH2MutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModGameTranslationsReq) => Client().translationsPATCH2(id, body), {...options, mutationKey: key});
}
  
    
export function fuzzy2Url(fuzzyPrefix: string | undefined, maxCount: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/games/fuzzy?";
if (fuzzyPrefix === null)
    throw new Error("The parameter 'fuzzyPrefix' cannot be null.");
else if (fuzzyPrefix !== undefined)
    url_ += "FuzzyPrefix=" + encodeURIComponent("" + fuzzyPrefix) + "&";
if (maxCount === null)
    throw new Error("The parameter 'maxCount' cannot be null.");
else if (maxCount !== undefined)
    url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let fuzzy2DefaultOptions: UseQueryOptions<Types.GetFuzzyGamesRespApiRespBase, unknown, Types.GetFuzzyGamesRespApiRespBase> = {
  queryFn: __fuzzy2,
};
export function getFuzzy2DefaultOptions(): UseQueryOptions<Types.GetFuzzyGamesRespApiRespBase, unknown, Types.GetFuzzyGamesRespApiRespBase> {
  return fuzzy2DefaultOptions;
};
export function setFuzzy2DefaultOptions(options: UseQueryOptions<Types.GetFuzzyGamesRespApiRespBase, unknown, Types.GetFuzzyGamesRespApiRespBase>) {
  fuzzy2DefaultOptions = options;
}

export function fuzzy2QueryKey(dto: Fuzzy2QueryParameters): QueryKey;
export function fuzzy2QueryKey(fuzzyPrefix: string | undefined, maxCount: number | undefined): QueryKey;
export function fuzzy2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { fuzzyPrefix, maxCount,  } = params[0] as Fuzzy2QueryParameters;

    return trimArrayEnd([
        'Client',
        'fuzzy2',
        fuzzyPrefix as any,
        maxCount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'fuzzy2',
        ...params
      ]);
  }
}
function __fuzzy2(context: QueryFunctionContext) {
  return Client().fuzzy2(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined    );
}

export function useFuzzy2Query<TSelectData = Types.GetFuzzyGamesRespApiRespBase, TError = unknown>(dto: Fuzzy2QueryParameters, options?: UseQueryOptions<Types.GetFuzzyGamesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get fuzzy games
 * @param fuzzyPrefix (optional) if FuzzyPrefix = null will get list of all games
 * @param maxCount (optional) 
 * @return Error
 */
export function useFuzzy2Query<TSelectData = Types.GetFuzzyGamesRespApiRespBase, TError = unknown>(fuzzyPrefix: string | undefined, maxCount: number | undefined, options?: UseQueryOptions<Types.GetFuzzyGamesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFuzzy2Query<TSelectData = Types.GetFuzzyGamesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuzzyGamesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let fuzzyPrefix: any = undefined;
  let maxCount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ fuzzyPrefix, maxCount,  } = params[0] as Fuzzy2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [fuzzyPrefix, maxCount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuzzyGamesRespApiRespBase, TError, TSelectData>({
    queryFn: __fuzzy2,
    queryKey: fuzzy2QueryKey(fuzzyPrefix, maxCount),
    ...fuzzy2DefaultOptions as unknown as UseQueryOptions<Types.GetFuzzyGamesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get fuzzy games
 * @param fuzzyPrefix (optional) if FuzzyPrefix = null will get list of all games
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzy2Data(queryClient: QueryClient, updater: (data: Types.GetFuzzyGamesRespApiRespBase | undefined) => Types.GetFuzzyGamesRespApiRespBase, fuzzyPrefix: string | undefined, maxCount: number | undefined) {
  queryClient.setQueryData(fuzzy2QueryKey(fuzzyPrefix, maxCount),
    updater
  );
}

/**
 * Get fuzzy games
 * @param fuzzyPrefix (optional) if FuzzyPrefix = null will get list of all games
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzy2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuzzyGamesRespApiRespBase | undefined) => Types.GetFuzzyGamesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gamesidesGETUrl(name: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/gamesides?";
if (name === null)
    throw new Error("The parameter 'name' cannot be null.");
else if (name !== undefined)
    url_ += "Name=" + encodeURIComponent("" + name) + "&";
if (gameId === null)
    throw new Error("The parameter 'gameId' cannot be null.");
else if (gameId !== undefined)
    url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let gamesidesGETDefaultOptions: UseQueryOptions<Types.GetSidesRespApiRespBase, unknown, Types.GetSidesRespApiRespBase> = {
  queryFn: __gamesidesGET,
};
export function getGamesidesGETDefaultOptions(): UseQueryOptions<Types.GetSidesRespApiRespBase, unknown, Types.GetSidesRespApiRespBase> {
  return gamesidesGETDefaultOptions;
};
export function setGamesidesGETDefaultOptions(options: UseQueryOptions<Types.GetSidesRespApiRespBase, unknown, Types.GetSidesRespApiRespBase>) {
  gamesidesGETDefaultOptions = options;
}

export function gamesidesGETQueryKey(dto: GamesidesGETQueryParameters): QueryKey;
export function gamesidesGETQueryKey(name: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function gamesidesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { name, gameId, pageNo, pageSize,  } = params[0] as GamesidesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'gamesidesGET',
        name as any,
        gameId as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'gamesidesGET',
        ...params
      ]);
  }
}
function __gamesidesGET(context: QueryFunctionContext) {
  return Client().gamesidesGET(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as number | undefined    );
}

export function useGamesidesGETQuery<TSelectData = Types.GetSidesRespApiRespBase, TError = unknown>(dto: GamesidesGETQueryParameters, options?: UseQueryOptions<Types.GetSidesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get sides by condition
 * @param name (optional) Side Name
 * @param gameId (optional) Side Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useGamesidesGETQuery<TSelectData = Types.GetSidesRespApiRespBase, TError = unknown>(name: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetSidesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGamesidesGETQuery<TSelectData = Types.GetSidesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetSidesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let name: any = undefined;
  let gameId: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ name, gameId, pageNo, pageSize,  } = params[0] as GamesidesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [name, gameId, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetSidesRespApiRespBase, TError, TSelectData>({
    queryFn: __gamesidesGET,
    queryKey: gamesidesGETQueryKey(name, gameId, pageNo, pageSize),
    ...gamesidesGETDefaultOptions as unknown as UseQueryOptions<Types.GetSidesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get sides by condition
 * @param name (optional) Side Name
 * @param gameId (optional) Side Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setGamesidesGETData(queryClient: QueryClient, updater: (data: Types.GetSidesRespApiRespBase | undefined) => Types.GetSidesRespApiRespBase, name: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(gamesidesGETQueryKey(name, gameId, pageNo, pageSize),
    updater
  );
}

/**
 * Get sides by condition
 * @param name (optional) Side Name
 * @param gameId (optional) Side Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setGamesidesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetSidesRespApiRespBase | undefined) => Types.GetSidesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gamesidesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/gamesides";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function gamesidesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'gamesidesPOST',
    ]);
}

/**
 * Add new game side
 * @param name (optional) Game Side Name
 * @param iconFile (optional) Icon file
 * @param gameId (optional) Side Game Id
 * @return Error
 */
export function useGamesidesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddSideRespApiRespBase, unknown, GamesidesPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddSideRespApiRespBase, unknown, GamesidesPOSTMutationParameters, TContext> {
  const key = gamesidesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((gamesidesPOSTMutationParameters: GamesidesPOSTMutationParameters) => Client().gamesidesPOST(gamesidesPOSTMutationParameters.name, gamesidesPOSTMutationParameters.iconFile, gamesidesPOSTMutationParameters.gameId), {...options, mutationKey: key});
}
  
    
export function gamesidesGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/gamesides/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let gamesidesGET2DefaultOptions: UseQueryOptions<Types.GetSideRespApiRespBase, unknown, Types.GetSideRespApiRespBase> = {
  queryFn: __gamesidesGET2,
};
export function getGamesidesGET2DefaultOptions(): UseQueryOptions<Types.GetSideRespApiRespBase, unknown, Types.GetSideRespApiRespBase> {
  return gamesidesGET2DefaultOptions;
};
export function setGamesidesGET2DefaultOptions(options: UseQueryOptions<Types.GetSideRespApiRespBase, unknown, Types.GetSideRespApiRespBase>) {
  gamesidesGET2DefaultOptions = options;
}

export function gamesidesGET2QueryKey(id: number): QueryKey;
export function gamesidesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GamesidesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'gamesidesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'gamesidesGET2',
        ...params
      ]);
  }
}
function __gamesidesGET2(context: QueryFunctionContext) {
  return Client().gamesidesGET2(
      context.queryKey[2] as number    );
}

export function useGamesidesGET2Query<TSelectData = Types.GetSideRespApiRespBase, TError = unknown>(dto: GamesidesGET2QueryParameters, options?: UseQueryOptions<Types.GetSideRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get game side
 * @param id Sides Id
 * @return Error
 */
export function useGamesidesGET2Query<TSelectData = Types.GetSideRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetSideRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGamesidesGET2Query<TSelectData = Types.GetSideRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetSideRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GamesidesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetSideRespApiRespBase, TError, TSelectData>({
    queryFn: __gamesidesGET2,
    queryKey: gamesidesGET2QueryKey(id),
    ...gamesidesGET2DefaultOptions as unknown as UseQueryOptions<Types.GetSideRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get game side
 * @param id Sides Id
 * @return Error
 */
export function setGamesidesGET2Data(queryClient: QueryClient, updater: (data: Types.GetSideRespApiRespBase | undefined) => Types.GetSideRespApiRespBase, id: number) {
  queryClient.setQueryData(gamesidesGET2QueryKey(id),
    updater
  );
}

/**
 * Get game side
 * @param id Sides Id
 * @return Error
 */
export function setGamesidesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetSideRespApiRespBase | undefined) => Types.GetSideRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gamesidesPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/gamesides/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function gamesidesPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'gamesidesPATCH',
      id as any,
    ]);
}

/**
 * Modify game side
 * @param id Game side Id
 * @param id (optional) Side Id
 * @param name (optional) Game Side Name
 * @param iconFile (optional) Icon file
 * @param gameId (optional) Side Game Id
 * @return Error
 */
export function useGamesidesPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModSideRespApiRespBase, unknown, GamesidesPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModSideRespApiRespBase, unknown, GamesidesPATCHMutationParameters, TContext> {
  const key = gamesidesPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((gamesidesPATCHMutationParameters: GamesidesPATCHMutationParameters) => Client().gamesidesPATCH(id, gamesidesPATCHMutationParameters.id, gamesidesPATCHMutationParameters.name, gamesidesPATCHMutationParameters.iconFile, gamesidesPATCHMutationParameters.gameId), {...options, mutationKey: key});
}
  
    
export function gamesidesDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/gamesides/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function gamesidesDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'gamesidesDELETE',
      id as any,
    ]);
}

/**
 * Delete game side
 * @param id Game side Id
 * @return Error
 */
export function useGamesidesDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelSideRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelSideRespApiRespBase, unknown, void, TContext> {
  const key = gamesidesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().gamesidesDELETE(id), {...options, mutationKey: key});
}
  
    
export function translationsGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/gamesides/{id}/translations";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let translationsGET2DefaultOptions: UseQueryOptions<Types.GetSideTranslationsRespApiRespBase, unknown, Types.GetSideTranslationsRespApiRespBase> = {
  queryFn: __translationsGET2,
};
export function getTranslationsGET2DefaultOptions(): UseQueryOptions<Types.GetSideTranslationsRespApiRespBase, unknown, Types.GetSideTranslationsRespApiRespBase> {
  return translationsGET2DefaultOptions;
};
export function setTranslationsGET2DefaultOptions(options: UseQueryOptions<Types.GetSideTranslationsRespApiRespBase, unknown, Types.GetSideTranslationsRespApiRespBase>) {
  translationsGET2DefaultOptions = options;
}

export function translationsGET2QueryKey(id: number): QueryKey;
export function translationsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as TranslationsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'translationsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'translationsGET2',
        ...params
      ]);
  }
}
function __translationsGET2(context: QueryFunctionContext) {
  return Client().translationsGET2(
      context.queryKey[2] as number    );
}

export function useTranslationsGET2Query<TSelectData = Types.GetSideTranslationsRespApiRespBase, TError = unknown>(dto: TranslationsGET2QueryParameters, options?: UseQueryOptions<Types.GetSideTranslationsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get game side translations
 * @param id Sides Id
 * @return Error
 */
export function useTranslationsGET2Query<TSelectData = Types.GetSideTranslationsRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetSideTranslationsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTranslationsGET2Query<TSelectData = Types.GetSideTranslationsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetSideTranslationsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as TranslationsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetSideTranslationsRespApiRespBase, TError, TSelectData>({
    queryFn: __translationsGET2,
    queryKey: translationsGET2QueryKey(id),
    ...translationsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetSideTranslationsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get game side translations
 * @param id Sides Id
 * @return Error
 */
export function setTranslationsGET2Data(queryClient: QueryClient, updater: (data: Types.GetSideTranslationsRespApiRespBase | undefined) => Types.GetSideTranslationsRespApiRespBase, id: number) {
  queryClient.setQueryData(translationsGET2QueryKey(id),
    updater
  );
}

/**
 * Get game side translations
 * @param id Sides Id
 * @return Error
 */
export function setTranslationsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetSideTranslationsRespApiRespBase | undefined) => Types.GetSideTranslationsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function translationsPATCH3Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/gamesides/{id}/translations";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function translationsPATCH3MutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'translationsPATCH3',
      id as any,
    ]);
}

/**
 * Modify game side translations
 * @param id Game side Id
 * @param body (optional) Request
 * @return Error
 */
export function useTranslationsPATCH3Mutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModSideTranslationsRespApiRespBase, unknown, Types.ModSideTranslationsReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModSideTranslationsRespApiRespBase, unknown, Types.ModSideTranslationsReq, TContext> {
  const key = translationsPATCH3MutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModSideTranslationsReq) => Client().translationsPATCH3(id, body), {...options, mutationKey: key});
}
  
    
export function groupOptionsUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/groups/group-options";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let groupOptionsDefaultOptions: UseQueryOptions<Types.GetGroupOptionsRespApiRespBase, unknown, Types.GetGroupOptionsRespApiRespBase> = {
  queryFn: __groupOptions,
};
export function getGroupOptionsDefaultOptions(): UseQueryOptions<Types.GetGroupOptionsRespApiRespBase, unknown, Types.GetGroupOptionsRespApiRespBase> {
  return groupOptionsDefaultOptions;
};
export function setGroupOptionsDefaultOptions(options: UseQueryOptions<Types.GetGroupOptionsRespApiRespBase, unknown, Types.GetGroupOptionsRespApiRespBase>) {
  groupOptionsDefaultOptions = options;
}

export function groupOptionsQueryKey(): QueryKey;
export function groupOptionsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'groupOptions',
    ]);
}
function __groupOptions() {
  return Client().groupOptions(
    );
}

/**
 * Get group options
 * @return Error
 */
export function useGroupOptionsQuery<TSelectData = Types.GetGroupOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetGroupOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGroupOptionsQuery<TSelectData = Types.GetGroupOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGroupOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGroupOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __groupOptions,
    queryKey: groupOptionsQueryKey(),
    ...groupOptionsDefaultOptions as unknown as UseQueryOptions<Types.GetGroupOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get group options
 * @return Error
 */
export function setGroupOptionsData(queryClient: QueryClient, updater: (data: Types.GetGroupOptionsRespApiRespBase | undefined) => Types.GetGroupOptionsRespApiRespBase, ) {
  queryClient.setQueryData(groupOptionsQueryKey(),
    updater
  );
}

/**
 * Get group options
 * @return Error
 */
export function setGroupOptionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGroupOptionsRespApiRespBase | undefined) => Types.GetGroupOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function groupOptionsByUserUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/groups/group-options-by-user";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let groupOptionsByUserDefaultOptions: UseQueryOptions<Types.GetGroupOptionsRespApiRespBase, unknown, Types.GetGroupOptionsRespApiRespBase> = {
  queryFn: __groupOptionsByUser,
};
export function getGroupOptionsByUserDefaultOptions(): UseQueryOptions<Types.GetGroupOptionsRespApiRespBase, unknown, Types.GetGroupOptionsRespApiRespBase> {
  return groupOptionsByUserDefaultOptions;
};
export function setGroupOptionsByUserDefaultOptions(options: UseQueryOptions<Types.GetGroupOptionsRespApiRespBase, unknown, Types.GetGroupOptionsRespApiRespBase>) {
  groupOptionsByUserDefaultOptions = options;
}

export function groupOptionsByUserQueryKey(): QueryKey;
export function groupOptionsByUserQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'groupOptionsByUser',
    ]);
}
function __groupOptionsByUser() {
  return Client().groupOptionsByUser(
    );
}

/**
 * Get group options by user
 * @return Error
 */
export function useGroupOptionsByUserQuery<TSelectData = Types.GetGroupOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetGroupOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGroupOptionsByUserQuery<TSelectData = Types.GetGroupOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGroupOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGroupOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __groupOptionsByUser,
    queryKey: groupOptionsByUserQueryKey(),
    ...groupOptionsByUserDefaultOptions as unknown as UseQueryOptions<Types.GetGroupOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get group options by user
 * @return Error
 */
export function setGroupOptionsByUserData(queryClient: QueryClient, updater: (data: Types.GetGroupOptionsRespApiRespBase | undefined) => Types.GetGroupOptionsRespApiRespBase, ) {
  queryClient.setQueryData(groupOptionsByUserQueryKey(),
    updater
  );
}

/**
 * Get group options by user
 * @return Error
 */
export function setGroupOptionsByUserDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGroupOptionsRespApiRespBase | undefined) => Types.GetGroupOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function groupsGETUrl(groupIds: number[] | undefined, remark: string | undefined, frontendIds: number[] | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/groups?";
if (groupIds === null)
    throw new Error("The parameter 'groupIds' cannot be null.");
else if (groupIds !== undefined)
    groupIds && groupIds.forEach(item => { url_ += "GroupIds=" + encodeURIComponent("" + item) + "&"; });
if (remark === null)
    throw new Error("The parameter 'remark' cannot be null.");
else if (remark !== undefined)
    url_ += "Remark=" + encodeURIComponent("" + remark) + "&";
if (frontendIds === null)
    throw new Error("The parameter 'frontendIds' cannot be null.");
else if (frontendIds !== undefined)
    frontendIds && frontendIds.forEach(item => { url_ += "FrontendIds=" + encodeURIComponent("" + item) + "&"; });
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let groupsGETDefaultOptions: UseQueryOptions<Types.GetGroupsRespApiRespBase, unknown, Types.GetGroupsRespApiRespBase> = {
  queryFn: __groupsGET,
};
export function getGroupsGETDefaultOptions(): UseQueryOptions<Types.GetGroupsRespApiRespBase, unknown, Types.GetGroupsRespApiRespBase> {
  return groupsGETDefaultOptions;
};
export function setGroupsGETDefaultOptions(options: UseQueryOptions<Types.GetGroupsRespApiRespBase, unknown, Types.GetGroupsRespApiRespBase>) {
  groupsGETDefaultOptions = options;
}

export function groupsGETQueryKey(dto: GroupsGETQueryParameters): QueryKey;
export function groupsGETQueryKey(groupIds: number[] | undefined, remark: string | undefined, frontendIds: number[] | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function groupsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { groupIds, remark, frontendIds, pageNo, pageSize,  } = params[0] as GroupsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'groupsGET',
        groupIds as any,
        remark as any,
        frontendIds as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'groupsGET',
        ...params
      ]);
  }
}
function __groupsGET(context: QueryFunctionContext) {
  return Client().groupsGET(
      context.queryKey[2] as number[] | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as number[] | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as number | undefined    );
}

export function useGroupsGETQuery<TSelectData = Types.GetGroupsRespApiRespBase, TError = unknown>(dto: GroupsGETQueryParameters, options?: UseQueryOptions<Types.GetGroupsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get Groups
 * @param groupIds (optional) Group ids
 * @param remark (optional) Group remark
 * @param frontendIds (optional) Frontend ids
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useGroupsGETQuery<TSelectData = Types.GetGroupsRespApiRespBase, TError = unknown>(groupIds: number[] | undefined, remark: string | undefined, frontendIds: number[] | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetGroupsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGroupsGETQuery<TSelectData = Types.GetGroupsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGroupsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let groupIds: any = undefined;
  let remark: any = undefined;
  let frontendIds: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ groupIds, remark, frontendIds, pageNo, pageSize,  } = params[0] as GroupsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [groupIds, remark, frontendIds, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGroupsRespApiRespBase, TError, TSelectData>({
    queryFn: __groupsGET,
    queryKey: groupsGETQueryKey(groupIds, remark, frontendIds, pageNo, pageSize),
    ...groupsGETDefaultOptions as unknown as UseQueryOptions<Types.GetGroupsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Groups
 * @param groupIds (optional) Group ids
 * @param remark (optional) Group remark
 * @param frontendIds (optional) Frontend ids
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setGroupsGETData(queryClient: QueryClient, updater: (data: Types.GetGroupsRespApiRespBase | undefined) => Types.GetGroupsRespApiRespBase, groupIds: number[] | undefined, remark: string | undefined, frontendIds: number[] | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(groupsGETQueryKey(groupIds, remark, frontendIds, pageNo, pageSize),
    updater
  );
}

/**
 * Get Groups
 * @param groupIds (optional) Group ids
 * @param remark (optional) Group remark
 * @param frontendIds (optional) Frontend ids
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setGroupsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGroupsRespApiRespBase | undefined) => Types.GetGroupsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function groupsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/groups";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function groupsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'groupsPOST',
    ]);
}

/**
 * Add group
 * @param body (optional) Request
 * @return Error
 */
export function useGroupsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddGroupRespApiRespBase, unknown, Types.AddGroupReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddGroupRespApiRespBase, unknown, Types.AddGroupReq, TContext> {
  const key = groupsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.AddGroupReq) => Client().groupsPOST(body), {...options, mutationKey: key});
}
  
    
export function groupsGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/groups/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let groupsGET2DefaultOptions: UseQueryOptions<Types.GetGroupRespApiRespBase, unknown, Types.GetGroupRespApiRespBase> = {
  queryFn: __groupsGET2,
};
export function getGroupsGET2DefaultOptions(): UseQueryOptions<Types.GetGroupRespApiRespBase, unknown, Types.GetGroupRespApiRespBase> {
  return groupsGET2DefaultOptions;
};
export function setGroupsGET2DefaultOptions(options: UseQueryOptions<Types.GetGroupRespApiRespBase, unknown, Types.GetGroupRespApiRespBase>) {
  groupsGET2DefaultOptions = options;
}

export function groupsGET2QueryKey(id: number): QueryKey;
export function groupsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GroupsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'groupsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'groupsGET2',
        ...params
      ]);
  }
}
function __groupsGET2(context: QueryFunctionContext) {
  return Client().groupsGET2(
      context.queryKey[2] as number    );
}

export function useGroupsGET2Query<TSelectData = Types.GetGroupRespApiRespBase, TError = unknown>(dto: GroupsGET2QueryParameters, options?: UseQueryOptions<Types.GetGroupRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get Group
 * @param id GroupId
 * @return Error
 */
export function useGroupsGET2Query<TSelectData = Types.GetGroupRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetGroupRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGroupsGET2Query<TSelectData = Types.GetGroupRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGroupRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GroupsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGroupRespApiRespBase, TError, TSelectData>({
    queryFn: __groupsGET2,
    queryKey: groupsGET2QueryKey(id),
    ...groupsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetGroupRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Group
 * @param id GroupId
 * @return Error
 */
export function setGroupsGET2Data(queryClient: QueryClient, updater: (data: Types.GetGroupRespApiRespBase | undefined) => Types.GetGroupRespApiRespBase, id: number) {
  queryClient.setQueryData(groupsGET2QueryKey(id),
    updater
  );
}

/**
 * Get Group
 * @param id GroupId
 * @return Error
 */
export function setGroupsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGroupRespApiRespBase | undefined) => Types.GetGroupRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function groupsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/groups/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function groupsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'groupsPATCH',
      id as any,
    ]);
}

/**
 * Modify Group
 * @param id GroupId
 * @param body (optional) Request
 * @return Error
 */
export function useGroupsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModGroupRespApiRespBase, unknown, Types.ModGroupReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModGroupRespApiRespBase, unknown, Types.ModGroupReq, TContext> {
  const key = groupsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModGroupReq) => Client().groupsPATCH(id, body), {...options, mutationKey: key});
}
  
    
export function groupsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/groups/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function groupsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'groupsDELETE',
      id as any,
    ]);
}

/**
 * Delete Group
 * @param id GroupId
 * @return Error
 */
export function useGroupsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelGroupRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelGroupRespApiRespBase, unknown, void, TContext> {
  const key = groupsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().groupsDELETE(id), {...options, mutationKey: key});
}
  
    
export function blankPermissionsUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/groups/blank-permissions";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let blankPermissionsDefaultOptions: UseQueryOptions<Types.GetGroupBlankPermissionsRespApiRespBase, unknown, Types.GetGroupBlankPermissionsRespApiRespBase> = {
  queryFn: __blankPermissions,
};
export function getBlankPermissionsDefaultOptions(): UseQueryOptions<Types.GetGroupBlankPermissionsRespApiRespBase, unknown, Types.GetGroupBlankPermissionsRespApiRespBase> {
  return blankPermissionsDefaultOptions;
};
export function setBlankPermissionsDefaultOptions(options: UseQueryOptions<Types.GetGroupBlankPermissionsRespApiRespBase, unknown, Types.GetGroupBlankPermissionsRespApiRespBase>) {
  blankPermissionsDefaultOptions = options;
}

export function blankPermissionsQueryKey(): QueryKey;
export function blankPermissionsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'blankPermissions',
    ]);
}
function __blankPermissions() {
  return Client().blankPermissions(
    );
}

/**
 * Get group blank permissions
 * @return Error
 */
export function useBlankPermissionsQuery<TSelectData = Types.GetGroupBlankPermissionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetGroupBlankPermissionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useBlankPermissionsQuery<TSelectData = Types.GetGroupBlankPermissionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGroupBlankPermissionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGroupBlankPermissionsRespApiRespBase, TError, TSelectData>({
    queryFn: __blankPermissions,
    queryKey: blankPermissionsQueryKey(),
    ...blankPermissionsDefaultOptions as unknown as UseQueryOptions<Types.GetGroupBlankPermissionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get group blank permissions
 * @return Error
 */
export function setBlankPermissionsData(queryClient: QueryClient, updater: (data: Types.GetGroupBlankPermissionsRespApiRespBase | undefined) => Types.GetGroupBlankPermissionsRespApiRespBase, ) {
  queryClient.setQueryData(blankPermissionsQueryKey(),
    updater
  );
}

/**
 * Get group blank permissions
 * @return Error
 */
export function setBlankPermissionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGroupBlankPermissionsRespApiRespBase | undefined) => Types.GetGroupBlankPermissionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function templatesUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/groups/templates";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let templatesDefaultOptions: UseQueryOptions<Types.GetGroupTemplatesRespApiRespBase, unknown, Types.GetGroupTemplatesRespApiRespBase> = {
  queryFn: __templates,
};
export function getTemplatesDefaultOptions(): UseQueryOptions<Types.GetGroupTemplatesRespApiRespBase, unknown, Types.GetGroupTemplatesRespApiRespBase> {
  return templatesDefaultOptions;
};
export function setTemplatesDefaultOptions(options: UseQueryOptions<Types.GetGroupTemplatesRespApiRespBase, unknown, Types.GetGroupTemplatesRespApiRespBase>) {
  templatesDefaultOptions = options;
}

export function templatesQueryKey(): QueryKey;
export function templatesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'templates',
    ]);
}
function __templates() {
  return Client().templates(
    );
}

/**
 * Get Group Templates
 * @return Error
 */
export function useTemplatesQuery<TSelectData = Types.GetGroupTemplatesRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetGroupTemplatesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTemplatesQuery<TSelectData = Types.GetGroupTemplatesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGroupTemplatesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGroupTemplatesRespApiRespBase, TError, TSelectData>({
    queryFn: __templates,
    queryKey: templatesQueryKey(),
    ...templatesDefaultOptions as unknown as UseQueryOptions<Types.GetGroupTemplatesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Group Templates
 * @return Error
 */
export function setTemplatesData(queryClient: QueryClient, updater: (data: Types.GetGroupTemplatesRespApiRespBase | undefined) => Types.GetGroupTemplatesRespApiRespBase, ) {
  queryClient.setQueryData(templatesQueryKey(),
    updater
  );
}

/**
 * Get Group Templates
 * @return Error
 */
export function setTemplatesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGroupTemplatesRespApiRespBase | undefined) => Types.GetGroupTemplatesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function assignGroupUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/groups/assign-group";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function assignGroupMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'assignGroup',
    ]);
}

/**
 * Assign group to ser
 * @param body (optional) Request
 * @return Error
 */
export function useAssignGroupMutation<TContext>(options?: Omit<UseMutationOptions<Types.AssignGroupRespApiRespBase, unknown, Types.AssignGroupReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AssignGroupRespApiRespBase, unknown, Types.AssignGroupReq, TContext> {
  const key = assignGroupMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.AssignGroupReq) => Client().assignGroup(body), {...options, mutationKey: key});
}
  
    
export function unassignGroupUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/groups/unassign-group";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function unassignGroupMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'unassignGroup',
    ]);
}

/**
 * UnAssign group from user
 * @param body (optional) Request
 * @return Error
 */
export function useUnassignGroupMutation<TContext>(options?: Omit<UseMutationOptions<Types.UnAssignGroupRespApiRespBase, unknown, Types.UnAssignGroupReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.UnAssignGroupRespApiRespBase, unknown, Types.UnAssignGroupReq, TContext> {
  const key = unassignGroupMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.UnAssignGroupReq) => Client().unassignGroup(body), {...options, mutationKey: key});
}
  
    
export function usersGETUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/groups/{id}/users";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let usersGETDefaultOptions: UseQueryOptions<Types.GetUsersByGroupRespApiRespBase, unknown, Types.GetUsersByGroupRespApiRespBase> = {
  queryFn: __usersGET,
};
export function getUsersGETDefaultOptions(): UseQueryOptions<Types.GetUsersByGroupRespApiRespBase, unknown, Types.GetUsersByGroupRespApiRespBase> {
  return usersGETDefaultOptions;
};
export function setUsersGETDefaultOptions(options: UseQueryOptions<Types.GetUsersByGroupRespApiRespBase, unknown, Types.GetUsersByGroupRespApiRespBase>) {
  usersGETDefaultOptions = options;
}

export function usersGETQueryKey(id: number): QueryKey;
export function usersGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as UsersGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'usersGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'usersGET',
        ...params
      ]);
  }
}
function __usersGET(context: QueryFunctionContext) {
  return Client().usersGET(
      context.queryKey[2] as number    );
}

export function useUsersGETQuery<TSelectData = Types.GetUsersByGroupRespApiRespBase, TError = unknown>(dto: UsersGETQueryParameters, options?: UseQueryOptions<Types.GetUsersByGroupRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get users by group
 * @return Error
 */
export function useUsersGETQuery<TSelectData = Types.GetUsersByGroupRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetUsersByGroupRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUsersGETQuery<TSelectData = Types.GetUsersByGroupRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetUsersByGroupRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as UsersGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetUsersByGroupRespApiRespBase, TError, TSelectData>({
    queryFn: __usersGET,
    queryKey: usersGETQueryKey(id),
    ...usersGETDefaultOptions as unknown as UseQueryOptions<Types.GetUsersByGroupRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get users by group
 * @return Error
 */
export function setUsersGETData(queryClient: QueryClient, updater: (data: Types.GetUsersByGroupRespApiRespBase | undefined) => Types.GetUsersByGroupRespApiRespBase, id: number) {
  queryClient.setQueryData(usersGETQueryKey(id),
    updater
  );
}

/**
 * Get users by group
 * @return Error
 */
export function setUsersGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetUsersByGroupRespApiRespBase | undefined) => Types.GetUsersByGroupRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function fuzzyUsersUrl(id: number, fuzzyPrefix: string, maxCount: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/groups/{id}/fuzzy-users?";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  if (fuzzyPrefix === undefined || fuzzyPrefix === null)
    throw new Error("The parameter 'fuzzyPrefix' must be defined and cannot be null.");
  else
    url_ += "FuzzyPrefix=" + encodeURIComponent("" + fuzzyPrefix) + "&";
if (maxCount === null)
    throw new Error("The parameter 'maxCount' cannot be null.");
else if (maxCount !== undefined)
    url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let fuzzyUsersDefaultOptions: UseQueryOptions<Types.GetFuzzyUsersByGroupRespApiRespBase, unknown, Types.GetFuzzyUsersByGroupRespApiRespBase> = {
  queryFn: __fuzzyUsers,
};
export function getFuzzyUsersDefaultOptions(): UseQueryOptions<Types.GetFuzzyUsersByGroupRespApiRespBase, unknown, Types.GetFuzzyUsersByGroupRespApiRespBase> {
  return fuzzyUsersDefaultOptions;
};
export function setFuzzyUsersDefaultOptions(options: UseQueryOptions<Types.GetFuzzyUsersByGroupRespApiRespBase, unknown, Types.GetFuzzyUsersByGroupRespApiRespBase>) {
  fuzzyUsersDefaultOptions = options;
}

export function fuzzyUsersQueryKey(dto: FuzzyUsersQueryParameters): QueryKey;
export function fuzzyUsersQueryKey(id: number, fuzzyPrefix: string, maxCount: number | undefined): QueryKey;
export function fuzzyUsersQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, fuzzyPrefix, maxCount,  } = params[0] as FuzzyUsersQueryParameters;

    return trimArrayEnd([
        'Client',
        'fuzzyUsers',
        id as any,
        fuzzyPrefix as any,
        maxCount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'fuzzyUsers',
        ...params
      ]);
  }
}
function __fuzzyUsers(context: QueryFunctionContext) {
  return Client().fuzzyUsers(
      context.queryKey[2] as number,       context.queryKey[3] as string,       context.queryKey[4] as number | undefined    );
}

export function useFuzzyUsersQuery<TSelectData = Types.GetFuzzyUsersByGroupRespApiRespBase, TError = unknown>(dto: FuzzyUsersQueryParameters, options?: UseQueryOptions<Types.GetFuzzyUsersByGroupRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get fuzzy users by group
 * @param maxCount (optional) 
 * @return Error
 */
export function useFuzzyUsersQuery<TSelectData = Types.GetFuzzyUsersByGroupRespApiRespBase, TError = unknown>(id: number, fuzzyPrefix: string, maxCount: number | undefined, options?: UseQueryOptions<Types.GetFuzzyUsersByGroupRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFuzzyUsersQuery<TSelectData = Types.GetFuzzyUsersByGroupRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuzzyUsersByGroupRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  let fuzzyPrefix: any = undefined;
  let maxCount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, fuzzyPrefix, maxCount,  } = params[0] as FuzzyUsersQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, fuzzyPrefix, maxCount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuzzyUsersByGroupRespApiRespBase, TError, TSelectData>({
    queryFn: __fuzzyUsers,
    queryKey: fuzzyUsersQueryKey(id, fuzzyPrefix, maxCount),
    ...fuzzyUsersDefaultOptions as unknown as UseQueryOptions<Types.GetFuzzyUsersByGroupRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get fuzzy users by group
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzyUsersData(queryClient: QueryClient, updater: (data: Types.GetFuzzyUsersByGroupRespApiRespBase | undefined) => Types.GetFuzzyUsersByGroupRespApiRespBase, id: number, fuzzyPrefix: string, maxCount: number | undefined) {
  queryClient.setQueryData(fuzzyUsersQueryKey(id, fuzzyPrefix, maxCount),
    updater
  );
}

/**
 * Get fuzzy users by group
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzyUsersDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuzzyUsersByGroupRespApiRespBase | undefined) => Types.GetFuzzyUsersByGroupRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function heroesGETUrl(name: string | undefined, title: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/heroes?";
if (name === null)
    throw new Error("The parameter 'name' cannot be null.");
else if (name !== undefined)
    url_ += "Name=" + encodeURIComponent("" + name) + "&";
if (title === null)
    throw new Error("The parameter 'title' cannot be null.");
else if (title !== undefined)
    url_ += "Title=" + encodeURIComponent("" + title) + "&";
if (gameId === null)
    throw new Error("The parameter 'gameId' cannot be null.");
else if (gameId !== undefined)
    url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let heroesGETDefaultOptions: UseQueryOptions<Types.GetHeroesRespApiRespBase, unknown, Types.GetHeroesRespApiRespBase> = {
  queryFn: __heroesGET,
};
export function getHeroesGETDefaultOptions(): UseQueryOptions<Types.GetHeroesRespApiRespBase, unknown, Types.GetHeroesRespApiRespBase> {
  return heroesGETDefaultOptions;
};
export function setHeroesGETDefaultOptions(options: UseQueryOptions<Types.GetHeroesRespApiRespBase, unknown, Types.GetHeroesRespApiRespBase>) {
  heroesGETDefaultOptions = options;
}

export function heroesGETQueryKey(dto: HeroesGETQueryParameters): QueryKey;
export function heroesGETQueryKey(name: string | undefined, title: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function heroesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { name, title, gameId, pageNo, pageSize,  } = params[0] as HeroesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'heroesGET',
        name as any,
        title as any,
        gameId as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'heroesGET',
        ...params
      ]);
  }
}
function __heroesGET(context: QueryFunctionContext) {
  return Client().heroesGET(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as number | undefined    );
}

export function useHeroesGETQuery<TSelectData = Types.GetHeroesRespApiRespBase, TError = unknown>(dto: HeroesGETQueryParameters, options?: UseQueryOptions<Types.GetHeroesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get heroes by condition
 * @param name (optional) Hero Name
 * @param title (optional) Hero Title
 * @param gameId (optional) Hero Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useHeroesGETQuery<TSelectData = Types.GetHeroesRespApiRespBase, TError = unknown>(name: string | undefined, title: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetHeroesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHeroesGETQuery<TSelectData = Types.GetHeroesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetHeroesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let name: any = undefined;
  let title: any = undefined;
  let gameId: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ name, title, gameId, pageNo, pageSize,  } = params[0] as HeroesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [name, title, gameId, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetHeroesRespApiRespBase, TError, TSelectData>({
    queryFn: __heroesGET,
    queryKey: heroesGETQueryKey(name, title, gameId, pageNo, pageSize),
    ...heroesGETDefaultOptions as unknown as UseQueryOptions<Types.GetHeroesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get heroes by condition
 * @param name (optional) Hero Name
 * @param title (optional) Hero Title
 * @param gameId (optional) Hero Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setHeroesGETData(queryClient: QueryClient, updater: (data: Types.GetHeroesRespApiRespBase | undefined) => Types.GetHeroesRespApiRespBase, name: string | undefined, title: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(heroesGETQueryKey(name, title, gameId, pageNo, pageSize),
    updater
  );
}

/**
 * Get heroes by condition
 * @param name (optional) Hero Name
 * @param title (optional) Hero Title
 * @param gameId (optional) Hero Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setHeroesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetHeroesRespApiRespBase | undefined) => Types.GetHeroesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function heroesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/heroes";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function heroesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'heroesPOST',
    ]);
}

/**
 * Add new game Hero
 * @param name (optional) Game Hero Name
 * @param gameId (optional) Hero Game Id
 * @param title (optional) Title
 * @param referredToBy (optional) ReferredToBy
 * @param tagline (optional) Tagline
 * @param description (optional) Description
 * @param imageFile (optional) Image file
 * @param iconFile (optional) Icon file
 * @return Error
 */
export function useHeroesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddHeroRespApiRespBase, unknown, HeroesPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddHeroRespApiRespBase, unknown, HeroesPOSTMutationParameters, TContext> {
  const key = heroesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((heroesPOSTMutationParameters: HeroesPOSTMutationParameters) => Client().heroesPOST(heroesPOSTMutationParameters.name, heroesPOSTMutationParameters.gameId, heroesPOSTMutationParameters.title, heroesPOSTMutationParameters.referredToBy, heroesPOSTMutationParameters.tagline, heroesPOSTMutationParameters.description, heroesPOSTMutationParameters.imageFile, heroesPOSTMutationParameters.iconFile), {...options, mutationKey: key});
}
  
    
export function heroesGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/heroes/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let heroesGET2DefaultOptions: UseQueryOptions<Types.GetHeroRespApiRespBase, unknown, Types.GetHeroRespApiRespBase> = {
  queryFn: __heroesGET2,
};
export function getHeroesGET2DefaultOptions(): UseQueryOptions<Types.GetHeroRespApiRespBase, unknown, Types.GetHeroRespApiRespBase> {
  return heroesGET2DefaultOptions;
};
export function setHeroesGET2DefaultOptions(options: UseQueryOptions<Types.GetHeroRespApiRespBase, unknown, Types.GetHeroRespApiRespBase>) {
  heroesGET2DefaultOptions = options;
}

export function heroesGET2QueryKey(id: number): QueryKey;
export function heroesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as HeroesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'heroesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'heroesGET2',
        ...params
      ]);
  }
}
function __heroesGET2(context: QueryFunctionContext) {
  return Client().heroesGET2(
      context.queryKey[2] as number    );
}

export function useHeroesGET2Query<TSelectData = Types.GetHeroRespApiRespBase, TError = unknown>(dto: HeroesGET2QueryParameters, options?: UseQueryOptions<Types.GetHeroRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get game hero
 * @param id Hero Id
 * @return Error
 */
export function useHeroesGET2Query<TSelectData = Types.GetHeroRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetHeroRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHeroesGET2Query<TSelectData = Types.GetHeroRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetHeroRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as HeroesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetHeroRespApiRespBase, TError, TSelectData>({
    queryFn: __heroesGET2,
    queryKey: heroesGET2QueryKey(id),
    ...heroesGET2DefaultOptions as unknown as UseQueryOptions<Types.GetHeroRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get game hero
 * @param id Hero Id
 * @return Error
 */
export function setHeroesGET2Data(queryClient: QueryClient, updater: (data: Types.GetHeroRespApiRespBase | undefined) => Types.GetHeroRespApiRespBase, id: number) {
  queryClient.setQueryData(heroesGET2QueryKey(id),
    updater
  );
}

/**
 * Get game hero
 * @param id Hero Id
 * @return Error
 */
export function setHeroesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetHeroRespApiRespBase | undefined) => Types.GetHeroRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function heroesPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/heroes/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function heroesPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'heroesPATCH',
      id as any,
    ]);
}

/**
 * Modify game Hero
 * @param id game Hero Id
 * @param id (optional) Game Hero Id
 * @param name (optional) Game Hero Name
 * @param gameId (optional) Hero Game Id
 * @param title (optional) Title
 * @param referredToBy (optional) ReferredToBy
 * @param tagline (optional) Tagline
 * @param description (optional) Description
 * @param imageFile (optional) Image file
 * @param iconFile (optional) Icon file
 * @return Error
 */
export function useHeroesPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModHeroRespApiRespBase, unknown, HeroesPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModHeroRespApiRespBase, unknown, HeroesPATCHMutationParameters, TContext> {
  const key = heroesPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((heroesPATCHMutationParameters: HeroesPATCHMutationParameters) => Client().heroesPATCH(id, heroesPATCHMutationParameters.id, heroesPATCHMutationParameters.name, heroesPATCHMutationParameters.gameId, heroesPATCHMutationParameters.title, heroesPATCHMutationParameters.referredToBy, heroesPATCHMutationParameters.tagline, heroesPATCHMutationParameters.description, heroesPATCHMutationParameters.imageFile, heroesPATCHMutationParameters.iconFile), {...options, mutationKey: key});
}
  
    
export function heroesDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/heroes/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function heroesDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'heroesDELETE',
      id as any,
    ]);
}

/**
 * Delete game Hero
 * @param id game Hero Id
 * @return Error
 */
export function useHeroesDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelHeroRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelHeroRespApiRespBase, unknown, void, TContext> {
  const key = heroesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().heroesDELETE(id), {...options, mutationKey: key});
}
  
    
export function translationsGET3Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/heroes/{id}/translations";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let translationsGET3DefaultOptions: UseQueryOptions<Types.GetHeroTranslationsRespApiRespBase, unknown, Types.GetHeroTranslationsRespApiRespBase> = {
  queryFn: __translationsGET3,
};
export function getTranslationsGET3DefaultOptions(): UseQueryOptions<Types.GetHeroTranslationsRespApiRespBase, unknown, Types.GetHeroTranslationsRespApiRespBase> {
  return translationsGET3DefaultOptions;
};
export function setTranslationsGET3DefaultOptions(options: UseQueryOptions<Types.GetHeroTranslationsRespApiRespBase, unknown, Types.GetHeroTranslationsRespApiRespBase>) {
  translationsGET3DefaultOptions = options;
}

export function translationsGET3QueryKey(id: number): QueryKey;
export function translationsGET3QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as TranslationsGET3QueryParameters;

    return trimArrayEnd([
        'Client',
        'translationsGET3',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'translationsGET3',
        ...params
      ]);
  }
}
function __translationsGET3(context: QueryFunctionContext) {
  return Client().translationsGET3(
      context.queryKey[2] as number    );
}

export function useTranslationsGET3Query<TSelectData = Types.GetHeroTranslationsRespApiRespBase, TError = unknown>(dto: TranslationsGET3QueryParameters, options?: UseQueryOptions<Types.GetHeroTranslationsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get game hero translations
 * @param id heroes Id
 * @return Error
 */
export function useTranslationsGET3Query<TSelectData = Types.GetHeroTranslationsRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetHeroTranslationsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTranslationsGET3Query<TSelectData = Types.GetHeroTranslationsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetHeroTranslationsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as TranslationsGET3QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetHeroTranslationsRespApiRespBase, TError, TSelectData>({
    queryFn: __translationsGET3,
    queryKey: translationsGET3QueryKey(id),
    ...translationsGET3DefaultOptions as unknown as UseQueryOptions<Types.GetHeroTranslationsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get game hero translations
 * @param id heroes Id
 * @return Error
 */
export function setTranslationsGET3Data(queryClient: QueryClient, updater: (data: Types.GetHeroTranslationsRespApiRespBase | undefined) => Types.GetHeroTranslationsRespApiRespBase, id: number) {
  queryClient.setQueryData(translationsGET3QueryKey(id),
    updater
  );
}

/**
 * Get game hero translations
 * @param id heroes Id
 * @return Error
 */
export function setTranslationsGET3DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetHeroTranslationsRespApiRespBase | undefined) => Types.GetHeroTranslationsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function translationsPATCH4Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/heroes/{id}/translations";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function translationsPATCH4MutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'translationsPATCH4',
      id as any,
    ]);
}

/**
 * Modify game Hero translations
 * @param id game Hero Id
 * @param body (optional) Request
 * @return Error
 */
export function useTranslationsPATCH4Mutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModHeroTranslationsRespApiRespBase, unknown, Types.ModHeroTranslationsReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModHeroTranslationsRespApiRespBase, unknown, Types.ModHeroTranslationsReq, TContext> {
  const key = translationsPATCH4MutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModHeroTranslationsReq) => Client().translationsPATCH4(id, body), {...options, mutationKey: key});
}
  
    
export function logoutPOSTUrl(refreshToken: string | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/logout?";
if (refreshToken === null)
    throw new Error("The parameter 'refreshToken' cannot be null.");
else if (refreshToken !== undefined)
    url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function logoutPOSTMutationKey(refreshToken: string | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'logoutPOST',
      refreshToken as any,
    ]);
}

/**
 * Logout
 * @param refreshToken (optional) RefreshToken
 * @return Error
 */
export function useLogoutPOSTMutation<TContext>(refreshToken: string | undefined, options?: Omit<UseMutationOptions<Types.LogoutRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.LogoutRespApiRespBase, unknown, void, TContext> {
  const key = logoutPOSTMutationKey(refreshToken);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().logoutPOST(refreshToken), {...options, mutationKey: key});
}
  
    
export function logLevelsUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/logs/log-levels";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let logLevelsDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __logLevels,
};
export function getLogLevelsDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return logLevelsDefaultOptions;
};
export function setLogLevelsDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  logLevelsDefaultOptions = options;
}

export function logLevelsQueryKey(): QueryKey;
export function logLevelsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'logLevels',
    ]);
}
function __logLevels() {
  return Client().logLevels(
    );
}

/**
 * Get Log Levels
 * @return Success
 */
export function useLogLevelsQuery<TSelectData = void, TError = unknown>(options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useLogLevelsQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __logLevels,
    queryKey: logLevelsQueryKey(),
    ...logLevelsDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Log Levels
 * @return Success
 */
export function setLogLevelsData(queryClient: QueryClient, updater: (data: void | undefined) => void, ) {
  queryClient.setQueryData(logLevelsQueryKey(),
    updater
  );
}

/**
 * Get Log Levels
 * @return Success
 */
export function setLogLevelsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function apiLogsUrl(from: number | undefined, to: number | undefined, prefix: string | undefined, httpStatusCode: number | undefined, ip: string | undefined, path: string | undefined, content: string | undefined, serverName: string | undefined, traceId: string | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/logs/api-logs?";
if (from === null)
    throw new Error("The parameter 'from' cannot be null.");
else if (from !== undefined)
    url_ += "From=" + encodeURIComponent("" + from) + "&";
if (to === null)
    throw new Error("The parameter 'to' cannot be null.");
else if (to !== undefined)
    url_ += "To=" + encodeURIComponent("" + to) + "&";
if (prefix === null)
    throw new Error("The parameter 'prefix' cannot be null.");
else if (prefix !== undefined)
    url_ += "Prefix=" + encodeURIComponent("" + prefix) + "&";
if (httpStatusCode === null)
    throw new Error("The parameter 'httpStatusCode' cannot be null.");
else if (httpStatusCode !== undefined)
    url_ += "HttpStatusCode=" + encodeURIComponent("" + httpStatusCode) + "&";
if (ip === null)
    throw new Error("The parameter 'ip' cannot be null.");
else if (ip !== undefined)
    url_ += "Ip=" + encodeURIComponent("" + ip) + "&";
if (path === null)
    throw new Error("The parameter 'path' cannot be null.");
else if (path !== undefined)
    url_ += "Path=" + encodeURIComponent("" + path) + "&";
if (content === null)
    throw new Error("The parameter 'content' cannot be null.");
else if (content !== undefined)
    url_ += "Content=" + encodeURIComponent("" + content) + "&";
if (serverName === null)
    throw new Error("The parameter 'serverName' cannot be null.");
else if (serverName !== undefined)
    url_ += "ServerName=" + encodeURIComponent("" + serverName) + "&";
if (traceId === null)
    throw new Error("The parameter 'traceId' cannot be null.");
else if (traceId !== undefined)
    url_ += "TraceId=" + encodeURIComponent("" + traceId) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let apiLogsDefaultOptions: UseQueryOptions<Types.GetApiLogsRespApiRespBase, unknown, Types.GetApiLogsRespApiRespBase> = {
  queryFn: __apiLogs,
};
export function getApiLogsDefaultOptions(): UseQueryOptions<Types.GetApiLogsRespApiRespBase, unknown, Types.GetApiLogsRespApiRespBase> {
  return apiLogsDefaultOptions;
};
export function setApiLogsDefaultOptions(options: UseQueryOptions<Types.GetApiLogsRespApiRespBase, unknown, Types.GetApiLogsRespApiRespBase>) {
  apiLogsDefaultOptions = options;
}

export function apiLogsQueryKey(dto: ApiLogsQueryParameters): QueryKey;
export function apiLogsQueryKey(from: number | undefined, to: number | undefined, prefix: string | undefined, httpStatusCode: number | undefined, ip: string | undefined, path: string | undefined, content: string | undefined, serverName: string | undefined, traceId: string | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function apiLogsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { from, to, prefix, httpStatusCode, ip, path, content, serverName, traceId, pageNo, pageSize,  } = params[0] as ApiLogsQueryParameters;

    return trimArrayEnd([
        'Client',
        'apiLogs',
        from as any,
        to as any,
        prefix as any,
        httpStatusCode as any,
        ip as any,
        path as any,
        content as any,
        serverName as any,
        traceId as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'apiLogs',
        ...params
      ]);
  }
}
function __apiLogs(context: QueryFunctionContext) {
  return Client().apiLogs(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as string | undefined,       context.queryKey[7] as string | undefined,       context.queryKey[8] as string | undefined,       context.queryKey[9] as string | undefined,       context.queryKey[10] as string | undefined,       context.queryKey[11] as number | undefined,       context.queryKey[12] as number | undefined    );
}

export function useApiLogsQuery<TSelectData = Types.GetApiLogsRespApiRespBase, TError = unknown>(dto: ApiLogsQueryParameters, options?: UseQueryOptions<Types.GetApiLogsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get Api Logs
 * @param from (optional) From
 * @param to (optional) To
 * @param prefix (optional) Prefix
 * @param httpStatusCode (optional) Http Status Code
 * @param ip (optional) IP Address
 * @param path (optional) Path
 * @param content (optional) Content
 * @param serverName (optional) Server Name
 * @param traceId (optional) Trace Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useApiLogsQuery<TSelectData = Types.GetApiLogsRespApiRespBase, TError = unknown>(from: number | undefined, to: number | undefined, prefix: string | undefined, httpStatusCode: number | undefined, ip: string | undefined, path: string | undefined, content: string | undefined, serverName: string | undefined, traceId: string | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetApiLogsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useApiLogsQuery<TSelectData = Types.GetApiLogsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetApiLogsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let from: any = undefined;
  let to: any = undefined;
  let prefix: any = undefined;
  let httpStatusCode: any = undefined;
  let ip: any = undefined;
  let path: any = undefined;
  let content: any = undefined;
  let serverName: any = undefined;
  let traceId: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ from, to, prefix, httpStatusCode, ip, path, content, serverName, traceId, pageNo, pageSize,  } = params[0] as ApiLogsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [from, to, prefix, httpStatusCode, ip, path, content, serverName, traceId, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetApiLogsRespApiRespBase, TError, TSelectData>({
    queryFn: __apiLogs,
    queryKey: apiLogsQueryKey(from, to, prefix, httpStatusCode, ip, path, content, serverName, traceId, pageNo, pageSize),
    ...apiLogsDefaultOptions as unknown as UseQueryOptions<Types.GetApiLogsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Api Logs
 * @param from (optional) From
 * @param to (optional) To
 * @param prefix (optional) Prefix
 * @param httpStatusCode (optional) Http Status Code
 * @param ip (optional) IP Address
 * @param path (optional) Path
 * @param content (optional) Content
 * @param serverName (optional) Server Name
 * @param traceId (optional) Trace Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setApiLogsData(queryClient: QueryClient, updater: (data: Types.GetApiLogsRespApiRespBase | undefined) => Types.GetApiLogsRespApiRespBase, from: number | undefined, to: number | undefined, prefix: string | undefined, httpStatusCode: number | undefined, ip: string | undefined, path: string | undefined, content: string | undefined, serverName: string | undefined, traceId: string | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(apiLogsQueryKey(from, to, prefix, httpStatusCode, ip, path, content, serverName, traceId, pageNo, pageSize),
    updater
  );
}

/**
 * Get Api Logs
 * @param from (optional) From
 * @param to (optional) To
 * @param prefix (optional) Prefix
 * @param httpStatusCode (optional) Http Status Code
 * @param ip (optional) IP Address
 * @param path (optional) Path
 * @param content (optional) Content
 * @param serverName (optional) Server Name
 * @param traceId (optional) Trace Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setApiLogsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetApiLogsRespApiRespBase | undefined) => Types.GetApiLogsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function apiLogs2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/logs/api-logs/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let apiLogs2DefaultOptions: UseQueryOptions<Types.GetApiLogRespApiRespBase, unknown, Types.GetApiLogRespApiRespBase> = {
  queryFn: __apiLogs2,
};
export function getApiLogs2DefaultOptions(): UseQueryOptions<Types.GetApiLogRespApiRespBase, unknown, Types.GetApiLogRespApiRespBase> {
  return apiLogs2DefaultOptions;
};
export function setApiLogs2DefaultOptions(options: UseQueryOptions<Types.GetApiLogRespApiRespBase, unknown, Types.GetApiLogRespApiRespBase>) {
  apiLogs2DefaultOptions = options;
}

export function apiLogs2QueryKey(id: number): QueryKey;
export function apiLogs2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ApiLogs2QueryParameters;

    return trimArrayEnd([
        'Client',
        'apiLogs2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'apiLogs2',
        ...params
      ]);
  }
}
function __apiLogs2(context: QueryFunctionContext) {
  return Client().apiLogs2(
      context.queryKey[2] as number    );
}

export function useApiLogs2Query<TSelectData = Types.GetApiLogRespApiRespBase, TError = unknown>(dto: ApiLogs2QueryParameters, options?: UseQueryOptions<Types.GetApiLogRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get Api log
 * @param id Log Id
 * @return Error
 */
export function useApiLogs2Query<TSelectData = Types.GetApiLogRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetApiLogRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useApiLogs2Query<TSelectData = Types.GetApiLogRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetApiLogRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ApiLogs2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetApiLogRespApiRespBase, TError, TSelectData>({
    queryFn: __apiLogs2,
    queryKey: apiLogs2QueryKey(id),
    ...apiLogs2DefaultOptions as unknown as UseQueryOptions<Types.GetApiLogRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Api log
 * @param id Log Id
 * @return Error
 */
export function setApiLogs2Data(queryClient: QueryClient, updater: (data: Types.GetApiLogRespApiRespBase | undefined) => Types.GetApiLogRespApiRespBase, id: number) {
  queryClient.setQueryData(apiLogs2QueryKey(id),
    updater
  );
}

/**
 * Get Api log
 * @param id Log Id
 * @return Error
 */
export function setApiLogs2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetApiLogRespApiRespBase | undefined) => Types.GetApiLogRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function systemLogsUrl(from: number | undefined, to: number | undefined, prefix: string | undefined, serverName: string | undefined, logger: string | undefined, method: string | undefined, logLevel: Types.LogLevel | undefined, traceId: string | undefined, keyword: string | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/logs/system-logs?";
if (from === null)
    throw new Error("The parameter 'from' cannot be null.");
else if (from !== undefined)
    url_ += "From=" + encodeURIComponent("" + from) + "&";
if (to === null)
    throw new Error("The parameter 'to' cannot be null.");
else if (to !== undefined)
    url_ += "To=" + encodeURIComponent("" + to) + "&";
if (prefix === null)
    throw new Error("The parameter 'prefix' cannot be null.");
else if (prefix !== undefined)
    url_ += "Prefix=" + encodeURIComponent("" + prefix) + "&";
if (serverName === null)
    throw new Error("The parameter 'serverName' cannot be null.");
else if (serverName !== undefined)
    url_ += "ServerName=" + encodeURIComponent("" + serverName) + "&";
if (logger === null)
    throw new Error("The parameter 'logger' cannot be null.");
else if (logger !== undefined)
    url_ += "Logger=" + encodeURIComponent("" + logger) + "&";
if (method === null)
    throw new Error("The parameter 'method' cannot be null.");
else if (method !== undefined)
    url_ += "Method=" + encodeURIComponent("" + method) + "&";
if (logLevel === null)
    throw new Error("The parameter 'logLevel' cannot be null.");
else if (logLevel !== undefined)
    url_ += "LogLevel=" + encodeURIComponent("" + logLevel) + "&";
if (traceId === null)
    throw new Error("The parameter 'traceId' cannot be null.");
else if (traceId !== undefined)
    url_ += "TraceId=" + encodeURIComponent("" + traceId) + "&";
if (keyword === null)
    throw new Error("The parameter 'keyword' cannot be null.");
else if (keyword !== undefined)
    url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let systemLogsDefaultOptions: UseQueryOptions<Types.GetSystemLogsRespApiRespBase, unknown, Types.GetSystemLogsRespApiRespBase> = {
  queryFn: __systemLogs,
};
export function getSystemLogsDefaultOptions(): UseQueryOptions<Types.GetSystemLogsRespApiRespBase, unknown, Types.GetSystemLogsRespApiRespBase> {
  return systemLogsDefaultOptions;
};
export function setSystemLogsDefaultOptions(options: UseQueryOptions<Types.GetSystemLogsRespApiRespBase, unknown, Types.GetSystemLogsRespApiRespBase>) {
  systemLogsDefaultOptions = options;
}

export function systemLogsQueryKey(dto: SystemLogsQueryParameters): QueryKey;
export function systemLogsQueryKey(from: number | undefined, to: number | undefined, prefix: string | undefined, serverName: string | undefined, logger: string | undefined, method: string | undefined, logLevel: Types.LogLevel | undefined, traceId: string | undefined, keyword: string | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function systemLogsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { from, to, prefix, serverName, logger, method, logLevel, traceId, keyword, pageNo, pageSize,  } = params[0] as SystemLogsQueryParameters;

    return trimArrayEnd([
        'Client',
        'systemLogs',
        from as any,
        to as any,
        prefix as any,
        serverName as any,
        logger as any,
        method as any,
        logLevel as any,
        traceId as any,
        keyword as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'systemLogs',
        ...params
      ]);
  }
}
function __systemLogs(context: QueryFunctionContext) {
  return Client().systemLogs(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as string | undefined,       context.queryKey[7] as string | undefined,       context.queryKey[8] as Types.LogLevel | undefined,       context.queryKey[9] as string | undefined,       context.queryKey[10] as string | undefined,       context.queryKey[11] as number | undefined,       context.queryKey[12] as number | undefined    );
}

export function useSystemLogsQuery<TSelectData = Types.GetSystemLogsRespApiRespBase, TError = unknown>(dto: SystemLogsQueryParameters, options?: UseQueryOptions<Types.GetSystemLogsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get System Logs
 * @param from (optional) From
 * @param to (optional) To
 * @param prefix (optional) Prefix
 * @param serverName (optional) Server Name
 * @param logger (optional) Logger
 * @param method (optional) Method
 * @param logLevel (optional) Log Level
 * @param traceId (optional) Trace Id
 * @param keyword (optional) Keyword
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useSystemLogsQuery<TSelectData = Types.GetSystemLogsRespApiRespBase, TError = unknown>(from: number | undefined, to: number | undefined, prefix: string | undefined, serverName: string | undefined, logger: string | undefined, method: string | undefined, logLevel: Types.LogLevel | undefined, traceId: string | undefined, keyword: string | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetSystemLogsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSystemLogsQuery<TSelectData = Types.GetSystemLogsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetSystemLogsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let from: any = undefined;
  let to: any = undefined;
  let prefix: any = undefined;
  let serverName: any = undefined;
  let logger: any = undefined;
  let method: any = undefined;
  let logLevel: any = undefined;
  let traceId: any = undefined;
  let keyword: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ from, to, prefix, serverName, logger, method, logLevel, traceId, keyword, pageNo, pageSize,  } = params[0] as SystemLogsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [from, to, prefix, serverName, logger, method, logLevel, traceId, keyword, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetSystemLogsRespApiRespBase, TError, TSelectData>({
    queryFn: __systemLogs,
    queryKey: systemLogsQueryKey(from, to, prefix, serverName, logger, method, logLevel, traceId, keyword, pageNo, pageSize),
    ...systemLogsDefaultOptions as unknown as UseQueryOptions<Types.GetSystemLogsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get System Logs
 * @param from (optional) From
 * @param to (optional) To
 * @param prefix (optional) Prefix
 * @param serverName (optional) Server Name
 * @param logger (optional) Logger
 * @param method (optional) Method
 * @param logLevel (optional) Log Level
 * @param traceId (optional) Trace Id
 * @param keyword (optional) Keyword
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setSystemLogsData(queryClient: QueryClient, updater: (data: Types.GetSystemLogsRespApiRespBase | undefined) => Types.GetSystemLogsRespApiRespBase, from: number | undefined, to: number | undefined, prefix: string | undefined, serverName: string | undefined, logger: string | undefined, method: string | undefined, logLevel: Types.LogLevel | undefined, traceId: string | undefined, keyword: string | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(systemLogsQueryKey(from, to, prefix, serverName, logger, method, logLevel, traceId, keyword, pageNo, pageSize),
    updater
  );
}

/**
 * Get System Logs
 * @param from (optional) From
 * @param to (optional) To
 * @param prefix (optional) Prefix
 * @param serverName (optional) Server Name
 * @param logger (optional) Logger
 * @param method (optional) Method
 * @param logLevel (optional) Log Level
 * @param traceId (optional) Trace Id
 * @param keyword (optional) Keyword
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setSystemLogsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetSystemLogsRespApiRespBase | undefined) => Types.GetSystemLogsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function systemLogs2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/logs/system-logs/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let systemLogs2DefaultOptions: UseQueryOptions<Types.GetSystemLogRespApiRespBase, unknown, Types.GetSystemLogRespApiRespBase> = {
  queryFn: __systemLogs2,
};
export function getSystemLogs2DefaultOptions(): UseQueryOptions<Types.GetSystemLogRespApiRespBase, unknown, Types.GetSystemLogRespApiRespBase> {
  return systemLogs2DefaultOptions;
};
export function setSystemLogs2DefaultOptions(options: UseQueryOptions<Types.GetSystemLogRespApiRespBase, unknown, Types.GetSystemLogRespApiRespBase>) {
  systemLogs2DefaultOptions = options;
}

export function systemLogs2QueryKey(id: number): QueryKey;
export function systemLogs2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as SystemLogs2QueryParameters;

    return trimArrayEnd([
        'Client',
        'systemLogs2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'systemLogs2',
        ...params
      ]);
  }
}
function __systemLogs2(context: QueryFunctionContext) {
  return Client().systemLogs2(
      context.queryKey[2] as number    );
}

export function useSystemLogs2Query<TSelectData = Types.GetSystemLogRespApiRespBase, TError = unknown>(dto: SystemLogs2QueryParameters, options?: UseQueryOptions<Types.GetSystemLogRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get System Log
 * @param id Log Id
 * @return Error
 */
export function useSystemLogs2Query<TSelectData = Types.GetSystemLogRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetSystemLogRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSystemLogs2Query<TSelectData = Types.GetSystemLogRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetSystemLogRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as SystemLogs2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetSystemLogRespApiRespBase, TError, TSelectData>({
    queryFn: __systemLogs2,
    queryKey: systemLogs2QueryKey(id),
    ...systemLogs2DefaultOptions as unknown as UseQueryOptions<Types.GetSystemLogRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get System Log
 * @param id Log Id
 * @return Error
 */
export function setSystemLogs2Data(queryClient: QueryClient, updater: (data: Types.GetSystemLogRespApiRespBase | undefined) => Types.GetSystemLogRespApiRespBase, id: number) {
  queryClient.setQueryData(systemLogs2QueryKey(id),
    updater
  );
}

/**
 * Get System Log
 * @param id Log Id
 * @return Error
 */
export function setSystemLogs2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetSystemLogRespApiRespBase | undefined) => Types.GetSystemLogRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function mapsGETUrl(name: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/maps?";
if (name === null)
    throw new Error("The parameter 'name' cannot be null.");
else if (name !== undefined)
    url_ += "Name=" + encodeURIComponent("" + name) + "&";
if (gameId === null)
    throw new Error("The parameter 'gameId' cannot be null.");
else if (gameId !== undefined)
    url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let mapsGETDefaultOptions: UseQueryOptions<Types.GetMapsRespApiRespBase, unknown, Types.GetMapsRespApiRespBase> = {
  queryFn: __mapsGET,
};
export function getMapsGETDefaultOptions(): UseQueryOptions<Types.GetMapsRespApiRespBase, unknown, Types.GetMapsRespApiRespBase> {
  return mapsGETDefaultOptions;
};
export function setMapsGETDefaultOptions(options: UseQueryOptions<Types.GetMapsRespApiRespBase, unknown, Types.GetMapsRespApiRespBase>) {
  mapsGETDefaultOptions = options;
}

export function mapsGETQueryKey(dto: MapsGETQueryParameters): QueryKey;
export function mapsGETQueryKey(name: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function mapsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { name, gameId, pageNo, pageSize,  } = params[0] as MapsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'mapsGET',
        name as any,
        gameId as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'mapsGET',
        ...params
      ]);
  }
}
function __mapsGET(context: QueryFunctionContext) {
  return Client().mapsGET(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as number | undefined    );
}

export function useMapsGETQuery<TSelectData = Types.GetMapsRespApiRespBase, TError = unknown>(dto: MapsGETQueryParameters, options?: UseQueryOptions<Types.GetMapsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get maps by condition
 * @param name (optional) Maps Name
 * @param gameId (optional) Maps Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useMapsGETQuery<TSelectData = Types.GetMapsRespApiRespBase, TError = unknown>(name: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetMapsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMapsGETQuery<TSelectData = Types.GetMapsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetMapsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let name: any = undefined;
  let gameId: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ name, gameId, pageNo, pageSize,  } = params[0] as MapsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [name, gameId, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetMapsRespApiRespBase, TError, TSelectData>({
    queryFn: __mapsGET,
    queryKey: mapsGETQueryKey(name, gameId, pageNo, pageSize),
    ...mapsGETDefaultOptions as unknown as UseQueryOptions<Types.GetMapsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get maps by condition
 * @param name (optional) Maps Name
 * @param gameId (optional) Maps Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setMapsGETData(queryClient: QueryClient, updater: (data: Types.GetMapsRespApiRespBase | undefined) => Types.GetMapsRespApiRespBase, name: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(mapsGETQueryKey(name, gameId, pageNo, pageSize),
    updater
  );
}

/**
 * Get maps by condition
 * @param name (optional) Maps Name
 * @param gameId (optional) Maps Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setMapsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetMapsRespApiRespBase | undefined) => Types.GetMapsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function mapsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/maps";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function mapsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'mapsPOST',
    ]);
}

/**
 * Add new game map
 * @param name (optional) Game Map Name
 * @param imageFile (optional) Image file
 * @param gameId (optional) Map Game Id
 * @return Error
 */
export function useMapsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddMapRespApiRespBase, unknown, MapsPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddMapRespApiRespBase, unknown, MapsPOSTMutationParameters, TContext> {
  const key = mapsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((mapsPOSTMutationParameters: MapsPOSTMutationParameters) => Client().mapsPOST(mapsPOSTMutationParameters.name, mapsPOSTMutationParameters.imageFile, mapsPOSTMutationParameters.gameId), {...options, mutationKey: key});
}
  
    
export function mapsGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/maps/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let mapsGET2DefaultOptions: UseQueryOptions<Types.GetMapRespApiRespBase, unknown, Types.GetMapRespApiRespBase> = {
  queryFn: __mapsGET2,
};
export function getMapsGET2DefaultOptions(): UseQueryOptions<Types.GetMapRespApiRespBase, unknown, Types.GetMapRespApiRespBase> {
  return mapsGET2DefaultOptions;
};
export function setMapsGET2DefaultOptions(options: UseQueryOptions<Types.GetMapRespApiRespBase, unknown, Types.GetMapRespApiRespBase>) {
  mapsGET2DefaultOptions = options;
}

export function mapsGET2QueryKey(id: number): QueryKey;
export function mapsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as MapsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'mapsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'mapsGET2',
        ...params
      ]);
  }
}
function __mapsGET2(context: QueryFunctionContext) {
  return Client().mapsGET2(
      context.queryKey[2] as number    );
}

export function useMapsGET2Query<TSelectData = Types.GetMapRespApiRespBase, TError = unknown>(dto: MapsGET2QueryParameters, options?: UseQueryOptions<Types.GetMapRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get game map
 * @param id Maps Id
 * @return Error
 */
export function useMapsGET2Query<TSelectData = Types.GetMapRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetMapRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMapsGET2Query<TSelectData = Types.GetMapRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetMapRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as MapsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetMapRespApiRespBase, TError, TSelectData>({
    queryFn: __mapsGET2,
    queryKey: mapsGET2QueryKey(id),
    ...mapsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetMapRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get game map
 * @param id Maps Id
 * @return Error
 */
export function setMapsGET2Data(queryClient: QueryClient, updater: (data: Types.GetMapRespApiRespBase | undefined) => Types.GetMapRespApiRespBase, id: number) {
  queryClient.setQueryData(mapsGET2QueryKey(id),
    updater
  );
}

/**
 * Get game map
 * @param id Maps Id
 * @return Error
 */
export function setMapsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetMapRespApiRespBase | undefined) => Types.GetMapRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function mapsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/maps/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function mapsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'mapsPATCH',
      id as any,
    ]);
}

/**
 * Modify game map
 * @param id game map Id
 * @param id (optional) Game Map Id
 * @param name (optional) Game Map Name
 * @param imageFile (optional) Image file
 * @param gameId (optional) Map Game Id
 * @return Error
 */
export function useMapsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModMapRespApiRespBase, unknown, MapsPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModMapRespApiRespBase, unknown, MapsPATCHMutationParameters, TContext> {
  const key = mapsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((mapsPATCHMutationParameters: MapsPATCHMutationParameters) => Client().mapsPATCH(id, mapsPATCHMutationParameters.id, mapsPATCHMutationParameters.name, mapsPATCHMutationParameters.imageFile, mapsPATCHMutationParameters.gameId), {...options, mutationKey: key});
}
  
    
export function mapsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/maps/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function mapsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'mapsDELETE',
      id as any,
    ]);
}

/**
 * Delete game map
 * @param id game map Id
 * @return Error
 */
export function useMapsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelMapRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelMapRespApiRespBase, unknown, void, TContext> {
  const key = mapsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().mapsDELETE(id), {...options, mutationKey: key});
}
  
    
export function translationsGET4Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/maps/{id}/translations";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let translationsGET4DefaultOptions: UseQueryOptions<Types.GetMapTranslationsRespApiRespBase, unknown, Types.GetMapTranslationsRespApiRespBase> = {
  queryFn: __translationsGET4,
};
export function getTranslationsGET4DefaultOptions(): UseQueryOptions<Types.GetMapTranslationsRespApiRespBase, unknown, Types.GetMapTranslationsRespApiRespBase> {
  return translationsGET4DefaultOptions;
};
export function setTranslationsGET4DefaultOptions(options: UseQueryOptions<Types.GetMapTranslationsRespApiRespBase, unknown, Types.GetMapTranslationsRespApiRespBase>) {
  translationsGET4DefaultOptions = options;
}

export function translationsGET4QueryKey(id: number): QueryKey;
export function translationsGET4QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as TranslationsGET4QueryParameters;

    return trimArrayEnd([
        'Client',
        'translationsGET4',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'translationsGET4',
        ...params
      ]);
  }
}
function __translationsGET4(context: QueryFunctionContext) {
  return Client().translationsGET4(
      context.queryKey[2] as number    );
}

export function useTranslationsGET4Query<TSelectData = Types.GetMapTranslationsRespApiRespBase, TError = unknown>(dto: TranslationsGET4QueryParameters, options?: UseQueryOptions<Types.GetMapTranslationsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get game map translations
 * @param id Maps Id
 * @return Error
 */
export function useTranslationsGET4Query<TSelectData = Types.GetMapTranslationsRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetMapTranslationsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTranslationsGET4Query<TSelectData = Types.GetMapTranslationsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetMapTranslationsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as TranslationsGET4QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetMapTranslationsRespApiRespBase, TError, TSelectData>({
    queryFn: __translationsGET4,
    queryKey: translationsGET4QueryKey(id),
    ...translationsGET4DefaultOptions as unknown as UseQueryOptions<Types.GetMapTranslationsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get game map translations
 * @param id Maps Id
 * @return Error
 */
export function setTranslationsGET4Data(queryClient: QueryClient, updater: (data: Types.GetMapTranslationsRespApiRespBase | undefined) => Types.GetMapTranslationsRespApiRespBase, id: number) {
  queryClient.setQueryData(translationsGET4QueryKey(id),
    updater
  );
}

/**
 * Get game map translations
 * @param id Maps Id
 * @return Error
 */
export function setTranslationsGET4DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetMapTranslationsRespApiRespBase | undefined) => Types.GetMapTranslationsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function translationsPATCH5Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/maps/{id}/translations";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function translationsPATCH5MutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'translationsPATCH5',
      id as any,
    ]);
}

/**
 * Modify game map translations
 * @param id game map Id
 * @param body (optional) Request
 * @return Error
 */
export function useTranslationsPATCH5Mutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModMapTranslationsRespApiRespBase, unknown, Types.ModMapTranslationsReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModMapTranslationsRespApiRespBase, unknown, Types.ModMapTranslationsReq, TContext> {
  const key = translationsPATCH5MutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModMapTranslationsReq) => Client().translationsPATCH5(id, body), {...options, mutationKey: key});
}
  
    
export function streamsGETUrl(title: string | undefined, creator: string | undefined, platformId: Types.EnumPlatform | undefined, streamId: string | undefined, gameId: number | undefined, isLive: boolean | undefined, createdFrom: number | undefined, createdTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/media/streams?";
if (title === null)
    throw new Error("The parameter 'title' cannot be null.");
else if (title !== undefined)
    url_ += "Title=" + encodeURIComponent("" + title) + "&";
if (creator === null)
    throw new Error("The parameter 'creator' cannot be null.");
else if (creator !== undefined)
    url_ += "Creator=" + encodeURIComponent("" + creator) + "&";
if (platformId === null)
    throw new Error("The parameter 'platformId' cannot be null.");
else if (platformId !== undefined)
    url_ += "PlatformId=" + encodeURIComponent("" + platformId) + "&";
if (streamId === null)
    throw new Error("The parameter 'streamId' cannot be null.");
else if (streamId !== undefined)
    url_ += "StreamId=" + encodeURIComponent("" + streamId) + "&";
if (gameId === null)
    throw new Error("The parameter 'gameId' cannot be null.");
else if (gameId !== undefined)
    url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
if (isLive === null)
    throw new Error("The parameter 'isLive' cannot be null.");
else if (isLive !== undefined)
    url_ += "IsLive=" + encodeURIComponent("" + isLive) + "&";
if (createdFrom === null)
    throw new Error("The parameter 'createdFrom' cannot be null.");
else if (createdFrom !== undefined)
    url_ += "CreatedFrom=" + encodeURIComponent("" + createdFrom) + "&";
if (createdTo === null)
    throw new Error("The parameter 'createdTo' cannot be null.");
else if (createdTo !== undefined)
    url_ += "CreatedTo=" + encodeURIComponent("" + createdTo) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let streamsGETDefaultOptions: UseQueryOptions<Types.GetStreamsRespApiRespBase, unknown, Types.GetStreamsRespApiRespBase> = {
  queryFn: __streamsGET,
};
export function getStreamsGETDefaultOptions(): UseQueryOptions<Types.GetStreamsRespApiRespBase, unknown, Types.GetStreamsRespApiRespBase> {
  return streamsGETDefaultOptions;
};
export function setStreamsGETDefaultOptions(options: UseQueryOptions<Types.GetStreamsRespApiRespBase, unknown, Types.GetStreamsRespApiRespBase>) {
  streamsGETDefaultOptions = options;
}

export function streamsGETQueryKey(dto: StreamsGETQueryParameters): QueryKey;
export function streamsGETQueryKey(title: string | undefined, creator: string | undefined, platformId: Types.EnumPlatform | undefined, streamId: string | undefined, gameId: number | undefined, isLive: boolean | undefined, createdFrom: number | undefined, createdTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function streamsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { title, creator, platformId, streamId, gameId, isLive, createdFrom, createdTo, pageNo, pageSize,  } = params[0] as StreamsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'streamsGET',
        title as any,
        creator as any,
        platformId as any,
        streamId as any,
        gameId as any,
        isLive as any,
        createdFrom as any,
        createdTo as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'streamsGET',
        ...params
      ]);
  }
}
function __streamsGET(context: QueryFunctionContext) {
  return Client().streamsGET(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as Types.EnumPlatform | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as number | undefined,       context.queryKey[7] as boolean | undefined,       context.queryKey[8] as number | undefined,       context.queryKey[9] as number | undefined,       context.queryKey[10] as number | undefined,       context.queryKey[11] as number | undefined    );
}

export function useStreamsGETQuery<TSelectData = Types.GetStreamsRespApiRespBase, TError = unknown>(dto: StreamsGETQueryParameters, options?: UseQueryOptions<Types.GetStreamsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get media streams by condition
 * @param title (optional) Title
 * @param creator (optional) Creator(Username)
 * @param platformId (optional) Platform Id (TwitchTV = 1,Youtube_Channel = 10,Youtube_Stream = 11,Other = 99)
 * @param streamId (optional) Stream Id
 * @param gameId (optional) Game Id
 * @param isLive (optional) Is Live
 * @param createdFrom (optional) Created From
 * @param createdTo (optional) Created To
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useStreamsGETQuery<TSelectData = Types.GetStreamsRespApiRespBase, TError = unknown>(title: string | undefined, creator: string | undefined, platformId: Types.EnumPlatform | undefined, streamId: string | undefined, gameId: number | undefined, isLive: boolean | undefined, createdFrom: number | undefined, createdTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetStreamsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useStreamsGETQuery<TSelectData = Types.GetStreamsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetStreamsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let title: any = undefined;
  let creator: any = undefined;
  let platformId: any = undefined;
  let streamId: any = undefined;
  let gameId: any = undefined;
  let isLive: any = undefined;
  let createdFrom: any = undefined;
  let createdTo: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ title, creator, platformId, streamId, gameId, isLive, createdFrom, createdTo, pageNo, pageSize,  } = params[0] as StreamsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [title, creator, platformId, streamId, gameId, isLive, createdFrom, createdTo, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetStreamsRespApiRespBase, TError, TSelectData>({
    queryFn: __streamsGET,
    queryKey: streamsGETQueryKey(title, creator, platformId, streamId, gameId, isLive, createdFrom, createdTo, pageNo, pageSize),
    ...streamsGETDefaultOptions as unknown as UseQueryOptions<Types.GetStreamsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get media streams by condition
 * @param title (optional) Title
 * @param creator (optional) Creator(Username)
 * @param platformId (optional) Platform Id (TwitchTV = 1,Youtube_Channel = 10,Youtube_Stream = 11,Other = 99)
 * @param streamId (optional) Stream Id
 * @param gameId (optional) Game Id
 * @param isLive (optional) Is Live
 * @param createdFrom (optional) Created From
 * @param createdTo (optional) Created To
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setStreamsGETData(queryClient: QueryClient, updater: (data: Types.GetStreamsRespApiRespBase | undefined) => Types.GetStreamsRespApiRespBase, title: string | undefined, creator: string | undefined, platformId: Types.EnumPlatform | undefined, streamId: string | undefined, gameId: number | undefined, isLive: boolean | undefined, createdFrom: number | undefined, createdTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(streamsGETQueryKey(title, creator, platformId, streamId, gameId, isLive, createdFrom, createdTo, pageNo, pageSize),
    updater
  );
}

/**
 * Get media streams by condition
 * @param title (optional) Title
 * @param creator (optional) Creator(Username)
 * @param platformId (optional) Platform Id (TwitchTV = 1,Youtube_Channel = 10,Youtube_Stream = 11,Other = 99)
 * @param streamId (optional) Stream Id
 * @param gameId (optional) Game Id
 * @param isLive (optional) Is Live
 * @param createdFrom (optional) Created From
 * @param createdTo (optional) Created To
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setStreamsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetStreamsRespApiRespBase | undefined) => Types.GetStreamsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function streamsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/media/streams";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function streamsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'streamsPOST',
    ]);
}

/**
 * Add new media stream
 * @param platform (optional) 
 * @param streamId (optional) StreamId
 * @param streamUrl (optional) Stream Url
 * @param screenCapFile (optional) Screen Cap file
 * @param gameId (optional) GameId
 * @param languageId (optional) LanguageId
 * @param isEventStream (optional) Is Event Stream
 * @param isProPlayer (optional) Is Pro Player
 * @param isCelebCaster (optional) Is Celeb Caster
 * @param nextBroadcastAt (optional) Next Broadcast At
 * @param title (optional) Title
 * @param isFeatured (optional) Is Featured
 * @param description (optional) Description
 * @param tags (optional) Tags : Maximum of 5 tags(25 characters maximum per tag)
 * @return Error
 */
export function useStreamsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddStreamRespApiRespBase, unknown, StreamsPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddStreamRespApiRespBase, unknown, StreamsPOSTMutationParameters, TContext> {
  const key = streamsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((streamsPOSTMutationParameters: StreamsPOSTMutationParameters) => Client().streamsPOST(streamsPOSTMutationParameters.platform, streamsPOSTMutationParameters.streamId, streamsPOSTMutationParameters.streamUrl, streamsPOSTMutationParameters.screenCapFile, streamsPOSTMutationParameters.gameId, streamsPOSTMutationParameters.languageId, streamsPOSTMutationParameters.isEventStream, streamsPOSTMutationParameters.isProPlayer, streamsPOSTMutationParameters.isCelebCaster, streamsPOSTMutationParameters.nextBroadcastAt, streamsPOSTMutationParameters.title, streamsPOSTMutationParameters.isFeatured, streamsPOSTMutationParameters.description, streamsPOSTMutationParameters.tags), {...options, mutationKey: key});
}
  
    
export function streamsGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/media/streams/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let streamsGET2DefaultOptions: UseQueryOptions<Types.GetStreamRespApiRespBase, unknown, Types.GetStreamRespApiRespBase> = {
  queryFn: __streamsGET2,
};
export function getStreamsGET2DefaultOptions(): UseQueryOptions<Types.GetStreamRespApiRespBase, unknown, Types.GetStreamRespApiRespBase> {
  return streamsGET2DefaultOptions;
};
export function setStreamsGET2DefaultOptions(options: UseQueryOptions<Types.GetStreamRespApiRespBase, unknown, Types.GetStreamRespApiRespBase>) {
  streamsGET2DefaultOptions = options;
}

export function streamsGET2QueryKey(id: number): QueryKey;
export function streamsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as StreamsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'streamsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'streamsGET2',
        ...params
      ]);
  }
}
function __streamsGET2(context: QueryFunctionContext) {
  return Client().streamsGET2(
      context.queryKey[2] as number    );
}

export function useStreamsGET2Query<TSelectData = Types.GetStreamRespApiRespBase, TError = unknown>(dto: StreamsGET2QueryParameters, options?: UseQueryOptions<Types.GetStreamRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get media stream detail
 * @param id media item Id
 * @return Error
 */
export function useStreamsGET2Query<TSelectData = Types.GetStreamRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetStreamRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useStreamsGET2Query<TSelectData = Types.GetStreamRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetStreamRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as StreamsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetStreamRespApiRespBase, TError, TSelectData>({
    queryFn: __streamsGET2,
    queryKey: streamsGET2QueryKey(id),
    ...streamsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetStreamRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get media stream detail
 * @param id media item Id
 * @return Error
 */
export function setStreamsGET2Data(queryClient: QueryClient, updater: (data: Types.GetStreamRespApiRespBase | undefined) => Types.GetStreamRespApiRespBase, id: number) {
  queryClient.setQueryData(streamsGET2QueryKey(id),
    updater
  );
}

/**
 * Get media stream detail
 * @param id media item Id
 * @return Error
 */
export function setStreamsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetStreamRespApiRespBase | undefined) => Types.GetStreamRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function streamsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/media/streams/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function streamsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'streamsPATCH',
      id as any,
    ]);
}

/**
 * Modify media stream
 * @param id media item Id
 * @param id (optional) Media Item Id
 * @param platform (optional) 
 * @param streamId (optional) StreamId
 * @param streamUrl (optional) Stream Url
 * @param screenCapFile (optional) Screen Cap file
 * @param gameId (optional) GameId
 * @param languageId (optional) LanguageId
 * @param isEventStream (optional) Is Event Stream
 * @param isProPlayer (optional) Is Pro Player
 * @param isCelebCaster (optional) Is Celeb Caster
 * @param nextBroadcastAt (optional) Next Broadcast At
 * @param title (optional) Title
 * @param isFeatured (optional) Is Featured
 * @param description (optional) Description
 * @param tags (optional) Tags : Maximum of 5 tags(25 characters maximum per tag)
 * @return Error
 */
export function useStreamsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModStreamRespApiRespBase, unknown, StreamsPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModStreamRespApiRespBase, unknown, StreamsPATCHMutationParameters, TContext> {
  const key = streamsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((streamsPATCHMutationParameters: StreamsPATCHMutationParameters) => Client().streamsPATCH(id, streamsPATCHMutationParameters.id, streamsPATCHMutationParameters.platform, streamsPATCHMutationParameters.streamId, streamsPATCHMutationParameters.streamUrl, streamsPATCHMutationParameters.screenCapFile, streamsPATCHMutationParameters.gameId, streamsPATCHMutationParameters.languageId, streamsPATCHMutationParameters.isEventStream, streamsPATCHMutationParameters.isProPlayer, streamsPATCHMutationParameters.isCelebCaster, streamsPATCHMutationParameters.nextBroadcastAt, streamsPATCHMutationParameters.title, streamsPATCHMutationParameters.isFeatured, streamsPATCHMutationParameters.description, streamsPATCHMutationParameters.tags), {...options, mutationKey: key});
}
  
    
export function streamsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/media/streams/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function streamsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'streamsDELETE',
      id as any,
    ]);
}

/**
 * Delete media stream
 * @param id media stream Id
 * @return Error
 */
export function useStreamsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelStreamRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelStreamRespApiRespBase, unknown, void, TContext> {
  const key = streamsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().streamsDELETE(id), {...options, mutationKey: key});
}
  
    
export function fuzzyStreamsUrl(fuzzyPrefix: string | undefined, maxCount: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/media/fuzzy-streams?";
if (fuzzyPrefix === null)
    throw new Error("The parameter 'fuzzyPrefix' cannot be null.");
else if (fuzzyPrefix !== undefined)
    url_ += "FuzzyPrefix=" + encodeURIComponent("" + fuzzyPrefix) + "&";
if (maxCount === null)
    throw new Error("The parameter 'maxCount' cannot be null.");
else if (maxCount !== undefined)
    url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let fuzzyStreamsDefaultOptions: UseQueryOptions<Types.GetFuzzyMediaStreamsRespApiRespBase, unknown, Types.GetFuzzyMediaStreamsRespApiRespBase> = {
  queryFn: __fuzzyStreams,
};
export function getFuzzyStreamsDefaultOptions(): UseQueryOptions<Types.GetFuzzyMediaStreamsRespApiRespBase, unknown, Types.GetFuzzyMediaStreamsRespApiRespBase> {
  return fuzzyStreamsDefaultOptions;
};
export function setFuzzyStreamsDefaultOptions(options: UseQueryOptions<Types.GetFuzzyMediaStreamsRespApiRespBase, unknown, Types.GetFuzzyMediaStreamsRespApiRespBase>) {
  fuzzyStreamsDefaultOptions = options;
}

export function fuzzyStreamsQueryKey(dto: FuzzyStreamsQueryParameters): QueryKey;
export function fuzzyStreamsQueryKey(fuzzyPrefix: string | undefined, maxCount: number | undefined): QueryKey;
export function fuzzyStreamsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { fuzzyPrefix, maxCount,  } = params[0] as FuzzyStreamsQueryParameters;

    return trimArrayEnd([
        'Client',
        'fuzzyStreams',
        fuzzyPrefix as any,
        maxCount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'fuzzyStreams',
        ...params
      ]);
  }
}
function __fuzzyStreams(context: QueryFunctionContext) {
  return Client().fuzzyStreams(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined    );
}

export function useFuzzyStreamsQuery<TSelectData = Types.GetFuzzyMediaStreamsRespApiRespBase, TError = unknown>(dto: FuzzyStreamsQueryParameters, options?: UseQueryOptions<Types.GetFuzzyMediaStreamsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get fuzzy media streams
 * @param fuzzyPrefix (optional) FuzzyPrefix
 * @param maxCount (optional) 
 * @return Error
 */
export function useFuzzyStreamsQuery<TSelectData = Types.GetFuzzyMediaStreamsRespApiRespBase, TError = unknown>(fuzzyPrefix: string | undefined, maxCount: number | undefined, options?: UseQueryOptions<Types.GetFuzzyMediaStreamsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFuzzyStreamsQuery<TSelectData = Types.GetFuzzyMediaStreamsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuzzyMediaStreamsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let fuzzyPrefix: any = undefined;
  let maxCount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ fuzzyPrefix, maxCount,  } = params[0] as FuzzyStreamsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [fuzzyPrefix, maxCount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuzzyMediaStreamsRespApiRespBase, TError, TSelectData>({
    queryFn: __fuzzyStreams,
    queryKey: fuzzyStreamsQueryKey(fuzzyPrefix, maxCount),
    ...fuzzyStreamsDefaultOptions as unknown as UseQueryOptions<Types.GetFuzzyMediaStreamsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get fuzzy media streams
 * @param fuzzyPrefix (optional) FuzzyPrefix
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzyStreamsData(queryClient: QueryClient, updater: (data: Types.GetFuzzyMediaStreamsRespApiRespBase | undefined) => Types.GetFuzzyMediaStreamsRespApiRespBase, fuzzyPrefix: string | undefined, maxCount: number | undefined) {
  queryClient.setQueryData(fuzzyStreamsQueryKey(fuzzyPrefix, maxCount),
    updater
  );
}

/**
 * Get fuzzy media streams
 * @param fuzzyPrefix (optional) FuzzyPrefix
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzyStreamsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuzzyMediaStreamsRespApiRespBase | undefined) => Types.GetFuzzyMediaStreamsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function fuzzyVideosUrl(fuzzyPrefix: string | undefined, maxCount: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/media/fuzzy-videos?";
if (fuzzyPrefix === null)
    throw new Error("The parameter 'fuzzyPrefix' cannot be null.");
else if (fuzzyPrefix !== undefined)
    url_ += "FuzzyPrefix=" + encodeURIComponent("" + fuzzyPrefix) + "&";
if (maxCount === null)
    throw new Error("The parameter 'maxCount' cannot be null.");
else if (maxCount !== undefined)
    url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let fuzzyVideosDefaultOptions: UseQueryOptions<Types.GetFuzzyMediaVideosRespApiRespBase, unknown, Types.GetFuzzyMediaVideosRespApiRespBase> = {
  queryFn: __fuzzyVideos,
};
export function getFuzzyVideosDefaultOptions(): UseQueryOptions<Types.GetFuzzyMediaVideosRespApiRespBase, unknown, Types.GetFuzzyMediaVideosRespApiRespBase> {
  return fuzzyVideosDefaultOptions;
};
export function setFuzzyVideosDefaultOptions(options: UseQueryOptions<Types.GetFuzzyMediaVideosRespApiRespBase, unknown, Types.GetFuzzyMediaVideosRespApiRespBase>) {
  fuzzyVideosDefaultOptions = options;
}

export function fuzzyVideosQueryKey(dto: FuzzyVideosQueryParameters): QueryKey;
export function fuzzyVideosQueryKey(fuzzyPrefix: string | undefined, maxCount: number | undefined): QueryKey;
export function fuzzyVideosQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { fuzzyPrefix, maxCount,  } = params[0] as FuzzyVideosQueryParameters;

    return trimArrayEnd([
        'Client',
        'fuzzyVideos',
        fuzzyPrefix as any,
        maxCount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'fuzzyVideos',
        ...params
      ]);
  }
}
function __fuzzyVideos(context: QueryFunctionContext) {
  return Client().fuzzyVideos(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined    );
}

export function useFuzzyVideosQuery<TSelectData = Types.GetFuzzyMediaVideosRespApiRespBase, TError = unknown>(dto: FuzzyVideosQueryParameters, options?: UseQueryOptions<Types.GetFuzzyMediaVideosRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get fuzzy media videos
 * @param fuzzyPrefix (optional) FuzzyPrefix
 * @param maxCount (optional) 
 * @return Error
 */
export function useFuzzyVideosQuery<TSelectData = Types.GetFuzzyMediaVideosRespApiRespBase, TError = unknown>(fuzzyPrefix: string | undefined, maxCount: number | undefined, options?: UseQueryOptions<Types.GetFuzzyMediaVideosRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFuzzyVideosQuery<TSelectData = Types.GetFuzzyMediaVideosRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuzzyMediaVideosRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let fuzzyPrefix: any = undefined;
  let maxCount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ fuzzyPrefix, maxCount,  } = params[0] as FuzzyVideosQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [fuzzyPrefix, maxCount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuzzyMediaVideosRespApiRespBase, TError, TSelectData>({
    queryFn: __fuzzyVideos,
    queryKey: fuzzyVideosQueryKey(fuzzyPrefix, maxCount),
    ...fuzzyVideosDefaultOptions as unknown as UseQueryOptions<Types.GetFuzzyMediaVideosRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get fuzzy media videos
 * @param fuzzyPrefix (optional) FuzzyPrefix
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzyVideosData(queryClient: QueryClient, updater: (data: Types.GetFuzzyMediaVideosRespApiRespBase | undefined) => Types.GetFuzzyMediaVideosRespApiRespBase, fuzzyPrefix: string | undefined, maxCount: number | undefined) {
  queryClient.setQueryData(fuzzyVideosQueryKey(fuzzyPrefix, maxCount),
    updater
  );
}

/**
 * Get fuzzy media videos
 * @param fuzzyPrefix (optional) FuzzyPrefix
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzyVideosDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuzzyMediaVideosRespApiRespBase | undefined) => Types.GetFuzzyMediaVideosRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function hostOptionsUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/media/vods/host-options";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let hostOptionsDefaultOptions: UseQueryOptions<Types.GetMediaVodHostOptionsResp, unknown, Types.GetMediaVodHostOptionsResp> = {
  queryFn: __hostOptions,
};
export function getHostOptionsDefaultOptions(): UseQueryOptions<Types.GetMediaVodHostOptionsResp, unknown, Types.GetMediaVodHostOptionsResp> {
  return hostOptionsDefaultOptions;
};
export function setHostOptionsDefaultOptions(options: UseQueryOptions<Types.GetMediaVodHostOptionsResp, unknown, Types.GetMediaVodHostOptionsResp>) {
  hostOptionsDefaultOptions = options;
}

export function hostOptionsQueryKey(): QueryKey;
export function hostOptionsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'hostOptions',
    ]);
}
function __hostOptions() {
  return Client().hostOptions(
    );
}

/**
 * Get media vod host options
 * @return Error
 */
export function useHostOptionsQuery<TSelectData = Types.GetMediaVodHostOptionsResp, TError = unknown>(options?: UseQueryOptions<Types.GetMediaVodHostOptionsResp, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useHostOptionsQuery<TSelectData = Types.GetMediaVodHostOptionsResp, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetMediaVodHostOptionsResp, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetMediaVodHostOptionsResp, TError, TSelectData>({
    queryFn: __hostOptions,
    queryKey: hostOptionsQueryKey(),
    ...hostOptionsDefaultOptions as unknown as UseQueryOptions<Types.GetMediaVodHostOptionsResp, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get media vod host options
 * @return Error
 */
export function setHostOptionsData(queryClient: QueryClient, updater: (data: Types.GetMediaVodHostOptionsResp | undefined) => Types.GetMediaVodHostOptionsResp, ) {
  queryClient.setQueryData(hostOptionsQueryKey(),
    updater
  );
}

/**
 * Get media vod host options
 * @return Error
 */
export function setHostOptionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetMediaVodHostOptionsResp | undefined) => Types.GetMediaVodHostOptionsResp) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function vodsGETUrl(vodId: number | undefined, title: string | undefined, hostId: number | undefined, hostVideoId: string | undefined, siteSectionIds: number[] | undefined, createdFrom: number | undefined, createdTo: number | undefined, creator: string | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/media/vods?";
if (vodId === null)
    throw new Error("The parameter 'vodId' cannot be null.");
else if (vodId !== undefined)
    url_ += "VodId=" + encodeURIComponent("" + vodId) + "&";
if (title === null)
    throw new Error("The parameter 'title' cannot be null.");
else if (title !== undefined)
    url_ += "Title=" + encodeURIComponent("" + title) + "&";
if (hostId === null)
    throw new Error("The parameter 'hostId' cannot be null.");
else if (hostId !== undefined)
    url_ += "HostId=" + encodeURIComponent("" + hostId) + "&";
if (hostVideoId === null)
    throw new Error("The parameter 'hostVideoId' cannot be null.");
else if (hostVideoId !== undefined)
    url_ += "HostVideoId=" + encodeURIComponent("" + hostVideoId) + "&";
if (siteSectionIds === null)
    throw new Error("The parameter 'siteSectionIds' cannot be null.");
else if (siteSectionIds !== undefined)
    siteSectionIds && siteSectionIds.forEach(item => { url_ += "SiteSectionIds=" + encodeURIComponent("" + item) + "&"; });
if (createdFrom === null)
    throw new Error("The parameter 'createdFrom' cannot be null.");
else if (createdFrom !== undefined)
    url_ += "CreatedFrom=" + encodeURIComponent("" + createdFrom) + "&";
if (createdTo === null)
    throw new Error("The parameter 'createdTo' cannot be null.");
else if (createdTo !== undefined)
    url_ += "CreatedTo=" + encodeURIComponent("" + createdTo) + "&";
if (creator === null)
    throw new Error("The parameter 'creator' cannot be null.");
else if (creator !== undefined)
    url_ += "Creator=" + encodeURIComponent("" + creator) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let vodsGETDefaultOptions: UseQueryOptions<Types.GetMediaVodsRespApiRespBase, unknown, Types.GetMediaVodsRespApiRespBase> = {
  queryFn: __vodsGET,
};
export function getVodsGETDefaultOptions(): UseQueryOptions<Types.GetMediaVodsRespApiRespBase, unknown, Types.GetMediaVodsRespApiRespBase> {
  return vodsGETDefaultOptions;
};
export function setVodsGETDefaultOptions(options: UseQueryOptions<Types.GetMediaVodsRespApiRespBase, unknown, Types.GetMediaVodsRespApiRespBase>) {
  vodsGETDefaultOptions = options;
}

export function vodsGETQueryKey(dto: VodsGETQueryParameters): QueryKey;
export function vodsGETQueryKey(vodId: number | undefined, title: string | undefined, hostId: number | undefined, hostVideoId: string | undefined, siteSectionIds: number[] | undefined, createdFrom: number | undefined, createdTo: number | undefined, creator: string | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function vodsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { vodId, title, hostId, hostVideoId, siteSectionIds, createdFrom, createdTo, creator, pageNo, pageSize,  } = params[0] as VodsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'vodsGET',
        vodId as any,
        title as any,
        hostId as any,
        hostVideoId as any,
        siteSectionIds as any,
        createdFrom as any,
        createdTo as any,
        creator as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'vodsGET',
        ...params
      ]);
  }
}
function __vodsGET(context: QueryFunctionContext) {
  return Client().vodsGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as number[] | undefined,       context.queryKey[7] as number | undefined,       context.queryKey[8] as number | undefined,       context.queryKey[9] as string | undefined,       context.queryKey[10] as number | undefined,       context.queryKey[11] as number | undefined    );
}

export function useVodsGETQuery<TSelectData = Types.GetMediaVodsRespApiRespBase, TError = unknown>(dto: VodsGETQueryParameters, options?: UseQueryOptions<Types.GetMediaVodsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get media vods
 * @param vodId (optional) Vod id
 * @param title (optional) vod title
 * @param hostId (optional) Host id
 * @param hostVideoId (optional) Host video id
 * @param siteSectionIds (optional) Site section ids
 * @param createdFrom (optional) Created From
 * @param createdTo (optional) Created To
 * @param creator (optional) Creator user name
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useVodsGETQuery<TSelectData = Types.GetMediaVodsRespApiRespBase, TError = unknown>(vodId: number | undefined, title: string | undefined, hostId: number | undefined, hostVideoId: string | undefined, siteSectionIds: number[] | undefined, createdFrom: number | undefined, createdTo: number | undefined, creator: string | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetMediaVodsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useVodsGETQuery<TSelectData = Types.GetMediaVodsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetMediaVodsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let vodId: any = undefined;
  let title: any = undefined;
  let hostId: any = undefined;
  let hostVideoId: any = undefined;
  let siteSectionIds: any = undefined;
  let createdFrom: any = undefined;
  let createdTo: any = undefined;
  let creator: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ vodId, title, hostId, hostVideoId, siteSectionIds, createdFrom, createdTo, creator, pageNo, pageSize,  } = params[0] as VodsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [vodId, title, hostId, hostVideoId, siteSectionIds, createdFrom, createdTo, creator, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetMediaVodsRespApiRespBase, TError, TSelectData>({
    queryFn: __vodsGET,
    queryKey: vodsGETQueryKey(vodId, title, hostId, hostVideoId, siteSectionIds, createdFrom, createdTo, creator, pageNo, pageSize),
    ...vodsGETDefaultOptions as unknown as UseQueryOptions<Types.GetMediaVodsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get media vods
 * @param vodId (optional) Vod id
 * @param title (optional) vod title
 * @param hostId (optional) Host id
 * @param hostVideoId (optional) Host video id
 * @param siteSectionIds (optional) Site section ids
 * @param createdFrom (optional) Created From
 * @param createdTo (optional) Created To
 * @param creator (optional) Creator user name
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setVodsGETData(queryClient: QueryClient, updater: (data: Types.GetMediaVodsRespApiRespBase | undefined) => Types.GetMediaVodsRespApiRespBase, vodId: number | undefined, title: string | undefined, hostId: number | undefined, hostVideoId: string | undefined, siteSectionIds: number[] | undefined, createdFrom: number | undefined, createdTo: number | undefined, creator: string | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(vodsGETQueryKey(vodId, title, hostId, hostVideoId, siteSectionIds, createdFrom, createdTo, creator, pageNo, pageSize),
    updater
  );
}

/**
 * Get media vods
 * @param vodId (optional) Vod id
 * @param title (optional) vod title
 * @param hostId (optional) Host id
 * @param hostVideoId (optional) Host video id
 * @param siteSectionIds (optional) Site section ids
 * @param createdFrom (optional) Created From
 * @param createdTo (optional) Created To
 * @param creator (optional) Creator user name
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setVodsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetMediaVodsRespApiRespBase | undefined) => Types.GetMediaVodsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function vodsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/media/vods";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function vodsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'vodsPOST',
    ]);
}

/**
 * Add media vod
 * @param body (optional) 
 * @return Error
 */
export function useVodsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddMediaVodRespApiRespBase, unknown, Types.AddMediaVodReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddMediaVodRespApiRespBase, unknown, Types.AddMediaVodReq, TContext> {
  const key = vodsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.AddMediaVodReq) => Client().vodsPOST(body), {...options, mutationKey: key});
}
  
    
export function vodsGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/media/vods/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let vodsGET2DefaultOptions: UseQueryOptions<Types.GetMediaVodRespApiRespBase, unknown, Types.GetMediaVodRespApiRespBase> = {
  queryFn: __vodsGET2,
};
export function getVodsGET2DefaultOptions(): UseQueryOptions<Types.GetMediaVodRespApiRespBase, unknown, Types.GetMediaVodRespApiRespBase> {
  return vodsGET2DefaultOptions;
};
export function setVodsGET2DefaultOptions(options: UseQueryOptions<Types.GetMediaVodRespApiRespBase, unknown, Types.GetMediaVodRespApiRespBase>) {
  vodsGET2DefaultOptions = options;
}

export function vodsGET2QueryKey(id: number): QueryKey;
export function vodsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as VodsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'vodsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'vodsGET2',
        ...params
      ]);
  }
}
function __vodsGET2(context: QueryFunctionContext) {
  return Client().vodsGET2(
      context.queryKey[2] as number    );
}

export function useVodsGET2Query<TSelectData = Types.GetMediaVodRespApiRespBase, TError = unknown>(dto: VodsGET2QueryParameters, options?: UseQueryOptions<Types.GetMediaVodRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get media vod
 * @return Error
 */
export function useVodsGET2Query<TSelectData = Types.GetMediaVodRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetMediaVodRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useVodsGET2Query<TSelectData = Types.GetMediaVodRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetMediaVodRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as VodsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetMediaVodRespApiRespBase, TError, TSelectData>({
    queryFn: __vodsGET2,
    queryKey: vodsGET2QueryKey(id),
    ...vodsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetMediaVodRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get media vod
 * @return Error
 */
export function setVodsGET2Data(queryClient: QueryClient, updater: (data: Types.GetMediaVodRespApiRespBase | undefined) => Types.GetMediaVodRespApiRespBase, id: number) {
  queryClient.setQueryData(vodsGET2QueryKey(id),
    updater
  );
}

/**
 * Get media vod
 * @return Error
 */
export function setVodsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetMediaVodRespApiRespBase | undefined) => Types.GetMediaVodRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function vodsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/media/vods/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function vodsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'vodsPATCH',
      id as any,
    ]);
}

/**
 * Modify media vod
 * @param body (optional) 
 * @return Error
 */
export function useVodsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModMediaVodRespApiRespBase, unknown, Types.ModMediaVodReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModMediaVodRespApiRespBase, unknown, Types.ModMediaVodReq, TContext> {
  const key = vodsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModMediaVodReq) => Client().vodsPATCH(id, body), {...options, mutationKey: key});
}
  
    
export function vodsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/media/vods/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function vodsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'vodsDELETE',
      id as any,
    ]);
}

/**
 * Delete media vod
 * @return Error
 */
export function useVodsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelMediaVodRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelMediaVodRespApiRespBase, unknown, void, TContext> {
  const key = vodsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().vodsDELETE(id), {...options, mutationKey: key});
}
  
    
export function downloadCsvUrl(pageSize: number | undefined, vodId: number | undefined, title: string | undefined, hostId: number | undefined, hostVideoId: string | undefined, siteSectionIds: number[] | undefined, createdFrom: number | undefined, createdTo: number | undefined, creator: string | undefined, pageNo: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/media/vods/download-csv?";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (vodId === null)
    throw new Error("The parameter 'vodId' cannot be null.");
else if (vodId !== undefined)
    url_ += "VodId=" + encodeURIComponent("" + vodId) + "&";
if (title === null)
    throw new Error("The parameter 'title' cannot be null.");
else if (title !== undefined)
    url_ += "Title=" + encodeURIComponent("" + title) + "&";
if (hostId === null)
    throw new Error("The parameter 'hostId' cannot be null.");
else if (hostId !== undefined)
    url_ += "HostId=" + encodeURIComponent("" + hostId) + "&";
if (hostVideoId === null)
    throw new Error("The parameter 'hostVideoId' cannot be null.");
else if (hostVideoId !== undefined)
    url_ += "HostVideoId=" + encodeURIComponent("" + hostVideoId) + "&";
if (siteSectionIds === null)
    throw new Error("The parameter 'siteSectionIds' cannot be null.");
else if (siteSectionIds !== undefined)
    siteSectionIds && siteSectionIds.forEach(item => { url_ += "SiteSectionIds=" + encodeURIComponent("" + item) + "&"; });
if (createdFrom === null)
    throw new Error("The parameter 'createdFrom' cannot be null.");
else if (createdFrom !== undefined)
    url_ += "CreatedFrom=" + encodeURIComponent("" + createdFrom) + "&";
if (createdTo === null)
    throw new Error("The parameter 'createdTo' cannot be null.");
else if (createdTo !== undefined)
    url_ += "CreatedTo=" + encodeURIComponent("" + createdTo) + "&";
if (creator === null)
    throw new Error("The parameter 'creator' cannot be null.");
else if (creator !== undefined)
    url_ += "Creator=" + encodeURIComponent("" + creator) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let downloadCsvDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __downloadCsv,
};
export function getDownloadCsvDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return downloadCsvDefaultOptions;
};
export function setDownloadCsvDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  downloadCsvDefaultOptions = options;
}

export function downloadCsvQueryKey(dto: DownloadCsvQueryParameters): QueryKey;
export function downloadCsvQueryKey(pageSize: number | undefined, vodId: number | undefined, title: string | undefined, hostId: number | undefined, hostVideoId: string | undefined, siteSectionIds: number[] | undefined, createdFrom: number | undefined, createdTo: number | undefined, creator: string | undefined, pageNo: number | undefined): QueryKey;
export function downloadCsvQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageSize, vodId, title, hostId, hostVideoId, siteSectionIds, createdFrom, createdTo, creator, pageNo,  } = params[0] as DownloadCsvQueryParameters;

    return trimArrayEnd([
        'Client',
        'downloadCsv',
        pageSize as any,
        vodId as any,
        title as any,
        hostId as any,
        hostVideoId as any,
        siteSectionIds as any,
        createdFrom as any,
        createdTo as any,
        creator as any,
        pageNo as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'downloadCsv',
        ...params
      ]);
  }
}
function __downloadCsv(context: QueryFunctionContext) {
  return Client().downloadCsv(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as string | undefined,       context.queryKey[7] as number[] | undefined,       context.queryKey[8] as number | undefined,       context.queryKey[9] as number | undefined,       context.queryKey[10] as string | undefined,       context.queryKey[11] as number | undefined    );
}

export function useDownloadCsvQuery<TSelectData = void, TError = unknown>(dto: DownloadCsvQueryParameters, options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Download media vods csv
 * @param pageSize (optional) Page size
 * @param vodId (optional) Vod id
 * @param title (optional) vod title
 * @param hostId (optional) Host id
 * @param hostVideoId (optional) Host video id
 * @param siteSectionIds (optional) Site section ids
 * @param createdFrom (optional) Created From
 * @param createdTo (optional) Created To
 * @param creator (optional) Creator user name
 * @param pageNo (optional) 
 * @return Success
 */
export function useDownloadCsvQuery<TSelectData = void, TError = unknown>(pageSize: number | undefined, vodId: number | undefined, title: string | undefined, hostId: number | undefined, hostVideoId: string | undefined, siteSectionIds: number[] | undefined, createdFrom: number | undefined, createdTo: number | undefined, creator: string | undefined, pageNo: number | undefined, options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDownloadCsvQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let pageSize: any = undefined;
  let vodId: any = undefined;
  let title: any = undefined;
  let hostId: any = undefined;
  let hostVideoId: any = undefined;
  let siteSectionIds: any = undefined;
  let createdFrom: any = undefined;
  let createdTo: any = undefined;
  let creator: any = undefined;
  let pageNo: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageSize, vodId, title, hostId, hostVideoId, siteSectionIds, createdFrom, createdTo, creator, pageNo,  } = params[0] as DownloadCsvQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageSize, vodId, title, hostId, hostVideoId, siteSectionIds, createdFrom, createdTo, creator, pageNo, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __downloadCsv,
    queryKey: downloadCsvQueryKey(pageSize, vodId, title, hostId, hostVideoId, siteSectionIds, createdFrom, createdTo, creator, pageNo),
    ...downloadCsvDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * Download media vods csv
 * @param pageSize (optional) Page size
 * @param vodId (optional) Vod id
 * @param title (optional) vod title
 * @param hostId (optional) Host id
 * @param hostVideoId (optional) Host video id
 * @param siteSectionIds (optional) Site section ids
 * @param createdFrom (optional) Created From
 * @param createdTo (optional) Created To
 * @param creator (optional) Creator user name
 * @param pageNo (optional) 
 * @return Success
 */
export function setDownloadCsvData(queryClient: QueryClient, updater: (data: void | undefined) => void, pageSize: number | undefined, vodId: number | undefined, title: string | undefined, hostId: number | undefined, hostVideoId: string | undefined, siteSectionIds: number[] | undefined, createdFrom: number | undefined, createdTo: number | undefined, creator: string | undefined, pageNo: number | undefined) {
  queryClient.setQueryData(downloadCsvQueryKey(pageSize, vodId, title, hostId, hostVideoId, siteSectionIds, createdFrom, createdTo, creator, pageNo),
    updater
  );
}

/**
 * Download media vods csv
 * @param pageSize (optional) Page size
 * @param vodId (optional) Vod id
 * @param title (optional) vod title
 * @param hostId (optional) Host id
 * @param hostVideoId (optional) Host video id
 * @param siteSectionIds (optional) Site section ids
 * @param createdFrom (optional) Created From
 * @param createdTo (optional) Created To
 * @param creator (optional) Creator user name
 * @param pageNo (optional) 
 * @return Success
 */
export function setDownloadCsvDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function modesGETUrl(name: string | undefined, abbreviation: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/modes?";
if (name === null)
    throw new Error("The parameter 'name' cannot be null.");
else if (name !== undefined)
    url_ += "Name=" + encodeURIComponent("" + name) + "&";
if (abbreviation === null)
    throw new Error("The parameter 'abbreviation' cannot be null.");
else if (abbreviation !== undefined)
    url_ += "Abbreviation=" + encodeURIComponent("" + abbreviation) + "&";
if (gameId === null)
    throw new Error("The parameter 'gameId' cannot be null.");
else if (gameId !== undefined)
    url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let modesGETDefaultOptions: UseQueryOptions<Types.GetModesRespApiRespBase, unknown, Types.GetModesRespApiRespBase> = {
  queryFn: __modesGET,
};
export function getModesGETDefaultOptions(): UseQueryOptions<Types.GetModesRespApiRespBase, unknown, Types.GetModesRespApiRespBase> {
  return modesGETDefaultOptions;
};
export function setModesGETDefaultOptions(options: UseQueryOptions<Types.GetModesRespApiRespBase, unknown, Types.GetModesRespApiRespBase>) {
  modesGETDefaultOptions = options;
}

export function modesGETQueryKey(dto: ModesGETQueryParameters): QueryKey;
export function modesGETQueryKey(name: string | undefined, abbreviation: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function modesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { name, abbreviation, gameId, pageNo, pageSize,  } = params[0] as ModesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'modesGET',
        name as any,
        abbreviation as any,
        gameId as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'modesGET',
        ...params
      ]);
  }
}
function __modesGET(context: QueryFunctionContext) {
  return Client().modesGET(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as number | undefined    );
}

export function useModesGETQuery<TSelectData = Types.GetModesRespApiRespBase, TError = unknown>(dto: ModesGETQueryParameters, options?: UseQueryOptions<Types.GetModesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get modes by condition
 * @param name (optional) Modes Name
 * @param abbreviation (optional) Modes Abbreviation
 * @param gameId (optional) Modes Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useModesGETQuery<TSelectData = Types.GetModesRespApiRespBase, TError = unknown>(name: string | undefined, abbreviation: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetModesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useModesGETQuery<TSelectData = Types.GetModesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetModesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let name: any = undefined;
  let abbreviation: any = undefined;
  let gameId: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ name, abbreviation, gameId, pageNo, pageSize,  } = params[0] as ModesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [name, abbreviation, gameId, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetModesRespApiRespBase, TError, TSelectData>({
    queryFn: __modesGET,
    queryKey: modesGETQueryKey(name, abbreviation, gameId, pageNo, pageSize),
    ...modesGETDefaultOptions as unknown as UseQueryOptions<Types.GetModesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get modes by condition
 * @param name (optional) Modes Name
 * @param abbreviation (optional) Modes Abbreviation
 * @param gameId (optional) Modes Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setModesGETData(queryClient: QueryClient, updater: (data: Types.GetModesRespApiRespBase | undefined) => Types.GetModesRespApiRespBase, name: string | undefined, abbreviation: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(modesGETQueryKey(name, abbreviation, gameId, pageNo, pageSize),
    updater
  );
}

/**
 * Get modes by condition
 * @param name (optional) Modes Name
 * @param abbreviation (optional) Modes Abbreviation
 * @param gameId (optional) Modes Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setModesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetModesRespApiRespBase | undefined) => Types.GetModesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function modesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/modes";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function modesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'modesPOST',
    ]);
}

/**
 * Add new game mode
 * @param body (optional) Request
 * @return Error
 */
export function useModesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddModeRespApiRespBase, unknown, Types.AddModeReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddModeRespApiRespBase, unknown, Types.AddModeReq, TContext> {
  const key = modesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.AddModeReq) => Client().modesPOST(body), {...options, mutationKey: key});
}
  
    
export function modesGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/modes/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let modesGET2DefaultOptions: UseQueryOptions<Types.GetModeRespApiRespBase, unknown, Types.GetModeRespApiRespBase> = {
  queryFn: __modesGET2,
};
export function getModesGET2DefaultOptions(): UseQueryOptions<Types.GetModeRespApiRespBase, unknown, Types.GetModeRespApiRespBase> {
  return modesGET2DefaultOptions;
};
export function setModesGET2DefaultOptions(options: UseQueryOptions<Types.GetModeRespApiRespBase, unknown, Types.GetModeRespApiRespBase>) {
  modesGET2DefaultOptions = options;
}

export function modesGET2QueryKey(id: number): QueryKey;
export function modesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ModesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'modesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'modesGET2',
        ...params
      ]);
  }
}
function __modesGET2(context: QueryFunctionContext) {
  return Client().modesGET2(
      context.queryKey[2] as number    );
}

export function useModesGET2Query<TSelectData = Types.GetModeRespApiRespBase, TError = unknown>(dto: ModesGET2QueryParameters, options?: UseQueryOptions<Types.GetModeRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get game mode
 * @param id Modes Id
 * @return Error
 */
export function useModesGET2Query<TSelectData = Types.GetModeRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetModeRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useModesGET2Query<TSelectData = Types.GetModeRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetModeRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ModesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetModeRespApiRespBase, TError, TSelectData>({
    queryFn: __modesGET2,
    queryKey: modesGET2QueryKey(id),
    ...modesGET2DefaultOptions as unknown as UseQueryOptions<Types.GetModeRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get game mode
 * @param id Modes Id
 * @return Error
 */
export function setModesGET2Data(queryClient: QueryClient, updater: (data: Types.GetModeRespApiRespBase | undefined) => Types.GetModeRespApiRespBase, id: number) {
  queryClient.setQueryData(modesGET2QueryKey(id),
    updater
  );
}

/**
 * Get game mode
 * @param id Modes Id
 * @return Error
 */
export function setModesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetModeRespApiRespBase | undefined) => Types.GetModeRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function modesPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/modes/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function modesPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'modesPATCH',
      id as any,
    ]);
}

/**
 * Modify game mode
 * @param id game Mode Id
 * @param body (optional) Request
 * @return Error
 */
export function useModesPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModModeRespApiRespBase, unknown, Types.ModModeReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModModeRespApiRespBase, unknown, Types.ModModeReq, TContext> {
  const key = modesPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModModeReq) => Client().modesPATCH(id, body), {...options, mutationKey: key});
}
  
    
export function modesDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/modes/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function modesDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'modesDELETE',
      id as any,
    ]);
}

/**
 * Delete game mode
 * @param id game Mode Id
 * @return Error
 */
export function useModesDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelModeRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelModeRespApiRespBase, unknown, void, TContext> {
  const key = modesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().modesDELETE(id), {...options, mutationKey: key});
}
  
    
export function translationsGET5Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/modes/{id}/translations";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let translationsGET5DefaultOptions: UseQueryOptions<Types.GetModeTranslationsRespApiRespBase, unknown, Types.GetModeTranslationsRespApiRespBase> = {
  queryFn: __translationsGET5,
};
export function getTranslationsGET5DefaultOptions(): UseQueryOptions<Types.GetModeTranslationsRespApiRespBase, unknown, Types.GetModeTranslationsRespApiRespBase> {
  return translationsGET5DefaultOptions;
};
export function setTranslationsGET5DefaultOptions(options: UseQueryOptions<Types.GetModeTranslationsRespApiRespBase, unknown, Types.GetModeTranslationsRespApiRespBase>) {
  translationsGET5DefaultOptions = options;
}

export function translationsGET5QueryKey(id: number): QueryKey;
export function translationsGET5QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as TranslationsGET5QueryParameters;

    return trimArrayEnd([
        'Client',
        'translationsGET5',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'translationsGET5',
        ...params
      ]);
  }
}
function __translationsGET5(context: QueryFunctionContext) {
  return Client().translationsGET5(
      context.queryKey[2] as number    );
}

export function useTranslationsGET5Query<TSelectData = Types.GetModeTranslationsRespApiRespBase, TError = unknown>(dto: TranslationsGET5QueryParameters, options?: UseQueryOptions<Types.GetModeTranslationsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get game mode translations
 * @param id Modes Id
 * @return Error
 */
export function useTranslationsGET5Query<TSelectData = Types.GetModeTranslationsRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetModeTranslationsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTranslationsGET5Query<TSelectData = Types.GetModeTranslationsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetModeTranslationsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as TranslationsGET5QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetModeTranslationsRespApiRespBase, TError, TSelectData>({
    queryFn: __translationsGET5,
    queryKey: translationsGET5QueryKey(id),
    ...translationsGET5DefaultOptions as unknown as UseQueryOptions<Types.GetModeTranslationsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get game mode translations
 * @param id Modes Id
 * @return Error
 */
export function setTranslationsGET5Data(queryClient: QueryClient, updater: (data: Types.GetModeTranslationsRespApiRespBase | undefined) => Types.GetModeTranslationsRespApiRespBase, id: number) {
  queryClient.setQueryData(translationsGET5QueryKey(id),
    updater
  );
}

/**
 * Get game mode translations
 * @param id Modes Id
 * @return Error
 */
export function setTranslationsGET5DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetModeTranslationsRespApiRespBase | undefined) => Types.GetModeTranslationsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function translationsPATCH6Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/modes/{id}/translations";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function translationsPATCH6MutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'translationsPATCH6',
      id as any,
    ]);
}

/**
 * Modify game mode translations
 * @param id game Mode Id
 * @param body (optional) Request
 * @return Error
 */
export function useTranslationsPATCH6Mutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModModeTranslationsRespApiRespBase, unknown, Types.ModModeTranslationsReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModModeTranslationsRespApiRespBase, unknown, Types.ModModeTranslationsReq, TContext> {
  const key = translationsPATCH6MutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModModeTranslationsReq) => Client().translationsPATCH6(id, body), {...options, mutationKey: key});
}
  
    
export function messagingNotificationTemplatesGETUrl(frontendId: number | undefined, notificationTemplateType: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/messaging-notification-templates?";
if (frontendId === null)
    throw new Error("The parameter 'frontendId' cannot be null.");
else if (frontendId !== undefined)
    url_ += "FrontendId=" + encodeURIComponent("" + frontendId) + "&";
if (notificationTemplateType === null)
    throw new Error("The parameter 'notificationTemplateType' cannot be null.");
else if (notificationTemplateType !== undefined)
    url_ += "NotificationTemplateType=" + encodeURIComponent("" + notificationTemplateType) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let messagingNotificationTemplatesGETDefaultOptions: UseQueryOptions<Types.GetNotificationTemplatesRespApiRespBase, unknown, Types.GetNotificationTemplatesRespApiRespBase> = {
  queryFn: __messagingNotificationTemplatesGET,
};
export function getMessagingNotificationTemplatesGETDefaultOptions(): UseQueryOptions<Types.GetNotificationTemplatesRespApiRespBase, unknown, Types.GetNotificationTemplatesRespApiRespBase> {
  return messagingNotificationTemplatesGETDefaultOptions;
};
export function setMessagingNotificationTemplatesGETDefaultOptions(options: UseQueryOptions<Types.GetNotificationTemplatesRespApiRespBase, unknown, Types.GetNotificationTemplatesRespApiRespBase>) {
  messagingNotificationTemplatesGETDefaultOptions = options;
}

export function messagingNotificationTemplatesGETQueryKey(dto: MessagingNotificationTemplatesGETQueryParameters): QueryKey;
export function messagingNotificationTemplatesGETQueryKey(frontendId: number | undefined, notificationTemplateType: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function messagingNotificationTemplatesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { frontendId, notificationTemplateType, pageNo, pageSize,  } = params[0] as MessagingNotificationTemplatesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'messagingNotificationTemplatesGET',
        frontendId as any,
        notificationTemplateType as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'messagingNotificationTemplatesGET',
        ...params
      ]);
  }
}
function __messagingNotificationTemplatesGET(context: QueryFunctionContext) {
  return Client().messagingNotificationTemplatesGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as number | undefined    );
}

export function useMessagingNotificationTemplatesGETQuery<TSelectData = Types.GetNotificationTemplatesRespApiRespBase, TError = unknown>(dto: MessagingNotificationTemplatesGETQueryParameters, options?: UseQueryOptions<Types.GetNotificationTemplatesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get Notification Templates
 * @param frontendId (optional) Frontend id
null: All
 * @param notificationTemplateType (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useMessagingNotificationTemplatesGETQuery<TSelectData = Types.GetNotificationTemplatesRespApiRespBase, TError = unknown>(frontendId: number | undefined, notificationTemplateType: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetNotificationTemplatesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMessagingNotificationTemplatesGETQuery<TSelectData = Types.GetNotificationTemplatesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetNotificationTemplatesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let frontendId: any = undefined;
  let notificationTemplateType: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ frontendId, notificationTemplateType, pageNo, pageSize,  } = params[0] as MessagingNotificationTemplatesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [frontendId, notificationTemplateType, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetNotificationTemplatesRespApiRespBase, TError, TSelectData>({
    queryFn: __messagingNotificationTemplatesGET,
    queryKey: messagingNotificationTemplatesGETQueryKey(frontendId, notificationTemplateType, pageNo, pageSize),
    ...messagingNotificationTemplatesGETDefaultOptions as unknown as UseQueryOptions<Types.GetNotificationTemplatesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Notification Templates
 * @param frontendId (optional) Frontend id
null: All
 * @param notificationTemplateType (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setMessagingNotificationTemplatesGETData(queryClient: QueryClient, updater: (data: Types.GetNotificationTemplatesRespApiRespBase | undefined) => Types.GetNotificationTemplatesRespApiRespBase, frontendId: number | undefined, notificationTemplateType: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(messagingNotificationTemplatesGETQueryKey(frontendId, notificationTemplateType, pageNo, pageSize),
    updater
  );
}

/**
 * Get Notification Templates
 * @param frontendId (optional) Frontend id
null: All
 * @param notificationTemplateType (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setMessagingNotificationTemplatesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetNotificationTemplatesRespApiRespBase | undefined) => Types.GetNotificationTemplatesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function messagingNotificationTemplatesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/messaging-notification-templates";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function messagingNotificationTemplatesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'messagingNotificationTemplatesPOST',
    ]);
}

/**
 * Add Notification Template
 * @param body (optional) 
 * @return Error
 */
export function useMessagingNotificationTemplatesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddNotificationTemplateRespApiRespBase, unknown, Types.AddNotificationTemplateReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddNotificationTemplateRespApiRespBase, unknown, Types.AddNotificationTemplateReq, TContext> {
  const key = messagingNotificationTemplatesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.AddNotificationTemplateReq) => Client().messagingNotificationTemplatesPOST(body), {...options, mutationKey: key});
}
  
    
export function messagingNotificationTemplatesGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/messaging-notification-templates/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let messagingNotificationTemplatesGET2DefaultOptions: UseQueryOptions<Types.GetNotificationTemplateRespApiRespBase, unknown, Types.GetNotificationTemplateRespApiRespBase> = {
  queryFn: __messagingNotificationTemplatesGET2,
};
export function getMessagingNotificationTemplatesGET2DefaultOptions(): UseQueryOptions<Types.GetNotificationTemplateRespApiRespBase, unknown, Types.GetNotificationTemplateRespApiRespBase> {
  return messagingNotificationTemplatesGET2DefaultOptions;
};
export function setMessagingNotificationTemplatesGET2DefaultOptions(options: UseQueryOptions<Types.GetNotificationTemplateRespApiRespBase, unknown, Types.GetNotificationTemplateRespApiRespBase>) {
  messagingNotificationTemplatesGET2DefaultOptions = options;
}

export function messagingNotificationTemplatesGET2QueryKey(id: number): QueryKey;
export function messagingNotificationTemplatesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as MessagingNotificationTemplatesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'messagingNotificationTemplatesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'messagingNotificationTemplatesGET2',
        ...params
      ]);
  }
}
function __messagingNotificationTemplatesGET2(context: QueryFunctionContext) {
  return Client().messagingNotificationTemplatesGET2(
      context.queryKey[2] as number    );
}

export function useMessagingNotificationTemplatesGET2Query<TSelectData = Types.GetNotificationTemplateRespApiRespBase, TError = unknown>(dto: MessagingNotificationTemplatesGET2QueryParameters, options?: UseQueryOptions<Types.GetNotificationTemplateRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get Notification Template
 * @return Error
 */
export function useMessagingNotificationTemplatesGET2Query<TSelectData = Types.GetNotificationTemplateRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetNotificationTemplateRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMessagingNotificationTemplatesGET2Query<TSelectData = Types.GetNotificationTemplateRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetNotificationTemplateRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as MessagingNotificationTemplatesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetNotificationTemplateRespApiRespBase, TError, TSelectData>({
    queryFn: __messagingNotificationTemplatesGET2,
    queryKey: messagingNotificationTemplatesGET2QueryKey(id),
    ...messagingNotificationTemplatesGET2DefaultOptions as unknown as UseQueryOptions<Types.GetNotificationTemplateRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Notification Template
 * @return Error
 */
export function setMessagingNotificationTemplatesGET2Data(queryClient: QueryClient, updater: (data: Types.GetNotificationTemplateRespApiRespBase | undefined) => Types.GetNotificationTemplateRespApiRespBase, id: number) {
  queryClient.setQueryData(messagingNotificationTemplatesGET2QueryKey(id),
    updater
  );
}

/**
 * Get Notification Template
 * @return Error
 */
export function setMessagingNotificationTemplatesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetNotificationTemplateRespApiRespBase | undefined) => Types.GetNotificationTemplateRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function messagingNotificationTemplatesPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/messaging-notification-templates/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function messagingNotificationTemplatesPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'messagingNotificationTemplatesPATCH',
      id as any,
    ]);
}

/**
 * Modify Notification Template
 * @param body (optional) 
 * @return Error
 */
export function useMessagingNotificationTemplatesPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModNotificationTemplateRespApiRespBase, unknown, Types.ModNotificationTemplateReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModNotificationTemplateRespApiRespBase, unknown, Types.ModNotificationTemplateReq, TContext> {
  const key = messagingNotificationTemplatesPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModNotificationTemplateReq) => Client().messagingNotificationTemplatesPATCH(id, body), {...options, mutationKey: key});
}
  
    
export function messagingNotificationTemplatesDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/messaging-notification-templates/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function messagingNotificationTemplatesDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'messagingNotificationTemplatesDELETE',
      id as any,
    ]);
}

/**
 * Delete Notification Template
 * @return Error
 */
export function useMessagingNotificationTemplatesDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelNotificationTemplateRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelNotificationTemplateRespApiRespBase, unknown, void, TContext> {
  const key = messagingNotificationTemplatesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().messagingNotificationTemplatesDELETE(id), {...options, mutationKey: key});
}
  
    
export function messagingOnesignalAppsGETUrl(pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/messaging-onesignal-apps?";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let messagingOnesignalAppsGETDefaultOptions: UseQueryOptions<Types.GetOneSignalAppsRespApiRespBase, unknown, Types.GetOneSignalAppsRespApiRespBase> = {
  queryFn: __messagingOnesignalAppsGET,
};
export function getMessagingOnesignalAppsGETDefaultOptions(): UseQueryOptions<Types.GetOneSignalAppsRespApiRespBase, unknown, Types.GetOneSignalAppsRespApiRespBase> {
  return messagingOnesignalAppsGETDefaultOptions;
};
export function setMessagingOnesignalAppsGETDefaultOptions(options: UseQueryOptions<Types.GetOneSignalAppsRespApiRespBase, unknown, Types.GetOneSignalAppsRespApiRespBase>) {
  messagingOnesignalAppsGETDefaultOptions = options;
}

export function messagingOnesignalAppsGETQueryKey(dto: MessagingOnesignalAppsGETQueryParameters): QueryKey;
export function messagingOnesignalAppsGETQueryKey(pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function messagingOnesignalAppsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNo, pageSize,  } = params[0] as MessagingOnesignalAppsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'messagingOnesignalAppsGET',
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'messagingOnesignalAppsGET',
        ...params
      ]);
  }
}
function __messagingOnesignalAppsGET(context: QueryFunctionContext) {
  return Client().messagingOnesignalAppsGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined    );
}

export function useMessagingOnesignalAppsGETQuery<TSelectData = Types.GetOneSignalAppsRespApiRespBase, TError = unknown>(dto: MessagingOnesignalAppsGETQueryParameters, options?: UseQueryOptions<Types.GetOneSignalAppsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get One Signal Apps
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useMessagingOnesignalAppsGETQuery<TSelectData = Types.GetOneSignalAppsRespApiRespBase, TError = unknown>(pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetOneSignalAppsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMessagingOnesignalAppsGETQuery<TSelectData = Types.GetOneSignalAppsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetOneSignalAppsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNo, pageSize,  } = params[0] as MessagingOnesignalAppsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetOneSignalAppsRespApiRespBase, TError, TSelectData>({
    queryFn: __messagingOnesignalAppsGET,
    queryKey: messagingOnesignalAppsGETQueryKey(pageNo, pageSize),
    ...messagingOnesignalAppsGETDefaultOptions as unknown as UseQueryOptions<Types.GetOneSignalAppsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get One Signal Apps
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setMessagingOnesignalAppsGETData(queryClient: QueryClient, updater: (data: Types.GetOneSignalAppsRespApiRespBase | undefined) => Types.GetOneSignalAppsRespApiRespBase, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(messagingOnesignalAppsGETQueryKey(pageNo, pageSize),
    updater
  );
}

/**
 * Get One Signal Apps
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setMessagingOnesignalAppsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetOneSignalAppsRespApiRespBase | undefined) => Types.GetOneSignalAppsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function messagingOnesignalAppsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/messaging-onesignal-apps";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function messagingOnesignalAppsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'messagingOnesignalAppsPOST',
    ]);
}

/**
 * Add One Signal App
 * @param body (optional) 
 * @return Error
 */
export function useMessagingOnesignalAppsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddOneSignalAppRespApiRespBase, unknown, Types.AddOneSignalAppReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddOneSignalAppRespApiRespBase, unknown, Types.AddOneSignalAppReq, TContext> {
  const key = messagingOnesignalAppsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.AddOneSignalAppReq) => Client().messagingOnesignalAppsPOST(body), {...options, mutationKey: key});
}
  
    
export function messagingOnesignalAppsGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/messaging-onesignal-apps/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let messagingOnesignalAppsGET2DefaultOptions: UseQueryOptions<Types.GetOneSignalAppRespApiRespBase, unknown, Types.GetOneSignalAppRespApiRespBase> = {
  queryFn: __messagingOnesignalAppsGET2,
};
export function getMessagingOnesignalAppsGET2DefaultOptions(): UseQueryOptions<Types.GetOneSignalAppRespApiRespBase, unknown, Types.GetOneSignalAppRespApiRespBase> {
  return messagingOnesignalAppsGET2DefaultOptions;
};
export function setMessagingOnesignalAppsGET2DefaultOptions(options: UseQueryOptions<Types.GetOneSignalAppRespApiRespBase, unknown, Types.GetOneSignalAppRespApiRespBase>) {
  messagingOnesignalAppsGET2DefaultOptions = options;
}

export function messagingOnesignalAppsGET2QueryKey(id: number): QueryKey;
export function messagingOnesignalAppsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as MessagingOnesignalAppsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'messagingOnesignalAppsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'messagingOnesignalAppsGET2',
        ...params
      ]);
  }
}
function __messagingOnesignalAppsGET2(context: QueryFunctionContext) {
  return Client().messagingOnesignalAppsGET2(
      context.queryKey[2] as number    );
}

export function useMessagingOnesignalAppsGET2Query<TSelectData = Types.GetOneSignalAppRespApiRespBase, TError = unknown>(dto: MessagingOnesignalAppsGET2QueryParameters, options?: UseQueryOptions<Types.GetOneSignalAppRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get One Signal App
 * @return Error
 */
export function useMessagingOnesignalAppsGET2Query<TSelectData = Types.GetOneSignalAppRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetOneSignalAppRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMessagingOnesignalAppsGET2Query<TSelectData = Types.GetOneSignalAppRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetOneSignalAppRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as MessagingOnesignalAppsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetOneSignalAppRespApiRespBase, TError, TSelectData>({
    queryFn: __messagingOnesignalAppsGET2,
    queryKey: messagingOnesignalAppsGET2QueryKey(id),
    ...messagingOnesignalAppsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetOneSignalAppRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get One Signal App
 * @return Error
 */
export function setMessagingOnesignalAppsGET2Data(queryClient: QueryClient, updater: (data: Types.GetOneSignalAppRespApiRespBase | undefined) => Types.GetOneSignalAppRespApiRespBase, id: number) {
  queryClient.setQueryData(messagingOnesignalAppsGET2QueryKey(id),
    updater
  );
}

/**
 * Get One Signal App
 * @return Error
 */
export function setMessagingOnesignalAppsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetOneSignalAppRespApiRespBase | undefined) => Types.GetOneSignalAppRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function messagingOnesignalAppsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/messaging-onesignal-apps/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function messagingOnesignalAppsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'messagingOnesignalAppsPATCH',
      id as any,
    ]);
}

/**
 * Modify One Signal App
 * @param body (optional) 
 * @return Error
 */
export function useMessagingOnesignalAppsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModOneSignalAppRespApiRespBase, unknown, Types.ModOneSignalAppReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModOneSignalAppRespApiRespBase, unknown, Types.ModOneSignalAppReq, TContext> {
  const key = messagingOnesignalAppsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModOneSignalAppReq) => Client().messagingOnesignalAppsPATCH(id, body), {...options, mutationKey: key});
}
  
    
export function messagingOnesignalAppsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/messaging-onesignal-apps/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function messagingOnesignalAppsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'messagingOnesignalAppsDELETE',
      id as any,
    ]);
}

/**
 * Delete One Signal App
 * @return Error
 */
export function useMessagingOnesignalAppsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelOneSignalAppRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelOneSignalAppRespApiRespBase, unknown, void, TContext> {
  const key = messagingOnesignalAppsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().messagingOnesignalAppsDELETE(id), {...options, mutationKey: key});
}
  
    
export function statesUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/options/states";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let statesDefaultOptions: UseQueryOptions<Types.GetStateOptionsRespApiRespBase, unknown, Types.GetStateOptionsRespApiRespBase> = {
  queryFn: __states,
};
export function getStatesDefaultOptions(): UseQueryOptions<Types.GetStateOptionsRespApiRespBase, unknown, Types.GetStateOptionsRespApiRespBase> {
  return statesDefaultOptions;
};
export function setStatesDefaultOptions(options: UseQueryOptions<Types.GetStateOptionsRespApiRespBase, unknown, Types.GetStateOptionsRespApiRespBase>) {
  statesDefaultOptions = options;
}

export function statesQueryKey(): QueryKey;
export function statesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'states',
    ]);
}
function __states() {
  return Client().states(
    );
}

/**
 * Get state options
 * @return Error
 */
export function useStatesQuery<TSelectData = Types.GetStateOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetStateOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useStatesQuery<TSelectData = Types.GetStateOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetStateOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetStateOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __states,
    queryKey: statesQueryKey(),
    ...statesDefaultOptions as unknown as UseQueryOptions<Types.GetStateOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get state options
 * @return Error
 */
export function setStatesData(queryClient: QueryClient, updater: (data: Types.GetStateOptionsRespApiRespBase | undefined) => Types.GetStateOptionsRespApiRespBase, ) {
  queryClient.setQueryData(statesQueryKey(),
    updater
  );
}

/**
 * Get state options
 * @return Error
 */
export function setStatesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetStateOptionsRespApiRespBase | undefined) => Types.GetStateOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function contactTypesUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/options/contact-types";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let contactTypesDefaultOptions: UseQueryOptions<Types.GetContactTypesRespApiRespBase, unknown, Types.GetContactTypesRespApiRespBase> = {
  queryFn: __contactTypes,
};
export function getContactTypesDefaultOptions(): UseQueryOptions<Types.GetContactTypesRespApiRespBase, unknown, Types.GetContactTypesRespApiRespBase> {
  return contactTypesDefaultOptions;
};
export function setContactTypesDefaultOptions(options: UseQueryOptions<Types.GetContactTypesRespApiRespBase, unknown, Types.GetContactTypesRespApiRespBase>) {
  contactTypesDefaultOptions = options;
}

export function contactTypesQueryKey(): QueryKey;
export function contactTypesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'contactTypes',
    ]);
}
function __contactTypes() {
  return Client().contactTypes(
    );
}

/**
 * Get contact types
 * @return Error
 */
export function useContactTypesQuery<TSelectData = Types.GetContactTypesRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetContactTypesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useContactTypesQuery<TSelectData = Types.GetContactTypesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetContactTypesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetContactTypesRespApiRespBase, TError, TSelectData>({
    queryFn: __contactTypes,
    queryKey: contactTypesQueryKey(),
    ...contactTypesDefaultOptions as unknown as UseQueryOptions<Types.GetContactTypesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get contact types
 * @return Error
 */
export function setContactTypesData(queryClient: QueryClient, updater: (data: Types.GetContactTypesRespApiRespBase | undefined) => Types.GetContactTypesRespApiRespBase, ) {
  queryClient.setQueryData(contactTypesQueryKey(),
    updater
  );
}

/**
 * Get contact types
 * @return Error
 */
export function setContactTypesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetContactTypesRespApiRespBase | undefined) => Types.GetContactTypesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function frontendsUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/options/frontends";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let frontendsDefaultOptions: UseQueryOptions<Types.GetFrontendOptionsRespApiRespBase, unknown, Types.GetFrontendOptionsRespApiRespBase> = {
  queryFn: __frontends,
};
export function getFrontendsDefaultOptions(): UseQueryOptions<Types.GetFrontendOptionsRespApiRespBase, unknown, Types.GetFrontendOptionsRespApiRespBase> {
  return frontendsDefaultOptions;
};
export function setFrontendsDefaultOptions(options: UseQueryOptions<Types.GetFrontendOptionsRespApiRespBase, unknown, Types.GetFrontendOptionsRespApiRespBase>) {
  frontendsDefaultOptions = options;
}

export function frontendsQueryKey(): QueryKey;
export function frontendsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'frontends',
    ]);
}
function __frontends() {
  return Client().frontends(
    );
}

/**
 * Get frontend options
 * @return Error
 */
export function useFrontendsQuery<TSelectData = Types.GetFrontendOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetFrontendOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFrontendsQuery<TSelectData = Types.GetFrontendOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFrontendOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFrontendOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __frontends,
    queryKey: frontendsQueryKey(),
    ...frontendsDefaultOptions as unknown as UseQueryOptions<Types.GetFrontendOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get frontend options
 * @return Error
 */
export function setFrontendsData(queryClient: QueryClient, updater: (data: Types.GetFrontendOptionsRespApiRespBase | undefined) => Types.GetFrontendOptionsRespApiRespBase, ) {
  queryClient.setQueryData(frontendsQueryKey(),
    updater
  );
}

/**
 * Get frontend options
 * @return Error
 */
export function setFrontendsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFrontendOptionsRespApiRespBase | undefined) => Types.GetFrontendOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function frontendsByUserUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/options/frontends-by-user";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let frontendsByUserDefaultOptions: UseQueryOptions<Types.GetFrontendOptionsRespApiRespBase, unknown, Types.GetFrontendOptionsRespApiRespBase> = {
  queryFn: __frontendsByUser,
};
export function getFrontendsByUserDefaultOptions(): UseQueryOptions<Types.GetFrontendOptionsRespApiRespBase, unknown, Types.GetFrontendOptionsRespApiRespBase> {
  return frontendsByUserDefaultOptions;
};
export function setFrontendsByUserDefaultOptions(options: UseQueryOptions<Types.GetFrontendOptionsRespApiRespBase, unknown, Types.GetFrontendOptionsRespApiRespBase>) {
  frontendsByUserDefaultOptions = options;
}

export function frontendsByUserQueryKey(): QueryKey;
export function frontendsByUserQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'frontendsByUser',
    ]);
}
function __frontendsByUser() {
  return Client().frontendsByUser(
    );
}

/**
 * Get frontend options by user
 * @return Error
 */
export function useFrontendsByUserQuery<TSelectData = Types.GetFrontendOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetFrontendOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFrontendsByUserQuery<TSelectData = Types.GetFrontendOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFrontendOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFrontendOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __frontendsByUser,
    queryKey: frontendsByUserQueryKey(),
    ...frontendsByUserDefaultOptions as unknown as UseQueryOptions<Types.GetFrontendOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get frontend options by user
 * @return Error
 */
export function setFrontendsByUserData(queryClient: QueryClient, updater: (data: Types.GetFrontendOptionsRespApiRespBase | undefined) => Types.GetFrontendOptionsRespApiRespBase, ) {
  queryClient.setQueryData(frontendsByUserQueryKey(),
    updater
  );
}

/**
 * Get frontend options by user
 * @return Error
 */
export function setFrontendsByUserDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFrontendOptionsRespApiRespBase | undefined) => Types.GetFrontendOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function localesUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/options/locales";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let localesDefaultOptions: UseQueryOptions<Types.GetLocaleOptionsRespApiRespBase, unknown, Types.GetLocaleOptionsRespApiRespBase> = {
  queryFn: __locales,
};
export function getLocalesDefaultOptions(): UseQueryOptions<Types.GetLocaleOptionsRespApiRespBase, unknown, Types.GetLocaleOptionsRespApiRespBase> {
  return localesDefaultOptions;
};
export function setLocalesDefaultOptions(options: UseQueryOptions<Types.GetLocaleOptionsRespApiRespBase, unknown, Types.GetLocaleOptionsRespApiRespBase>) {
  localesDefaultOptions = options;
}

export function localesQueryKey(): QueryKey;
export function localesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'locales',
    ]);
}
function __locales() {
  return Client().locales(
    );
}

/**
 * Get locale options
 * @return Error
 */
export function useLocalesQuery<TSelectData = Types.GetLocaleOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetLocaleOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useLocalesQuery<TSelectData = Types.GetLocaleOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetLocaleOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetLocaleOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __locales,
    queryKey: localesQueryKey(),
    ...localesDefaultOptions as unknown as UseQueryOptions<Types.GetLocaleOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get locale options
 * @return Error
 */
export function setLocalesData(queryClient: QueryClient, updater: (data: Types.GetLocaleOptionsRespApiRespBase | undefined) => Types.GetLocaleOptionsRespApiRespBase, ) {
  queryClient.setQueryData(localesQueryKey(),
    updater
  );
}

/**
 * Get locale options
 * @return Error
 */
export function setLocalesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetLocaleOptionsRespApiRespBase | undefined) => Types.GetLocaleOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function frontendLocalesUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/options/frontend-locales";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let frontendLocalesDefaultOptions: UseQueryOptions<Types.GetFrontendLocaleOptionsRespApiRespBase, unknown, Types.GetFrontendLocaleOptionsRespApiRespBase> = {
  queryFn: __frontendLocales,
};
export function getFrontendLocalesDefaultOptions(): UseQueryOptions<Types.GetFrontendLocaleOptionsRespApiRespBase, unknown, Types.GetFrontendLocaleOptionsRespApiRespBase> {
  return frontendLocalesDefaultOptions;
};
export function setFrontendLocalesDefaultOptions(options: UseQueryOptions<Types.GetFrontendLocaleOptionsRespApiRespBase, unknown, Types.GetFrontendLocaleOptionsRespApiRespBase>) {
  frontendLocalesDefaultOptions = options;
}

export function frontendLocalesQueryKey(): QueryKey;
export function frontendLocalesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'frontendLocales',
    ]);
}
function __frontendLocales() {
  return Client().frontendLocales(
    );
}

/**
 * Get frontend locale options
 * @return Error
 */
export function useFrontendLocalesQuery<TSelectData = Types.GetFrontendLocaleOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetFrontendLocaleOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFrontendLocalesQuery<TSelectData = Types.GetFrontendLocaleOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFrontendLocaleOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFrontendLocaleOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __frontendLocales,
    queryKey: frontendLocalesQueryKey(),
    ...frontendLocalesDefaultOptions as unknown as UseQueryOptions<Types.GetFrontendLocaleOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get frontend locale options
 * @return Error
 */
export function setFrontendLocalesData(queryClient: QueryClient, updater: (data: Types.GetFrontendLocaleOptionsRespApiRespBase | undefined) => Types.GetFrontendLocaleOptionsRespApiRespBase, ) {
  queryClient.setQueryData(frontendLocalesQueryKey(),
    updater
  );
}

/**
 * Get frontend locale options
 * @return Error
 */
export function setFrontendLocalesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFrontendLocaleOptionsRespApiRespBase | undefined) => Types.GetFrontendLocaleOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function siteSectionsGETUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/options/site-sections";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let siteSectionsGETDefaultOptions: UseQueryOptions<Types.GetSiteSectionsOptionsRespApiRespBase, unknown, Types.GetSiteSectionsOptionsRespApiRespBase> = {
  queryFn: __siteSectionsGET,
};
export function getSiteSectionsGETDefaultOptions(): UseQueryOptions<Types.GetSiteSectionsOptionsRespApiRespBase, unknown, Types.GetSiteSectionsOptionsRespApiRespBase> {
  return siteSectionsGETDefaultOptions;
};
export function setSiteSectionsGETDefaultOptions(options: UseQueryOptions<Types.GetSiteSectionsOptionsRespApiRespBase, unknown, Types.GetSiteSectionsOptionsRespApiRespBase>) {
  siteSectionsGETDefaultOptions = options;
}

export function siteSectionsGETQueryKey(): QueryKey;
export function siteSectionsGETQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'siteSectionsGET',
    ]);
}
function __siteSectionsGET() {
  return Client().siteSectionsGET(
    );
}

/**
 * Get site section options
 * @return Error
 */
export function useSiteSectionsGETQuery<TSelectData = Types.GetSiteSectionsOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetSiteSectionsOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSiteSectionsGETQuery<TSelectData = Types.GetSiteSectionsOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetSiteSectionsOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetSiteSectionsOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __siteSectionsGET,
    queryKey: siteSectionsGETQueryKey(),
    ...siteSectionsGETDefaultOptions as unknown as UseQueryOptions<Types.GetSiteSectionsOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get site section options
 * @return Error
 */
export function setSiteSectionsGETData(queryClient: QueryClient, updater: (data: Types.GetSiteSectionsOptionsRespApiRespBase | undefined) => Types.GetSiteSectionsOptionsRespApiRespBase, ) {
  queryClient.setQueryData(siteSectionsGETQueryKey(),
    updater
  );
}

/**
 * Get site section options
 * @return Error
 */
export function setSiteSectionsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetSiteSectionsOptionsRespApiRespBase | undefined) => Types.GetSiteSectionsOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function countriesUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/options/countries";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let countriesDefaultOptions: UseQueryOptions<Types.GetCountryOptionsRespApiRespBase, unknown, Types.GetCountryOptionsRespApiRespBase> = {
  queryFn: __countries,
};
export function getCountriesDefaultOptions(): UseQueryOptions<Types.GetCountryOptionsRespApiRespBase, unknown, Types.GetCountryOptionsRespApiRespBase> {
  return countriesDefaultOptions;
};
export function setCountriesDefaultOptions(options: UseQueryOptions<Types.GetCountryOptionsRespApiRespBase, unknown, Types.GetCountryOptionsRespApiRespBase>) {
  countriesDefaultOptions = options;
}

export function countriesQueryKey(): QueryKey;
export function countriesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'countries',
    ]);
}
function __countries() {
  return Client().countries(
    );
}

/**
 * Get country options
 * @return Error
 */
export function useCountriesQuery<TSelectData = Types.GetCountryOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetCountryOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useCountriesQuery<TSelectData = Types.GetCountryOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetCountryOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetCountryOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __countries,
    queryKey: countriesQueryKey(),
    ...countriesDefaultOptions as unknown as UseQueryOptions<Types.GetCountryOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get country options
 * @return Error
 */
export function setCountriesData(queryClient: QueryClient, updater: (data: Types.GetCountryOptionsRespApiRespBase | undefined) => Types.GetCountryOptionsRespApiRespBase, ) {
  queryClient.setQueryData(countriesQueryKey(),
    updater
  );
}

/**
 * Get country options
 * @return Error
 */
export function setCountriesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetCountryOptionsRespApiRespBase | undefined) => Types.GetCountryOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function userTypesUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/options/user-types";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let userTypesDefaultOptions: UseQueryOptions<Types.GetUserTypeOptionsRespApiRespBase, unknown, Types.GetUserTypeOptionsRespApiRespBase> = {
  queryFn: __userTypes,
};
export function getUserTypesDefaultOptions(): UseQueryOptions<Types.GetUserTypeOptionsRespApiRespBase, unknown, Types.GetUserTypeOptionsRespApiRespBase> {
  return userTypesDefaultOptions;
};
export function setUserTypesDefaultOptions(options: UseQueryOptions<Types.GetUserTypeOptionsRespApiRespBase, unknown, Types.GetUserTypeOptionsRespApiRespBase>) {
  userTypesDefaultOptions = options;
}

export function userTypesQueryKey(): QueryKey;
export function userTypesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'userTypes',
    ]);
}
function __userTypes() {
  return Client().userTypes(
    );
}

/**
 * Get user type options
 * @return Error
 */
export function useUserTypesQuery<TSelectData = Types.GetUserTypeOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetUserTypeOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUserTypesQuery<TSelectData = Types.GetUserTypeOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetUserTypeOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetUserTypeOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __userTypes,
    queryKey: userTypesQueryKey(),
    ...userTypesDefaultOptions as unknown as UseQueryOptions<Types.GetUserTypeOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get user type options
 * @return Error
 */
export function setUserTypesData(queryClient: QueryClient, updater: (data: Types.GetUserTypeOptionsRespApiRespBase | undefined) => Types.GetUserTypeOptionsRespApiRespBase, ) {
  queryClient.setQueryData(userTypesQueryKey(),
    updater
  );
}

/**
 * Get user type options
 * @return Error
 */
export function setUserTypesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetUserTypeOptionsRespApiRespBase | undefined) => Types.GetUserTypeOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gendersUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/options/genders";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let gendersDefaultOptions: UseQueryOptions<Types.GetGenderOptionsRespApiRespBase, unknown, Types.GetGenderOptionsRespApiRespBase> = {
  queryFn: __genders,
};
export function getGendersDefaultOptions(): UseQueryOptions<Types.GetGenderOptionsRespApiRespBase, unknown, Types.GetGenderOptionsRespApiRespBase> {
  return gendersDefaultOptions;
};
export function setGendersDefaultOptions(options: UseQueryOptions<Types.GetGenderOptionsRespApiRespBase, unknown, Types.GetGenderOptionsRespApiRespBase>) {
  gendersDefaultOptions = options;
}

export function gendersQueryKey(): QueryKey;
export function gendersQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'genders',
    ]);
}
function __genders() {
  return Client().genders(
    );
}

/**
 * Get gender options
 * @return Error
 */
export function useGendersQuery<TSelectData = Types.GetGenderOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetGenderOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGendersQuery<TSelectData = Types.GetGenderOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGenderOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGenderOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __genders,
    queryKey: gendersQueryKey(),
    ...gendersDefaultOptions as unknown as UseQueryOptions<Types.GetGenderOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get gender options
 * @return Error
 */
export function setGendersData(queryClient: QueryClient, updater: (data: Types.GetGenderOptionsRespApiRespBase | undefined) => Types.GetGenderOptionsRespApiRespBase, ) {
  queryClient.setQueryData(gendersQueryKey(),
    updater
  );
}

/**
 * Get gender options
 * @return Error
 */
export function setGendersDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGenderOptionsRespApiRespBase | undefined) => Types.GetGenderOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function proxyUrl(url: string | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/options/proxy?";
if (url === null)
    throw new Error("The parameter 'url' cannot be null.");
else if (url !== undefined)
    url_ += "url=" + encodeURIComponent("" + url) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let proxyDefaultOptions: UseQueryOptions<Types.GetGgCodeInfoRespApiRespBase, unknown, Types.GetGgCodeInfoRespApiRespBase> = {
  queryFn: __proxy,
};
export function getProxyDefaultOptions(): UseQueryOptions<Types.GetGgCodeInfoRespApiRespBase, unknown, Types.GetGgCodeInfoRespApiRespBase> {
  return proxyDefaultOptions;
};
export function setProxyDefaultOptions(options: UseQueryOptions<Types.GetGgCodeInfoRespApiRespBase, unknown, Types.GetGgCodeInfoRespApiRespBase>) {
  proxyDefaultOptions = options;
}

export function proxyQueryKey(url: string | undefined): QueryKey;
export function proxyQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { url,  } = params[0] as ProxyQueryParameters;

    return trimArrayEnd([
        'Client',
        'proxy',
        url as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'proxy',
        ...params
      ]);
  }
}
function __proxy(context: QueryFunctionContext) {
  return Client().proxy(
      context.queryKey[2] as string | undefined    );
}

export function useProxyQuery<TSelectData = Types.GetGgCodeInfoRespApiRespBase, TError = unknown>(dto: ProxyQueryParameters, options?: UseQueryOptions<Types.GetGgCodeInfoRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get GG Code Info
 * @param url (optional) 
 * @return Error
 */
export function useProxyQuery<TSelectData = Types.GetGgCodeInfoRespApiRespBase, TError = unknown>(url: string | undefined, options?: UseQueryOptions<Types.GetGgCodeInfoRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useProxyQuery<TSelectData = Types.GetGgCodeInfoRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGgCodeInfoRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let url: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ url,  } = params[0] as ProxyQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [url, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGgCodeInfoRespApiRespBase, TError, TSelectData>({
    queryFn: __proxy,
    queryKey: proxyQueryKey(url),
    ...proxyDefaultOptions as unknown as UseQueryOptions<Types.GetGgCodeInfoRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get GG Code Info
 * @param url (optional) 
 * @return Error
 */
export function setProxyData(queryClient: QueryClient, updater: (data: Types.GetGgCodeInfoRespApiRespBase | undefined) => Types.GetGgCodeInfoRespApiRespBase, url: string | undefined) {
  queryClient.setQueryData(proxyQueryKey(url),
    updater
  );
}

/**
 * Get GG Code Info
 * @param url (optional) 
 * @return Error
 */
export function setProxyDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGgCodeInfoRespApiRespBase | undefined) => Types.GetGgCodeInfoRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function notificationTypesUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/options/notification-types";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let notificationTypesDefaultOptions: UseQueryOptions<Types.GetNotificationTypeOptionsRespApiRespBase, unknown, Types.GetNotificationTypeOptionsRespApiRespBase> = {
  queryFn: __notificationTypes,
};
export function getNotificationTypesDefaultOptions(): UseQueryOptions<Types.GetNotificationTypeOptionsRespApiRespBase, unknown, Types.GetNotificationTypeOptionsRespApiRespBase> {
  return notificationTypesDefaultOptions;
};
export function setNotificationTypesDefaultOptions(options: UseQueryOptions<Types.GetNotificationTypeOptionsRespApiRespBase, unknown, Types.GetNotificationTypeOptionsRespApiRespBase>) {
  notificationTypesDefaultOptions = options;
}

export function notificationTypesQueryKey(): QueryKey;
export function notificationTypesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'notificationTypes',
    ]);
}
function __notificationTypes() {
  return Client().notificationTypes(
    );
}

/**
 * Get Notification Type Options
 * @return Error
 */
export function useNotificationTypesQuery<TSelectData = Types.GetNotificationTypeOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetNotificationTypeOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useNotificationTypesQuery<TSelectData = Types.GetNotificationTypeOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetNotificationTypeOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetNotificationTypeOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __notificationTypes,
    queryKey: notificationTypesQueryKey(),
    ...notificationTypesDefaultOptions as unknown as UseQueryOptions<Types.GetNotificationTypeOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Notification Type Options
 * @return Error
 */
export function setNotificationTypesData(queryClient: QueryClient, updater: (data: Types.GetNotificationTypeOptionsRespApiRespBase | undefined) => Types.GetNotificationTypeOptionsRespApiRespBase, ) {
  queryClient.setQueryData(notificationTypesQueryKey(),
    updater
  );
}

/**
 * Get Notification Type Options
 * @return Error
 */
export function setNotificationTypesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetNotificationTypeOptionsRespApiRespBase | undefined) => Types.GetNotificationTypeOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function languagesUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/options/languages";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let languagesDefaultOptions: UseQueryOptions<Types.GetLanguagesRespApiRespBase, unknown, Types.GetLanguagesRespApiRespBase> = {
  queryFn: __languages,
};
export function getLanguagesDefaultOptions(): UseQueryOptions<Types.GetLanguagesRespApiRespBase, unknown, Types.GetLanguagesRespApiRespBase> {
  return languagesDefaultOptions;
};
export function setLanguagesDefaultOptions(options: UseQueryOptions<Types.GetLanguagesRespApiRespBase, unknown, Types.GetLanguagesRespApiRespBase>) {
  languagesDefaultOptions = options;
}

export function languagesQueryKey(): QueryKey;
export function languagesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'languages',
    ]);
}
function __languages() {
  return Client().languages(
    );
}

/**
 * Get language options
 * @return Error
 */
export function useLanguagesQuery<TSelectData = Types.GetLanguagesRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetLanguagesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useLanguagesQuery<TSelectData = Types.GetLanguagesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetLanguagesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetLanguagesRespApiRespBase, TError, TSelectData>({
    queryFn: __languages,
    queryKey: languagesQueryKey(),
    ...languagesDefaultOptions as unknown as UseQueryOptions<Types.GetLanguagesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get language options
 * @return Error
 */
export function setLanguagesData(queryClient: QueryClient, updater: (data: Types.GetLanguagesRespApiRespBase | undefined) => Types.GetLanguagesRespApiRespBase, ) {
  queryClient.setQueryData(languagesQueryKey(),
    updater
  );
}

/**
 * Get language options
 * @return Error
 */
export function setLanguagesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetLanguagesRespApiRespBase | undefined) => Types.GetLanguagesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gamesGET3Url(): string {
  let url_ = getBaseUrl() + "/api/v4/options/games";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let gamesGET3DefaultOptions: UseQueryOptions<Types.GetGameOptionsRespApiRespBase, unknown, Types.GetGameOptionsRespApiRespBase> = {
  queryFn: __gamesGET3,
};
export function getGamesGET3DefaultOptions(): UseQueryOptions<Types.GetGameOptionsRespApiRespBase, unknown, Types.GetGameOptionsRespApiRespBase> {
  return gamesGET3DefaultOptions;
};
export function setGamesGET3DefaultOptions(options: UseQueryOptions<Types.GetGameOptionsRespApiRespBase, unknown, Types.GetGameOptionsRespApiRespBase>) {
  gamesGET3DefaultOptions = options;
}

export function gamesGET3QueryKey(): QueryKey;
export function gamesGET3QueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'gamesGET3',
    ]);
}
function __gamesGET3() {
  return Client().gamesGET3(
    );
}

/**
 * Get language options
 * @return Error
 */
export function useGamesGET3Query<TSelectData = Types.GetGameOptionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetGameOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGamesGET3Query<TSelectData = Types.GetGameOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGameOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGameOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __gamesGET3,
    queryKey: gamesGET3QueryKey(),
    ...gamesGET3DefaultOptions as unknown as UseQueryOptions<Types.GetGameOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get language options
 * @return Error
 */
export function setGamesGET3Data(queryClient: QueryClient, updater: (data: Types.GetGameOptionsRespApiRespBase | undefined) => Types.GetGameOptionsRespApiRespBase, ) {
  queryClient.setQueryData(gamesGET3QueryKey(),
    updater
  );
}

/**
 * Get language options
 * @return Error
 */
export function setGamesGET3DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGameOptionsRespApiRespBase | undefined) => Types.GetGameOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function serversGETUrl(gameId: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/options/servers?";
if (gameId === null)
    throw new Error("The parameter 'gameId' cannot be null.");
else if (gameId !== undefined)
    url_ += "gameId=" + encodeURIComponent("" + gameId) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let serversGETDefaultOptions: UseQueryOptions<Types.GetServerOptionsRespApiRespBase, unknown, Types.GetServerOptionsRespApiRespBase> = {
  queryFn: __serversGET,
};
export function getServersGETDefaultOptions(): UseQueryOptions<Types.GetServerOptionsRespApiRespBase, unknown, Types.GetServerOptionsRespApiRespBase> {
  return serversGETDefaultOptions;
};
export function setServersGETDefaultOptions(options: UseQueryOptions<Types.GetServerOptionsRespApiRespBase, unknown, Types.GetServerOptionsRespApiRespBase>) {
  serversGETDefaultOptions = options;
}

export function serversGETQueryKey(gameId: number | undefined): QueryKey;
export function serversGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { gameId,  } = params[0] as ServersGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'serversGET',
        gameId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'serversGET',
        ...params
      ]);
  }
}
function __serversGET(context: QueryFunctionContext) {
  return Client().serversGET(
      context.queryKey[2] as number | undefined    );
}

export function useServersGETQuery<TSelectData = Types.GetServerOptionsRespApiRespBase, TError = unknown>(dto: ServersGETQueryParameters, options?: UseQueryOptions<Types.GetServerOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get servers(locations) options
 * @param gameId (optional) 
 * @return Error
 */
export function useServersGETQuery<TSelectData = Types.GetServerOptionsRespApiRespBase, TError = unknown>(gameId: number | undefined, options?: UseQueryOptions<Types.GetServerOptionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useServersGETQuery<TSelectData = Types.GetServerOptionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetServerOptionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let gameId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ gameId,  } = params[0] as ServersGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [gameId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetServerOptionsRespApiRespBase, TError, TSelectData>({
    queryFn: __serversGET,
    queryKey: serversGETQueryKey(gameId),
    ...serversGETDefaultOptions as unknown as UseQueryOptions<Types.GetServerOptionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get servers(locations) options
 * @param gameId (optional) 
 * @return Error
 */
export function setServersGETData(queryClient: QueryClient, updater: (data: Types.GetServerOptionsRespApiRespBase | undefined) => Types.GetServerOptionsRespApiRespBase, gameId: number | undefined) {
  queryClient.setQueryData(serversGETQueryKey(gameId),
    updater
  );
}

/**
 * Get servers(locations) options
 * @param gameId (optional) 
 * @return Error
 */
export function setServersGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetServerOptionsRespApiRespBase | undefined) => Types.GetServerOptionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function pagesGETUrl(title: string | undefined, frontendId: number | undefined, author: string | undefined, pageId: number | undefined, updatedFrom: number | undefined, updatedTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/pages?";
if (title === null)
    throw new Error("The parameter 'title' cannot be null.");
else if (title !== undefined)
    url_ += "Title=" + encodeURIComponent("" + title) + "&";
if (frontendId === null)
    throw new Error("The parameter 'frontendId' cannot be null.");
else if (frontendId !== undefined)
    url_ += "FrontendId=" + encodeURIComponent("" + frontendId) + "&";
if (author === null)
    throw new Error("The parameter 'author' cannot be null.");
else if (author !== undefined)
    url_ += "Author=" + encodeURIComponent("" + author) + "&";
if (pageId === null)
    throw new Error("The parameter 'pageId' cannot be null.");
else if (pageId !== undefined)
    url_ += "PageId=" + encodeURIComponent("" + pageId) + "&";
if (updatedFrom === null)
    throw new Error("The parameter 'updatedFrom' cannot be null.");
else if (updatedFrom !== undefined)
    url_ += "UpdatedFrom=" + encodeURIComponent("" + updatedFrom) + "&";
if (updatedTo === null)
    throw new Error("The parameter 'updatedTo' cannot be null.");
else if (updatedTo !== undefined)
    url_ += "UpdatedTo=" + encodeURIComponent("" + updatedTo) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let pagesGETDefaultOptions: UseQueryOptions<Types.GetPagesRespApiRespBase, unknown, Types.GetPagesRespApiRespBase> = {
  queryFn: __pagesGET,
};
export function getPagesGETDefaultOptions(): UseQueryOptions<Types.GetPagesRespApiRespBase, unknown, Types.GetPagesRespApiRespBase> {
  return pagesGETDefaultOptions;
};
export function setPagesGETDefaultOptions(options: UseQueryOptions<Types.GetPagesRespApiRespBase, unknown, Types.GetPagesRespApiRespBase>) {
  pagesGETDefaultOptions = options;
}

export function pagesGETQueryKey(dto: PagesGETQueryParameters): QueryKey;
export function pagesGETQueryKey(title: string | undefined, frontendId: number | undefined, author: string | undefined, pageId: number | undefined, updatedFrom: number | undefined, updatedTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function pagesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { title, frontendId, author, pageId, updatedFrom, updatedTo, pageNo, pageSize,  } = params[0] as PagesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'pagesGET',
        title as any,
        frontendId as any,
        author as any,
        pageId as any,
        updatedFrom as any,
        updatedTo as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'pagesGET',
        ...params
      ]);
  }
}
function __pagesGET(context: QueryFunctionContext) {
  return Client().pagesGET(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as number | undefined,       context.queryKey[7] as number | undefined,       context.queryKey[8] as number | undefined,       context.queryKey[9] as number | undefined    );
}

export function usePagesGETQuery<TSelectData = Types.GetPagesRespApiRespBase, TError = unknown>(dto: PagesGETQueryParameters, options?: UseQueryOptions<Types.GetPagesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get pages byt conditions
 * @param title (optional) Title
 * @param frontendId (optional) Frontend id
 * @param author (optional) Create user name
 * @param pageId (optional) Page id
 * @param updatedFrom (optional) Updated from
 * @param updatedTo (optional) Updated to
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function usePagesGETQuery<TSelectData = Types.GetPagesRespApiRespBase, TError = unknown>(title: string | undefined, frontendId: number | undefined, author: string | undefined, pageId: number | undefined, updatedFrom: number | undefined, updatedTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetPagesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function usePagesGETQuery<TSelectData = Types.GetPagesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetPagesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let title: any = undefined;
  let frontendId: any = undefined;
  let author: any = undefined;
  let pageId: any = undefined;
  let updatedFrom: any = undefined;
  let updatedTo: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ title, frontendId, author, pageId, updatedFrom, updatedTo, pageNo, pageSize,  } = params[0] as PagesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [title, frontendId, author, pageId, updatedFrom, updatedTo, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetPagesRespApiRespBase, TError, TSelectData>({
    queryFn: __pagesGET,
    queryKey: pagesGETQueryKey(title, frontendId, author, pageId, updatedFrom, updatedTo, pageNo, pageSize),
    ...pagesGETDefaultOptions as unknown as UseQueryOptions<Types.GetPagesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get pages byt conditions
 * @param title (optional) Title
 * @param frontendId (optional) Frontend id
 * @param author (optional) Create user name
 * @param pageId (optional) Page id
 * @param updatedFrom (optional) Updated from
 * @param updatedTo (optional) Updated to
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setPagesGETData(queryClient: QueryClient, updater: (data: Types.GetPagesRespApiRespBase | undefined) => Types.GetPagesRespApiRespBase, title: string | undefined, frontendId: number | undefined, author: string | undefined, pageId: number | undefined, updatedFrom: number | undefined, updatedTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(pagesGETQueryKey(title, frontendId, author, pageId, updatedFrom, updatedTo, pageNo, pageSize),
    updater
  );
}

/**
 * Get pages byt conditions
 * @param title (optional) Title
 * @param frontendId (optional) Frontend id
 * @param author (optional) Create user name
 * @param pageId (optional) Page id
 * @param updatedFrom (optional) Updated from
 * @param updatedTo (optional) Updated to
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setPagesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetPagesRespApiRespBase | undefined) => Types.GetPagesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function pagesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/pages";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function pagesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'pagesPOST',
    ]);
}

/**
 * Add page
 * @param body (optional) Request
 * @return Error
 */
export function usePagesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddPageRespApiRespBase, unknown, Types.AddPageReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddPageRespApiRespBase, unknown, Types.AddPageReq, TContext> {
  const key = pagesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.AddPageReq) => Client().pagesPOST(body), {...options, mutationKey: key});
}
  
    
export function pagesDELETEUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/pages";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function pagesDELETEMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'pagesDELETE',
    ]);
}

/**
 * Delete page
 * @param body (optional) Request
 * @return Error
 */
export function usePagesDELETEMutation<TContext>(options?: Omit<UseMutationOptions<Types.DelPageRespApiRespBase, unknown, Types.DelPageReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelPageRespApiRespBase, unknown, Types.DelPageReq, TContext> {
  const key = pagesDELETEMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.DelPageReq) => Client().pagesDELETE(body), {...options, mutationKey: key});
}
  
    
export function pagesGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/pages/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let pagesGET2DefaultOptions: UseQueryOptions<Types.GetPageRespApiRespBase, unknown, Types.GetPageRespApiRespBase> = {
  queryFn: __pagesGET2,
};
export function getPagesGET2DefaultOptions(): UseQueryOptions<Types.GetPageRespApiRespBase, unknown, Types.GetPageRespApiRespBase> {
  return pagesGET2DefaultOptions;
};
export function setPagesGET2DefaultOptions(options: UseQueryOptions<Types.GetPageRespApiRespBase, unknown, Types.GetPageRespApiRespBase>) {
  pagesGET2DefaultOptions = options;
}

export function pagesGET2QueryKey(id: number): QueryKey;
export function pagesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as PagesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'pagesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'pagesGET2',
        ...params
      ]);
  }
}
function __pagesGET2(context: QueryFunctionContext) {
  return Client().pagesGET2(
      context.queryKey[2] as number    );
}

export function usePagesGET2Query<TSelectData = Types.GetPageRespApiRespBase, TError = unknown>(dto: PagesGET2QueryParameters, options?: UseQueryOptions<Types.GetPageRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get page
 * @param id PageId
 * @return Error
 */
export function usePagesGET2Query<TSelectData = Types.GetPageRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetPageRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function usePagesGET2Query<TSelectData = Types.GetPageRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetPageRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as PagesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetPageRespApiRespBase, TError, TSelectData>({
    queryFn: __pagesGET2,
    queryKey: pagesGET2QueryKey(id),
    ...pagesGET2DefaultOptions as unknown as UseQueryOptions<Types.GetPageRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get page
 * @param id PageId
 * @return Error
 */
export function setPagesGET2Data(queryClient: QueryClient, updater: (data: Types.GetPageRespApiRespBase | undefined) => Types.GetPageRespApiRespBase, id: number) {
  queryClient.setQueryData(pagesGET2QueryKey(id),
    updater
  );
}

/**
 * Get page
 * @param id PageId
 * @return Error
 */
export function setPagesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetPageRespApiRespBase | undefined) => Types.GetPageRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function pagesPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/pages/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function pagesPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'pagesPATCH',
      id as any,
    ]);
}

/**
 * Modify page
 * @param id PageId
 * @param body (optional) Request
 * @return Error
 */
export function usePagesPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModPageRespApiRespBase, unknown, Types.ModPageReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModPageRespApiRespBase, unknown, Types.ModPageReq, TContext> {
  const key = pagesPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModPageReq) => Client().pagesPATCH(id, body), {...options, mutationKey: key});
}
  
    
export function playersGETUrl(id: number | undefined, nickName: string | undefined, firstName: string | undefined, lastName: string | undefined, primaryGameId: number | undefined, countryId: number | undefined, createdAtFrom: number | undefined, createdAtTo: number | undefined, gameAccount: string | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/players?";
if (id === null)
    throw new Error("The parameter 'id' cannot be null.");
else if (id !== undefined)
    url_ += "Id=" + encodeURIComponent("" + id) + "&";
if (nickName === null)
    throw new Error("The parameter 'nickName' cannot be null.");
else if (nickName !== undefined)
    url_ += "NickName=" + encodeURIComponent("" + nickName) + "&";
if (firstName === null)
    throw new Error("The parameter 'firstName' cannot be null.");
else if (firstName !== undefined)
    url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
if (lastName === null)
    throw new Error("The parameter 'lastName' cannot be null.");
else if (lastName !== undefined)
    url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
if (primaryGameId === null)
    throw new Error("The parameter 'primaryGameId' cannot be null.");
else if (primaryGameId !== undefined)
    url_ += "PrimaryGameId=" + encodeURIComponent("" + primaryGameId) + "&";
if (countryId === null)
    throw new Error("The parameter 'countryId' cannot be null.");
else if (countryId !== undefined)
    url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
if (createdAtFrom === null)
    throw new Error("The parameter 'createdAtFrom' cannot be null.");
else if (createdAtFrom !== undefined)
    url_ += "CreatedAtFrom=" + encodeURIComponent("" + createdAtFrom) + "&";
if (createdAtTo === null)
    throw new Error("The parameter 'createdAtTo' cannot be null.");
else if (createdAtTo !== undefined)
    url_ += "CreatedAtTo=" + encodeURIComponent("" + createdAtTo) + "&";
if (gameAccount === null)
    throw new Error("The parameter 'gameAccount' cannot be null.");
else if (gameAccount !== undefined)
    url_ += "GameAccount=" + encodeURIComponent("" + gameAccount) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let playersGETDefaultOptions: UseQueryOptions<Types.GetPlayersRespApiRespBase, unknown, Types.GetPlayersRespApiRespBase> = {
  queryFn: __playersGET,
};
export function getPlayersGETDefaultOptions(): UseQueryOptions<Types.GetPlayersRespApiRespBase, unknown, Types.GetPlayersRespApiRespBase> {
  return playersGETDefaultOptions;
};
export function setPlayersGETDefaultOptions(options: UseQueryOptions<Types.GetPlayersRespApiRespBase, unknown, Types.GetPlayersRespApiRespBase>) {
  playersGETDefaultOptions = options;
}

export function playersGETQueryKey(dto: PlayersGETQueryParameters): QueryKey;
export function playersGETQueryKey(id: number | undefined, nickName: string | undefined, firstName: string | undefined, lastName: string | undefined, primaryGameId: number | undefined, countryId: number | undefined, createdAtFrom: number | undefined, createdAtTo: number | undefined, gameAccount: string | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function playersGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, nickName, firstName, lastName, primaryGameId, countryId, createdAtFrom, createdAtTo, gameAccount, pageNo, pageSize,  } = params[0] as PlayersGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'playersGET',
        id as any,
        nickName as any,
        firstName as any,
        lastName as any,
        primaryGameId as any,
        countryId as any,
        createdAtFrom as any,
        createdAtTo as any,
        gameAccount as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'playersGET',
        ...params
      ]);
  }
}
function __playersGET(context: QueryFunctionContext) {
  return Client().playersGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as number | undefined,       context.queryKey[7] as number | undefined,       context.queryKey[8] as number | undefined,       context.queryKey[9] as number | undefined,       context.queryKey[10] as string | undefined,       context.queryKey[11] as number | undefined,       context.queryKey[12] as number | undefined    );
}

export function usePlayersGETQuery<TSelectData = Types.GetPlayersRespApiRespBase, TError = unknown>(dto: PlayersGETQueryParameters, options?: UseQueryOptions<Types.GetPlayersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get players
 * @param id (optional) Player Id
 * @param nickName (optional) Player Name
 * @param firstName (optional) First Name
 * @param lastName (optional) Last Name
 * @param primaryGameId (optional) Primary Game Id
 * @param countryId (optional) CountryId
 * @param createdAtFrom (optional) Created at from
 * @param createdAtTo (optional) Created at to
 * @param gameAccount (optional) Game Account
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function usePlayersGETQuery<TSelectData = Types.GetPlayersRespApiRespBase, TError = unknown>(id: number | undefined, nickName: string | undefined, firstName: string | undefined, lastName: string | undefined, primaryGameId: number | undefined, countryId: number | undefined, createdAtFrom: number | undefined, createdAtTo: number | undefined, gameAccount: string | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetPlayersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function usePlayersGETQuery<TSelectData = Types.GetPlayersRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetPlayersRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  let nickName: any = undefined;
  let firstName: any = undefined;
  let lastName: any = undefined;
  let primaryGameId: any = undefined;
  let countryId: any = undefined;
  let createdAtFrom: any = undefined;
  let createdAtTo: any = undefined;
  let gameAccount: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, nickName, firstName, lastName, primaryGameId, countryId, createdAtFrom, createdAtTo, gameAccount, pageNo, pageSize,  } = params[0] as PlayersGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, nickName, firstName, lastName, primaryGameId, countryId, createdAtFrom, createdAtTo, gameAccount, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetPlayersRespApiRespBase, TError, TSelectData>({
    queryFn: __playersGET,
    queryKey: playersGETQueryKey(id, nickName, firstName, lastName, primaryGameId, countryId, createdAtFrom, createdAtTo, gameAccount, pageNo, pageSize),
    ...playersGETDefaultOptions as unknown as UseQueryOptions<Types.GetPlayersRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get players
 * @param id (optional) Player Id
 * @param nickName (optional) Player Name
 * @param firstName (optional) First Name
 * @param lastName (optional) Last Name
 * @param primaryGameId (optional) Primary Game Id
 * @param countryId (optional) CountryId
 * @param createdAtFrom (optional) Created at from
 * @param createdAtTo (optional) Created at to
 * @param gameAccount (optional) Game Account
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setPlayersGETData(queryClient: QueryClient, updater: (data: Types.GetPlayersRespApiRespBase | undefined) => Types.GetPlayersRespApiRespBase, id: number | undefined, nickName: string | undefined, firstName: string | undefined, lastName: string | undefined, primaryGameId: number | undefined, countryId: number | undefined, createdAtFrom: number | undefined, createdAtTo: number | undefined, gameAccount: string | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(playersGETQueryKey(id, nickName, firstName, lastName, primaryGameId, countryId, createdAtFrom, createdAtTo, gameAccount, pageNo, pageSize),
    updater
  );
}

/**
 * Get players
 * @param id (optional) Player Id
 * @param nickName (optional) Player Name
 * @param firstName (optional) First Name
 * @param lastName (optional) Last Name
 * @param primaryGameId (optional) Primary Game Id
 * @param countryId (optional) CountryId
 * @param createdAtFrom (optional) Created at from
 * @param createdAtTo (optional) Created at to
 * @param gameAccount (optional) Game Account
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setPlayersGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetPlayersRespApiRespBase | undefined) => Types.GetPlayersRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function playersPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/players";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function playersPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'playersPOST',
    ]);
}

/**
 * Add player
 * @param userId (optional) 
 * @param isActive (optional) 
 * @param nickName (optional) 
 * @param firstName (optional) 
 * @param lastName (optional) 
 * @param gender (optional) 
 * @param dateOfBirth (optional) ex:2022-12-01
 * @param countryId (optional) 
 * @param initialRating (optional) 
 * @param primaryGameId (optional) 
 * @param image (optional) 
 * @param descriptions (optional) 
 * @param faceBook (optional) 
 * @param twitter (optional) 
 * @param youtube (optional) 
 * @return Error
 */
export function usePlayersPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddPlayerRespApiRespBase, unknown, PlayersPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddPlayerRespApiRespBase, unknown, PlayersPOSTMutationParameters, TContext> {
  const key = playersPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((playersPOSTMutationParameters: PlayersPOSTMutationParameters) => Client().playersPOST(playersPOSTMutationParameters.userId, playersPOSTMutationParameters.isActive, playersPOSTMutationParameters.nickName, playersPOSTMutationParameters.firstName, playersPOSTMutationParameters.lastName, playersPOSTMutationParameters.gender, playersPOSTMutationParameters.dateOfBirth, playersPOSTMutationParameters.countryId, playersPOSTMutationParameters.initialRating, playersPOSTMutationParameters.primaryGameId, playersPOSTMutationParameters.image, playersPOSTMutationParameters.descriptions, playersPOSTMutationParameters.faceBook, playersPOSTMutationParameters.twitter, playersPOSTMutationParameters.youtube), {...options, mutationKey: key});
}
  
    
export function playersGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/players/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let playersGET2DefaultOptions: UseQueryOptions<Types.GetPlayerRespApiRespBase, unknown, Types.GetPlayerRespApiRespBase> = {
  queryFn: __playersGET2,
};
export function getPlayersGET2DefaultOptions(): UseQueryOptions<Types.GetPlayerRespApiRespBase, unknown, Types.GetPlayerRespApiRespBase> {
  return playersGET2DefaultOptions;
};
export function setPlayersGET2DefaultOptions(options: UseQueryOptions<Types.GetPlayerRespApiRespBase, unknown, Types.GetPlayerRespApiRespBase>) {
  playersGET2DefaultOptions = options;
}

export function playersGET2QueryKey(id: number): QueryKey;
export function playersGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as PlayersGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'playersGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'playersGET2',
        ...params
      ]);
  }
}
function __playersGET2(context: QueryFunctionContext) {
  return Client().playersGET2(
      context.queryKey[2] as number    );
}

export function usePlayersGET2Query<TSelectData = Types.GetPlayerRespApiRespBase, TError = unknown>(dto: PlayersGET2QueryParameters, options?: UseQueryOptions<Types.GetPlayerRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get player
 * @param id PlayerId
 * @return Error
 */
export function usePlayersGET2Query<TSelectData = Types.GetPlayerRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetPlayerRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function usePlayersGET2Query<TSelectData = Types.GetPlayerRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetPlayerRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as PlayersGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetPlayerRespApiRespBase, TError, TSelectData>({
    queryFn: __playersGET2,
    queryKey: playersGET2QueryKey(id),
    ...playersGET2DefaultOptions as unknown as UseQueryOptions<Types.GetPlayerRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get player
 * @param id PlayerId
 * @return Error
 */
export function setPlayersGET2Data(queryClient: QueryClient, updater: (data: Types.GetPlayerRespApiRespBase | undefined) => Types.GetPlayerRespApiRespBase, id: number) {
  queryClient.setQueryData(playersGET2QueryKey(id),
    updater
  );
}

/**
 * Get player
 * @param id PlayerId
 * @return Error
 */
export function setPlayersGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetPlayerRespApiRespBase | undefined) => Types.GetPlayerRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function playersPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/players/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function playersPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'playersPATCH',
      id as any,
    ]);
}

/**
 * Modify player
 * @param id PlayerId
 * @param playerId (optional) 
 * @param userId (optional) 
 * @param isActive (optional) 
 * @param nickName (optional) 
 * @param firstName (optional) 
 * @param lastName (optional) 
 * @param gender (optional) 
 * @param dateOfBirth (optional) ex:2022-12-01
 * @param countryId (optional) 
 * @param primaryGameId (optional) 
 * @param image (optional) 
 * @param isRemoveImage (optional) if IsRemoveImage = true will remove Image and set ImageFilePath = null
 * @param descriptions (optional) 
 * @param faceBook (optional) 
 * @param twitter (optional) 
 * @param youtube (optional) 
 * @return Error
 */
export function usePlayersPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModPlayerRespApiRespBase, unknown, PlayersPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModPlayerRespApiRespBase, unknown, PlayersPATCHMutationParameters, TContext> {
  const key = playersPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((playersPATCHMutationParameters: PlayersPATCHMutationParameters) => Client().playersPATCH(id, playersPATCHMutationParameters.playerId, playersPATCHMutationParameters.userId, playersPATCHMutationParameters.isActive, playersPATCHMutationParameters.nickName, playersPATCHMutationParameters.firstName, playersPATCHMutationParameters.lastName, playersPATCHMutationParameters.gender, playersPATCHMutationParameters.dateOfBirth, playersPATCHMutationParameters.countryId, playersPATCHMutationParameters.primaryGameId, playersPATCHMutationParameters.image, playersPATCHMutationParameters.isRemoveImage, playersPATCHMutationParameters.descriptions, playersPATCHMutationParameters.faceBook, playersPATCHMutationParameters.twitter, playersPATCHMutationParameters.youtube), {...options, mutationKey: key});
}
  
    
export function playersDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/players/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function playersDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'playersDELETE',
      id as any,
    ]);
}

/**
 * Delete player
 * @param id PlayerId
 * @return Error
 */
export function usePlayersDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelPlayerRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelPlayerRespApiRespBase, unknown, void, TContext> {
  const key = playersDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().playersDELETE(id), {...options, mutationKey: key});
}
  
    
export function fuzzy3Url(fuzzyPrefix: string, maxCount: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/players/fuzzy?";
  if (fuzzyPrefix === undefined || fuzzyPrefix === null)
    throw new Error("The parameter 'fuzzyPrefix' must be defined and cannot be null.");
  else
    url_ += "FuzzyPrefix=" + encodeURIComponent("" + fuzzyPrefix) + "&";
if (maxCount === null)
    throw new Error("The parameter 'maxCount' cannot be null.");
else if (maxCount !== undefined)
    url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let fuzzy3DefaultOptions: UseQueryOptions<Types.GetFuzzyPlayersRespApiRespBase, unknown, Types.GetFuzzyPlayersRespApiRespBase> = {
  queryFn: __fuzzy3,
};
export function getFuzzy3DefaultOptions(): UseQueryOptions<Types.GetFuzzyPlayersRespApiRespBase, unknown, Types.GetFuzzyPlayersRespApiRespBase> {
  return fuzzy3DefaultOptions;
};
export function setFuzzy3DefaultOptions(options: UseQueryOptions<Types.GetFuzzyPlayersRespApiRespBase, unknown, Types.GetFuzzyPlayersRespApiRespBase>) {
  fuzzy3DefaultOptions = options;
}

export function fuzzy3QueryKey(dto: Fuzzy3QueryParameters): QueryKey;
export function fuzzy3QueryKey(fuzzyPrefix: string, maxCount: number | undefined): QueryKey;
export function fuzzy3QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { fuzzyPrefix, maxCount,  } = params[0] as Fuzzy3QueryParameters;

    return trimArrayEnd([
        'Client',
        'fuzzy3',
        fuzzyPrefix as any,
        maxCount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'fuzzy3',
        ...params
      ]);
  }
}
function __fuzzy3(context: QueryFunctionContext) {
  return Client().fuzzy3(
      context.queryKey[2] as string,       context.queryKey[3] as number | undefined    );
}

export function useFuzzy3Query<TSelectData = Types.GetFuzzyPlayersRespApiRespBase, TError = unknown>(dto: Fuzzy3QueryParameters, options?: UseQueryOptions<Types.GetFuzzyPlayersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get fuzzy players
 * @param maxCount (optional) 
 * @return Error
 */
export function useFuzzy3Query<TSelectData = Types.GetFuzzyPlayersRespApiRespBase, TError = unknown>(fuzzyPrefix: string, maxCount: number | undefined, options?: UseQueryOptions<Types.GetFuzzyPlayersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFuzzy3Query<TSelectData = Types.GetFuzzyPlayersRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuzzyPlayersRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let fuzzyPrefix: any = undefined;
  let maxCount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ fuzzyPrefix, maxCount,  } = params[0] as Fuzzy3QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [fuzzyPrefix, maxCount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuzzyPlayersRespApiRespBase, TError, TSelectData>({
    queryFn: __fuzzy3,
    queryKey: fuzzy3QueryKey(fuzzyPrefix, maxCount),
    ...fuzzy3DefaultOptions as unknown as UseQueryOptions<Types.GetFuzzyPlayersRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get fuzzy players
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzy3Data(queryClient: QueryClient, updater: (data: Types.GetFuzzyPlayersRespApiRespBase | undefined) => Types.GetFuzzyPlayersRespApiRespBase, fuzzyPrefix: string, maxCount: number | undefined) {
  queryClient.setQueryData(fuzzy3QueryKey(fuzzyPrefix, maxCount),
    updater
  );
}

/**
 * Get fuzzy players
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzy3DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuzzyPlayersRespApiRespBase | undefined) => Types.GetFuzzyPlayersRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function usersGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/players/users/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let usersGET2DefaultOptions: UseQueryOptions<Types.GetUserForPlayerRespApiRespBase, unknown, Types.GetUserForPlayerRespApiRespBase> = {
  queryFn: __usersGET2,
};
export function getUsersGET2DefaultOptions(): UseQueryOptions<Types.GetUserForPlayerRespApiRespBase, unknown, Types.GetUserForPlayerRespApiRespBase> {
  return usersGET2DefaultOptions;
};
export function setUsersGET2DefaultOptions(options: UseQueryOptions<Types.GetUserForPlayerRespApiRespBase, unknown, Types.GetUserForPlayerRespApiRespBase>) {
  usersGET2DefaultOptions = options;
}

export function usersGET2QueryKey(id: number): QueryKey;
export function usersGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as UsersGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'usersGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'usersGET2',
        ...params
      ]);
  }
}
function __usersGET2(context: QueryFunctionContext) {
  return Client().usersGET2(
      context.queryKey[2] as number    );
}

export function useUsersGET2Query<TSelectData = Types.GetUserForPlayerRespApiRespBase, TError = unknown>(dto: UsersGET2QueryParameters, options?: UseQueryOptions<Types.GetUserForPlayerRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get User
 * @param id UserId
 * @return Error
 */
export function useUsersGET2Query<TSelectData = Types.GetUserForPlayerRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetUserForPlayerRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUsersGET2Query<TSelectData = Types.GetUserForPlayerRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetUserForPlayerRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as UsersGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetUserForPlayerRespApiRespBase, TError, TSelectData>({
    queryFn: __usersGET2,
    queryKey: usersGET2QueryKey(id),
    ...usersGET2DefaultOptions as unknown as UseQueryOptions<Types.GetUserForPlayerRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get User
 * @param id UserId
 * @return Error
 */
export function setUsersGET2Data(queryClient: QueryClient, updater: (data: Types.GetUserForPlayerRespApiRespBase | undefined) => Types.GetUserForPlayerRespApiRespBase, id: number) {
  queryClient.setQueryData(usersGET2QueryKey(id),
    updater
  );
}

/**
 * Get User
 * @param id UserId
 * @return Error
 */
export function setUsersGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetUserForPlayerRespApiRespBase | undefined) => Types.GetUserForPlayerRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function mediaItemsGET2Url(playerid: number, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/players/{playerid}/media-items?";
if (playerid === undefined || playerid === null)
  throw new Error("The parameter 'playerid' must be defined.");
url_ = url_.replace("{playerid}", encodeURIComponent("" + playerid));
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let mediaItemsGET2DefaultOptions: UseQueryOptions<Types.GetPlayerMediaItemsRespApiRespBase, unknown, Types.GetPlayerMediaItemsRespApiRespBase> = {
  queryFn: __mediaItemsGET2,
};
export function getMediaItemsGET2DefaultOptions(): UseQueryOptions<Types.GetPlayerMediaItemsRespApiRespBase, unknown, Types.GetPlayerMediaItemsRespApiRespBase> {
  return mediaItemsGET2DefaultOptions;
};
export function setMediaItemsGET2DefaultOptions(options: UseQueryOptions<Types.GetPlayerMediaItemsRespApiRespBase, unknown, Types.GetPlayerMediaItemsRespApiRespBase>) {
  mediaItemsGET2DefaultOptions = options;
}

export function mediaItemsGET2QueryKey(dto: MediaItemsGET2QueryParameters): QueryKey;
export function mediaItemsGET2QueryKey(playerid: number, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function mediaItemsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { playerid, pageNo, pageSize,  } = params[0] as MediaItemsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'mediaItemsGET2',
        playerid as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'mediaItemsGET2',
        ...params
      ]);
  }
}
function __mediaItemsGET2(context: QueryFunctionContext) {
  return Client().mediaItemsGET2(
      context.queryKey[2] as number,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined    );
}

export function useMediaItemsGET2Query<TSelectData = Types.GetPlayerMediaItemsRespApiRespBase, TError = unknown>(dto: MediaItemsGET2QueryParameters, options?: UseQueryOptions<Types.GetPlayerMediaItemsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get player Media items
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useMediaItemsGET2Query<TSelectData = Types.GetPlayerMediaItemsRespApiRespBase, TError = unknown>(playerid: number, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetPlayerMediaItemsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMediaItemsGET2Query<TSelectData = Types.GetPlayerMediaItemsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetPlayerMediaItemsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let playerid: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ playerid, pageNo, pageSize,  } = params[0] as MediaItemsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [playerid, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetPlayerMediaItemsRespApiRespBase, TError, TSelectData>({
    queryFn: __mediaItemsGET2,
    queryKey: mediaItemsGET2QueryKey(playerid, pageNo, pageSize),
    ...mediaItemsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetPlayerMediaItemsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get player Media items
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setMediaItemsGET2Data(queryClient: QueryClient, updater: (data: Types.GetPlayerMediaItemsRespApiRespBase | undefined) => Types.GetPlayerMediaItemsRespApiRespBase, playerid: number, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(mediaItemsGET2QueryKey(playerid, pageNo, pageSize),
    updater
  );
}

/**
 * Get player Media items
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setMediaItemsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetPlayerMediaItemsRespApiRespBase | undefined) => Types.GetPlayerMediaItemsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function mediaItemsPOST2Url(playerid: number, mediaItems: number[]): string {
  let url_ = getBaseUrl() + "/api/v4/players/{playerid}/media-items?";
if (playerid === undefined || playerid === null)
  throw new Error("The parameter 'playerid' must be defined.");
url_ = url_.replace("{playerid}", encodeURIComponent("" + playerid));
  if (mediaItems === undefined || mediaItems === null)
    throw new Error("The parameter 'mediaItems' must be defined and cannot be null.");
  else
    mediaItems && mediaItems.forEach(item => { url_ += "MediaItems=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function mediaItemsPOST2MutationKey(playerid: number, mediaItems: number[]): MutationKey {
  return trimArrayEnd([
      'Client',
      'mediaItemsPOST2',
      playerid as any,
      mediaItems as any,
    ]);
}

/**
 * Add player new Media items
 * @param mediaItems Media item Ids
 * @return Error
 */
export function useMediaItemsPOST2Mutation<TContext>(playerid: number, mediaItems: number[], options?: Omit<UseMutationOptions<Types.AddPlayerMediaItemRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddPlayerMediaItemRespApiRespBase, unknown, void, TContext> {
  const key = mediaItemsPOST2MutationKey(playerid, mediaItems);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().mediaItemsPOST2(playerid, mediaItems), {...options, mutationKey: key});
}
  
    
export function mediaItemsDELETE2Url(playerid: number, mediaitemid: number): string {
  let url_ = getBaseUrl() + "/api/v4/players/{playerid}/media-items/{mediaitemid}";
if (playerid === undefined || playerid === null)
  throw new Error("The parameter 'playerid' must be defined.");
url_ = url_.replace("{playerid}", encodeURIComponent("" + playerid));
if (mediaitemid === undefined || mediaitemid === null)
  throw new Error("The parameter 'mediaitemid' must be defined.");
url_ = url_.replace("{mediaitemid}", encodeURIComponent("" + mediaitemid));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function mediaItemsDELETE2MutationKey(playerid: number, mediaitemid: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'mediaItemsDELETE2',
      playerid as any,
      mediaitemid as any,
    ]);
}

/**
 * Delete player Media item
 * @param playerid Player Id
 * @param mediaitemid Media Item Id
 * @return Error
 */
export function useMediaItemsDELETE2Mutation<TContext>(playerid: number, mediaitemid: number, options?: Omit<UseMutationOptions<Types.DelPlayerMediaItemRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelPlayerMediaItemRespApiRespBase, unknown, void, TContext> {
  const key = mediaItemsDELETE2MutationKey(playerid, mediaitemid);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().mediaItemsDELETE2(playerid, mediaitemid), {...options, mutationKey: key});
}
  
    
export function roleOptionsUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/roles/role-options";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let roleOptionsDefaultOptions: UseQueryOptions<Types.GetRoleOptionsByGroupRespApiRespBase, unknown, Types.GetRoleOptionsByGroupRespApiRespBase> = {
  queryFn: __roleOptions,
};
export function getRoleOptionsDefaultOptions(): UseQueryOptions<Types.GetRoleOptionsByGroupRespApiRespBase, unknown, Types.GetRoleOptionsByGroupRespApiRespBase> {
  return roleOptionsDefaultOptions;
};
export function setRoleOptionsDefaultOptions(options: UseQueryOptions<Types.GetRoleOptionsByGroupRespApiRespBase, unknown, Types.GetRoleOptionsByGroupRespApiRespBase>) {
  roleOptionsDefaultOptions = options;
}

export function roleOptionsQueryKey(): QueryKey;
export function roleOptionsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'roleOptions',
    ]);
}
function __roleOptions() {
  return Client().roleOptions(
    );
}

/**
 * Get role options
 * @return Error
 */
export function useRoleOptionsQuery<TSelectData = Types.GetRoleOptionsByGroupRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetRoleOptionsByGroupRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useRoleOptionsQuery<TSelectData = Types.GetRoleOptionsByGroupRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetRoleOptionsByGroupRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetRoleOptionsByGroupRespApiRespBase, TError, TSelectData>({
    queryFn: __roleOptions,
    queryKey: roleOptionsQueryKey(),
    ...roleOptionsDefaultOptions as unknown as UseQueryOptions<Types.GetRoleOptionsByGroupRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get role options
 * @return Error
 */
export function setRoleOptionsData(queryClient: QueryClient, updater: (data: Types.GetRoleOptionsByGroupRespApiRespBase | undefined) => Types.GetRoleOptionsByGroupRespApiRespBase, ) {
  queryClient.setQueryData(roleOptionsQueryKey(),
    updater
  );
}

/**
 * Get role options
 * @return Error
 */
export function setRoleOptionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetRoleOptionsByGroupRespApiRespBase | undefined) => Types.GetRoleOptionsByGroupRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function usersGET3Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/roles/users/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let usersGET3DefaultOptions: UseQueryOptions<Types.GetUsersByRoleRespApiRespBase, unknown, Types.GetUsersByRoleRespApiRespBase> = {
  queryFn: __usersGET3,
};
export function getUsersGET3DefaultOptions(): UseQueryOptions<Types.GetUsersByRoleRespApiRespBase, unknown, Types.GetUsersByRoleRespApiRespBase> {
  return usersGET3DefaultOptions;
};
export function setUsersGET3DefaultOptions(options: UseQueryOptions<Types.GetUsersByRoleRespApiRespBase, unknown, Types.GetUsersByRoleRespApiRespBase>) {
  usersGET3DefaultOptions = options;
}

export function usersGET3QueryKey(id: number): QueryKey;
export function usersGET3QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as UsersGET3QueryParameters;

    return trimArrayEnd([
        'Client',
        'usersGET3',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'usersGET3',
        ...params
      ]);
  }
}
function __usersGET3(context: QueryFunctionContext) {
  return Client().usersGET3(
      context.queryKey[2] as number    );
}

export function useUsersGET3Query<TSelectData = Types.GetUsersByRoleRespApiRespBase, TError = unknown>(dto: UsersGET3QueryParameters, options?: UseQueryOptions<Types.GetUsersByRoleRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get users by role
 * @param id RoleId
 * @return Error
 */
export function useUsersGET3Query<TSelectData = Types.GetUsersByRoleRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetUsersByRoleRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUsersGET3Query<TSelectData = Types.GetUsersByRoleRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetUsersByRoleRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as UsersGET3QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetUsersByRoleRespApiRespBase, TError, TSelectData>({
    queryFn: __usersGET3,
    queryKey: usersGET3QueryKey(id),
    ...usersGET3DefaultOptions as unknown as UseQueryOptions<Types.GetUsersByRoleRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get users by role
 * @param id RoleId
 * @return Error
 */
export function setUsersGET3Data(queryClient: QueryClient, updater: (data: Types.GetUsersByRoleRespApiRespBase | undefined) => Types.GetUsersByRoleRespApiRespBase, id: number) {
  queryClient.setQueryData(usersGET3QueryKey(id),
    updater
  );
}

/**
 * Get users by role
 * @param id RoleId
 * @return Error
 */
export function setUsersGET3DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetUsersByRoleRespApiRespBase | undefined) => Types.GetUsersByRoleRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function rolesGETUrl(roleIds: number[] | undefined, groupIds: number[] | undefined, frontendIds: number[] | undefined, remark: string | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/roles?";
if (roleIds === null)
    throw new Error("The parameter 'roleIds' cannot be null.");
else if (roleIds !== undefined)
    roleIds && roleIds.forEach(item => { url_ += "RoleIds=" + encodeURIComponent("" + item) + "&"; });
if (groupIds === null)
    throw new Error("The parameter 'groupIds' cannot be null.");
else if (groupIds !== undefined)
    groupIds && groupIds.forEach(item => { url_ += "GroupIds=" + encodeURIComponent("" + item) + "&"; });
if (frontendIds === null)
    throw new Error("The parameter 'frontendIds' cannot be null.");
else if (frontendIds !== undefined)
    frontendIds && frontendIds.forEach(item => { url_ += "FrontendIds=" + encodeURIComponent("" + item) + "&"; });
if (remark === null)
    throw new Error("The parameter 'remark' cannot be null.");
else if (remark !== undefined)
    url_ += "Remark=" + encodeURIComponent("" + remark) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let rolesGETDefaultOptions: UseQueryOptions<Types.GetRolesByGroupRespApiRespBase, unknown, Types.GetRolesByGroupRespApiRespBase> = {
  queryFn: __rolesGET,
};
export function getRolesGETDefaultOptions(): UseQueryOptions<Types.GetRolesByGroupRespApiRespBase, unknown, Types.GetRolesByGroupRespApiRespBase> {
  return rolesGETDefaultOptions;
};
export function setRolesGETDefaultOptions(options: UseQueryOptions<Types.GetRolesByGroupRespApiRespBase, unknown, Types.GetRolesByGroupRespApiRespBase>) {
  rolesGETDefaultOptions = options;
}

export function rolesGETQueryKey(dto: RolesGETQueryParameters): QueryKey;
export function rolesGETQueryKey(roleIds: number[] | undefined, groupIds: number[] | undefined, frontendIds: number[] | undefined, remark: string | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function rolesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { roleIds, groupIds, frontendIds, remark, pageNo, pageSize,  } = params[0] as RolesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'rolesGET',
        roleIds as any,
        groupIds as any,
        frontendIds as any,
        remark as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'rolesGET',
        ...params
      ]);
  }
}
function __rolesGET(context: QueryFunctionContext) {
  return Client().rolesGET(
      context.queryKey[2] as number[] | undefined,       context.queryKey[3] as number[] | undefined,       context.queryKey[4] as number[] | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as number | undefined,       context.queryKey[7] as number | undefined    );
}

export function useRolesGETQuery<TSelectData = Types.GetRolesByGroupRespApiRespBase, TError = unknown>(dto: RolesGETQueryParameters, options?: UseQueryOptions<Types.GetRolesByGroupRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get roles
 * @param roleIds (optional) Role ids
 * @param groupIds (optional) Group ids
 * @param frontendIds (optional) Frontend ids
 * @param remark (optional) Group remark
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useRolesGETQuery<TSelectData = Types.GetRolesByGroupRespApiRespBase, TError = unknown>(roleIds: number[] | undefined, groupIds: number[] | undefined, frontendIds: number[] | undefined, remark: string | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetRolesByGroupRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useRolesGETQuery<TSelectData = Types.GetRolesByGroupRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetRolesByGroupRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let roleIds: any = undefined;
  let groupIds: any = undefined;
  let frontendIds: any = undefined;
  let remark: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ roleIds, groupIds, frontendIds, remark, pageNo, pageSize,  } = params[0] as RolesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [roleIds, groupIds, frontendIds, remark, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetRolesByGroupRespApiRespBase, TError, TSelectData>({
    queryFn: __rolesGET,
    queryKey: rolesGETQueryKey(roleIds, groupIds, frontendIds, remark, pageNo, pageSize),
    ...rolesGETDefaultOptions as unknown as UseQueryOptions<Types.GetRolesByGroupRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get roles
 * @param roleIds (optional) Role ids
 * @param groupIds (optional) Group ids
 * @param frontendIds (optional) Frontend ids
 * @param remark (optional) Group remark
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setRolesGETData(queryClient: QueryClient, updater: (data: Types.GetRolesByGroupRespApiRespBase | undefined) => Types.GetRolesByGroupRespApiRespBase, roleIds: number[] | undefined, groupIds: number[] | undefined, frontendIds: number[] | undefined, remark: string | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(rolesGETQueryKey(roleIds, groupIds, frontendIds, remark, pageNo, pageSize),
    updater
  );
}

/**
 * Get roles
 * @param roleIds (optional) Role ids
 * @param groupIds (optional) Group ids
 * @param frontendIds (optional) Frontend ids
 * @param remark (optional) Group remark
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setRolesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetRolesByGroupRespApiRespBase | undefined) => Types.GetRolesByGroupRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function rolesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/roles";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function rolesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'rolesPOST',
    ]);
}

/**
 * Add role
 * @param body (optional) Request
 * @return Error
 */
export function useRolesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddRoleRespApiRespBase, unknown, Types.AddRoleReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddRoleRespApiRespBase, unknown, Types.AddRoleReq, TContext> {
  const key = rolesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.AddRoleReq) => Client().rolesPOST(body), {...options, mutationKey: key});
}
  
    
export function rolesGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/roles/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let rolesGET2DefaultOptions: UseQueryOptions<Types.GetRoleRespApiRespBase, unknown, Types.GetRoleRespApiRespBase> = {
  queryFn: __rolesGET2,
};
export function getRolesGET2DefaultOptions(): UseQueryOptions<Types.GetRoleRespApiRespBase, unknown, Types.GetRoleRespApiRespBase> {
  return rolesGET2DefaultOptions;
};
export function setRolesGET2DefaultOptions(options: UseQueryOptions<Types.GetRoleRespApiRespBase, unknown, Types.GetRoleRespApiRespBase>) {
  rolesGET2DefaultOptions = options;
}

export function rolesGET2QueryKey(id: number): QueryKey;
export function rolesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as RolesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'rolesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'rolesGET2',
        ...params
      ]);
  }
}
function __rolesGET2(context: QueryFunctionContext) {
  return Client().rolesGET2(
      context.queryKey[2] as number    );
}

export function useRolesGET2Query<TSelectData = Types.GetRoleRespApiRespBase, TError = unknown>(dto: RolesGET2QueryParameters, options?: UseQueryOptions<Types.GetRoleRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get role
 * @param id RoleId
 * @return Error
 */
export function useRolesGET2Query<TSelectData = Types.GetRoleRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetRoleRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useRolesGET2Query<TSelectData = Types.GetRoleRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetRoleRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as RolesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetRoleRespApiRespBase, TError, TSelectData>({
    queryFn: __rolesGET2,
    queryKey: rolesGET2QueryKey(id),
    ...rolesGET2DefaultOptions as unknown as UseQueryOptions<Types.GetRoleRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get role
 * @param id RoleId
 * @return Error
 */
export function setRolesGET2Data(queryClient: QueryClient, updater: (data: Types.GetRoleRespApiRespBase | undefined) => Types.GetRoleRespApiRespBase, id: number) {
  queryClient.setQueryData(rolesGET2QueryKey(id),
    updater
  );
}

/**
 * Get role
 * @param id RoleId
 * @return Error
 */
export function setRolesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetRoleRespApiRespBase | undefined) => Types.GetRoleRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function rolesPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/roles/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function rolesPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'rolesPATCH',
      id as any,
    ]);
}

/**
 * Modify Role
 * @param id RoleId
 * @param body (optional) Request
 * @return Error
 */
export function useRolesPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModRoleRespApiRespBase, unknown, Types.ModRoleReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModRoleRespApiRespBase, unknown, Types.ModRoleReq, TContext> {
  const key = rolesPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModRoleReq) => Client().rolesPATCH(id, body), {...options, mutationKey: key});
}
  
    
export function rolesDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/roles/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function rolesDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'rolesDELETE',
      id as any,
    ]);
}

/**
 * Delete role
 * @param id RoleId
 * @return Error
 */
export function useRolesDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelRoleRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelRoleRespApiRespBase, unknown, void, TContext> {
  const key = rolesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().rolesDELETE(id), {...options, mutationKey: key});
}
  
    
export function assignRoleUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/roles/assign-role";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function assignRoleMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'assignRole',
    ]);
}

/**
 * Assign role
 * @param body (optional) Request
 * @return Error
 */
export function useAssignRoleMutation<TContext>(options?: Omit<UseMutationOptions<Types.AssignRoleRespApiRespBase, unknown, Types.AssignRoleReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AssignRoleRespApiRespBase, unknown, Types.AssignRoleReq, TContext> {
  const key = assignRoleMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.AssignRoleReq) => Client().assignRole(body), {...options, mutationKey: key});
}
  
    
export function unassignRoleUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/roles/unassign-role";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function unassignRoleMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'unassignRole',
    ]);
}

/**
 * UnAssign role
 * @param body (optional) Request
 * @return Error
 */
export function useUnassignRoleMutation<TContext>(options?: Omit<UseMutationOptions<Types.UnAssignRoleRespApiRespBase, unknown, Types.UnAssignRoleReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.UnAssignRoleRespApiRespBase, unknown, Types.UnAssignRoleReq, TContext> {
  const key = unassignRoleMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.UnAssignRoleReq) => Client().unassignRole(body), {...options, mutationKey: key});
}
  
    
export function blankPermissions2Url(): string {
  let url_ = getBaseUrl() + "/api/v4/roles/blank-permissions";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let blankPermissions2DefaultOptions: UseQueryOptions<Types.GetRoleBlankPermissionsRespApiRespBase, unknown, Types.GetRoleBlankPermissionsRespApiRespBase> = {
  queryFn: __blankPermissions2,
};
export function getBlankPermissions2DefaultOptions(): UseQueryOptions<Types.GetRoleBlankPermissionsRespApiRespBase, unknown, Types.GetRoleBlankPermissionsRespApiRespBase> {
  return blankPermissions2DefaultOptions;
};
export function setBlankPermissions2DefaultOptions(options: UseQueryOptions<Types.GetRoleBlankPermissionsRespApiRespBase, unknown, Types.GetRoleBlankPermissionsRespApiRespBase>) {
  blankPermissions2DefaultOptions = options;
}

export function blankPermissions2QueryKey(): QueryKey;
export function blankPermissions2QueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'blankPermissions2',
    ]);
}
function __blankPermissions2() {
  return Client().blankPermissions2(
    );
}

/**
 * Get role blank permissions
 * @return Error
 */
export function useBlankPermissions2Query<TSelectData = Types.GetRoleBlankPermissionsRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetRoleBlankPermissionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useBlankPermissions2Query<TSelectData = Types.GetRoleBlankPermissionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetRoleBlankPermissionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetRoleBlankPermissionsRespApiRespBase, TError, TSelectData>({
    queryFn: __blankPermissions2,
    queryKey: blankPermissions2QueryKey(),
    ...blankPermissions2DefaultOptions as unknown as UseQueryOptions<Types.GetRoleBlankPermissionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get role blank permissions
 * @return Error
 */
export function setBlankPermissions2Data(queryClient: QueryClient, updater: (data: Types.GetRoleBlankPermissionsRespApiRespBase | undefined) => Types.GetRoleBlankPermissionsRespApiRespBase, ) {
  queryClient.setQueryData(blankPermissions2QueryKey(),
    updater
  );
}

/**
 * Get role blank permissions
 * @return Error
 */
export function setBlankPermissions2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetRoleBlankPermissionsRespApiRespBase | undefined) => Types.GetRoleBlankPermissionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function templates2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/roles/templates/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let templates2DefaultOptions: UseQueryOptions<Types.GetRoleTemplatesByGroupRespApiRespBase, unknown, Types.GetRoleTemplatesByGroupRespApiRespBase> = {
  queryFn: __templates2,
};
export function getTemplates2DefaultOptions(): UseQueryOptions<Types.GetRoleTemplatesByGroupRespApiRespBase, unknown, Types.GetRoleTemplatesByGroupRespApiRespBase> {
  return templates2DefaultOptions;
};
export function setTemplates2DefaultOptions(options: UseQueryOptions<Types.GetRoleTemplatesByGroupRespApiRespBase, unknown, Types.GetRoleTemplatesByGroupRespApiRespBase>) {
  templates2DefaultOptions = options;
}

export function templates2QueryKey(id: number): QueryKey;
export function templates2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as Templates2QueryParameters;

    return trimArrayEnd([
        'Client',
        'templates2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'templates2',
        ...params
      ]);
  }
}
function __templates2(context: QueryFunctionContext) {
  return Client().templates2(
      context.queryKey[2] as number    );
}

export function useTemplates2Query<TSelectData = Types.GetRoleTemplatesByGroupRespApiRespBase, TError = unknown>(dto: Templates2QueryParameters, options?: UseQueryOptions<Types.GetRoleTemplatesByGroupRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get role templates by group
 * @return Error
 */
export function useTemplates2Query<TSelectData = Types.GetRoleTemplatesByGroupRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetRoleTemplatesByGroupRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTemplates2Query<TSelectData = Types.GetRoleTemplatesByGroupRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetRoleTemplatesByGroupRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as Templates2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetRoleTemplatesByGroupRespApiRespBase, TError, TSelectData>({
    queryFn: __templates2,
    queryKey: templates2QueryKey(id),
    ...templates2DefaultOptions as unknown as UseQueryOptions<Types.GetRoleTemplatesByGroupRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get role templates by group
 * @return Error
 */
export function setTemplates2Data(queryClient: QueryClient, updater: (data: Types.GetRoleTemplatesByGroupRespApiRespBase | undefined) => Types.GetRoleTemplatesByGroupRespApiRespBase, id: number) {
  queryClient.setQueryData(templates2QueryKey(id),
    updater
  );
}

/**
 * Get role templates by group
 * @return Error
 */
export function setTemplates2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetRoleTemplatesByGroupRespApiRespBase | undefined) => Types.GetRoleTemplatesByGroupRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function serversGET2Url(name: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/servers?";
if (name === null)
    throw new Error("The parameter 'name' cannot be null.");
else if (name !== undefined)
    url_ += "Name=" + encodeURIComponent("" + name) + "&";
if (gameId === null)
    throw new Error("The parameter 'gameId' cannot be null.");
else if (gameId !== undefined)
    url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let serversGET2DefaultOptions: UseQueryOptions<Types.GetServersRespApiRespBase, unknown, Types.GetServersRespApiRespBase> = {
  queryFn: __serversGET2,
};
export function getServersGET2DefaultOptions(): UseQueryOptions<Types.GetServersRespApiRespBase, unknown, Types.GetServersRespApiRespBase> {
  return serversGET2DefaultOptions;
};
export function setServersGET2DefaultOptions(options: UseQueryOptions<Types.GetServersRespApiRespBase, unknown, Types.GetServersRespApiRespBase>) {
  serversGET2DefaultOptions = options;
}

export function serversGET2QueryKey(dto: ServersGET2QueryParameters): QueryKey;
export function serversGET2QueryKey(name: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function serversGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { name, gameId, pageNo, pageSize,  } = params[0] as ServersGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'serversGET2',
        name as any,
        gameId as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'serversGET2',
        ...params
      ]);
  }
}
function __serversGET2(context: QueryFunctionContext) {
  return Client().serversGET2(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as number | undefined    );
}

export function useServersGET2Query<TSelectData = Types.GetServersRespApiRespBase, TError = unknown>(dto: ServersGET2QueryParameters, options?: UseQueryOptions<Types.GetServersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get servers by condition
 * @param name (optional) Server Name
 * @param gameId (optional) Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useServersGET2Query<TSelectData = Types.GetServersRespApiRespBase, TError = unknown>(name: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetServersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useServersGET2Query<TSelectData = Types.GetServersRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetServersRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let name: any = undefined;
  let gameId: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ name, gameId, pageNo, pageSize,  } = params[0] as ServersGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [name, gameId, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetServersRespApiRespBase, TError, TSelectData>({
    queryFn: __serversGET2,
    queryKey: serversGET2QueryKey(name, gameId, pageNo, pageSize),
    ...serversGET2DefaultOptions as unknown as UseQueryOptions<Types.GetServersRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get servers by condition
 * @param name (optional) Server Name
 * @param gameId (optional) Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setServersGET2Data(queryClient: QueryClient, updater: (data: Types.GetServersRespApiRespBase | undefined) => Types.GetServersRespApiRespBase, name: string | undefined, gameId: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(serversGET2QueryKey(name, gameId, pageNo, pageSize),
    updater
  );
}

/**
 * Get servers by condition
 * @param name (optional) Server Name
 * @param gameId (optional) Game Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setServersGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetServersRespApiRespBase | undefined) => Types.GetServersRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function serversPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/servers";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function serversPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'serversPOST',
    ]);
}

/**
 * Add new tournaments server
 * @param name (optional) Server Name
 * @param gameId (optional) Game Id
 * @return Error
 */
export function useServersPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddServerRespApiRespBase, unknown, ServersPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddServerRespApiRespBase, unknown, ServersPOSTMutationParameters, TContext> {
  const key = serversPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((serversPOSTMutationParameters: ServersPOSTMutationParameters) => Client().serversPOST(serversPOSTMutationParameters.name, serversPOSTMutationParameters.gameId), {...options, mutationKey: key});
}
  
    
export function serversGET3Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/servers/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let serversGET3DefaultOptions: UseQueryOptions<Types.GetServerRespApiRespBase, unknown, Types.GetServerRespApiRespBase> = {
  queryFn: __serversGET3,
};
export function getServersGET3DefaultOptions(): UseQueryOptions<Types.GetServerRespApiRespBase, unknown, Types.GetServerRespApiRespBase> {
  return serversGET3DefaultOptions;
};
export function setServersGET3DefaultOptions(options: UseQueryOptions<Types.GetServerRespApiRespBase, unknown, Types.GetServerRespApiRespBase>) {
  serversGET3DefaultOptions = options;
}

export function serversGET3QueryKey(id: number): QueryKey;
export function serversGET3QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ServersGET3QueryParameters;

    return trimArrayEnd([
        'Client',
        'serversGET3',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'serversGET3',
        ...params
      ]);
  }
}
function __serversGET3(context: QueryFunctionContext) {
  return Client().serversGET3(
      context.queryKey[2] as number    );
}

export function useServersGET3Query<TSelectData = Types.GetServerRespApiRespBase, TError = unknown>(dto: ServersGET3QueryParameters, options?: UseQueryOptions<Types.GetServerRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get tournaments server detail
 * @param id Server Id
 * @return Error
 */
export function useServersGET3Query<TSelectData = Types.GetServerRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetServerRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useServersGET3Query<TSelectData = Types.GetServerRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetServerRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ServersGET3QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetServerRespApiRespBase, TError, TSelectData>({
    queryFn: __serversGET3,
    queryKey: serversGET3QueryKey(id),
    ...serversGET3DefaultOptions as unknown as UseQueryOptions<Types.GetServerRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get tournaments server detail
 * @param id Server Id
 * @return Error
 */
export function setServersGET3Data(queryClient: QueryClient, updater: (data: Types.GetServerRespApiRespBase | undefined) => Types.GetServerRespApiRespBase, id: number) {
  queryClient.setQueryData(serversGET3QueryKey(id),
    updater
  );
}

/**
 * Get tournaments server detail
 * @param id Server Id
 * @return Error
 */
export function setServersGET3DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetServerRespApiRespBase | undefined) => Types.GetServerRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function serversPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/servers/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function serversPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'serversPATCH',
      id as any,
    ]);
}

/**
 * Modify tournaments server
 * @param id tournaments server id
 * @param id (optional) Server Id
 * @param name (optional) Server Name
 * @param isFrozen (optional) Is Frozen
 * @param gameId (optional) Game Id
 * @return Error
 */
export function useServersPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModServerRespApiRespBase, unknown, ServersPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModServerRespApiRespBase, unknown, ServersPATCHMutationParameters, TContext> {
  const key = serversPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((serversPATCHMutationParameters: ServersPATCHMutationParameters) => Client().serversPATCH(id, serversPATCHMutationParameters.id, serversPATCHMutationParameters.name, serversPATCHMutationParameters.isFrozen, serversPATCHMutationParameters.gameId), {...options, mutationKey: key});
}
  
    
export function serversDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/servers/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function serversDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'serversDELETE',
      id as any,
    ]);
}

/**
 * Delete tournaments server
 * @param id tournaments Server Id
 * @return Error
 */
export function useServersDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelServerRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelServerRespApiRespBase, unknown, void, TContext> {
  const key = serversDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().serversDELETE(id), {...options, mutationKey: key});
}
  
    
export function siteSectionsGET2Url(filters_Id: number | undefined, filters_Name: string | undefined, filters_GameName: string | undefined, filters_Hidden: boolean | undefined, sorts_Id: Types.EnumFieldSort | undefined, sorts_GameName: Types.EnumFieldSort | undefined, sorts_Name: Types.EnumFieldSort | undefined, sorts_Hidden: Types.EnumFieldSort | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/sitesections/site-sections?";
if (filters_Id === null)
    throw new Error("The parameter 'filters_Id' cannot be null.");
else if (filters_Id !== undefined)
    url_ += "Filters.Id=" + encodeURIComponent("" + filters_Id) + "&";
if (filters_Name === null)
    throw new Error("The parameter 'filters_Name' cannot be null.");
else if (filters_Name !== undefined)
    url_ += "Filters.Name=" + encodeURIComponent("" + filters_Name) + "&";
if (filters_GameName === null)
    throw new Error("The parameter 'filters_GameName' cannot be null.");
else if (filters_GameName !== undefined)
    url_ += "Filters.GameName=" + encodeURIComponent("" + filters_GameName) + "&";
if (filters_Hidden === null)
    throw new Error("The parameter 'filters_Hidden' cannot be null.");
else if (filters_Hidden !== undefined)
    url_ += "Filters.Hidden=" + encodeURIComponent("" + filters_Hidden) + "&";
if (sorts_Id === null)
    throw new Error("The parameter 'sorts_Id' cannot be null.");
else if (sorts_Id !== undefined)
    url_ += "Sorts.Id=" + encodeURIComponent("" + sorts_Id) + "&";
if (sorts_GameName === null)
    throw new Error("The parameter 'sorts_GameName' cannot be null.");
else if (sorts_GameName !== undefined)
    url_ += "Sorts.GameName=" + encodeURIComponent("" + sorts_GameName) + "&";
if (sorts_Name === null)
    throw new Error("The parameter 'sorts_Name' cannot be null.");
else if (sorts_Name !== undefined)
    url_ += "Sorts.Name=" + encodeURIComponent("" + sorts_Name) + "&";
if (sorts_Hidden === null)
    throw new Error("The parameter 'sorts_Hidden' cannot be null.");
else if (sorts_Hidden !== undefined)
    url_ += "Sorts.Hidden=" + encodeURIComponent("" + sorts_Hidden) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let siteSectionsGET2DefaultOptions: UseQueryOptions<Types.GetSiteSectionsRespApiRespBase, unknown, Types.GetSiteSectionsRespApiRespBase> = {
  queryFn: __siteSectionsGET2,
};
export function getSiteSectionsGET2DefaultOptions(): UseQueryOptions<Types.GetSiteSectionsRespApiRespBase, unknown, Types.GetSiteSectionsRespApiRespBase> {
  return siteSectionsGET2DefaultOptions;
};
export function setSiteSectionsGET2DefaultOptions(options: UseQueryOptions<Types.GetSiteSectionsRespApiRespBase, unknown, Types.GetSiteSectionsRespApiRespBase>) {
  siteSectionsGET2DefaultOptions = options;
}

export function siteSectionsGET2QueryKey(dto: SiteSectionsGET2QueryParameters): QueryKey;
export function siteSectionsGET2QueryKey(filters_Id: number | undefined, filters_Name: string | undefined, filters_GameName: string | undefined, filters_Hidden: boolean | undefined, sorts_Id: Types.EnumFieldSort | undefined, sorts_GameName: Types.EnumFieldSort | undefined, sorts_Name: Types.EnumFieldSort | undefined, sorts_Hidden: Types.EnumFieldSort | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function siteSectionsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filters_Id, filters_Name, filters_GameName, filters_Hidden, sorts_Id, sorts_GameName, sorts_Name, sorts_Hidden, pageNo, pageSize,  } = params[0] as SiteSectionsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'siteSectionsGET2',
        filters_Id as any,
        filters_Name as any,
        filters_GameName as any,
        filters_Hidden as any,
        sorts_Id as any,
        sorts_GameName as any,
        sorts_Name as any,
        sorts_Hidden as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'siteSectionsGET2',
        ...params
      ]);
  }
}
function __siteSectionsGET2(context: QueryFunctionContext) {
  return Client().siteSectionsGET2(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as boolean | undefined,       context.queryKey[6] as Types.EnumFieldSort | undefined,       context.queryKey[7] as Types.EnumFieldSort | undefined,       context.queryKey[8] as Types.EnumFieldSort | undefined,       context.queryKey[9] as Types.EnumFieldSort | undefined,       context.queryKey[10] as number | undefined,       context.queryKey[11] as number | undefined    );
}

export function useSiteSectionsGET2Query<TSelectData = Types.GetSiteSectionsRespApiRespBase, TError = unknown>(dto: SiteSectionsGET2QueryParameters, options?: UseQueryOptions<Types.GetSiteSectionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get Site-Sections
 * @param filters_Id (optional) 
 * @param filters_Name (optional) 
 * @param filters_GameName (optional) 
 * @param filters_Hidden (optional) 
 * @param sorts_Id (optional) 
 * @param sorts_GameName (optional) 
 * @param sorts_Name (optional) 
 * @param sorts_Hidden (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useSiteSectionsGET2Query<TSelectData = Types.GetSiteSectionsRespApiRespBase, TError = unknown>(filters_Id: number | undefined, filters_Name: string | undefined, filters_GameName: string | undefined, filters_Hidden: boolean | undefined, sorts_Id: Types.EnumFieldSort | undefined, sorts_GameName: Types.EnumFieldSort | undefined, sorts_Name: Types.EnumFieldSort | undefined, sorts_Hidden: Types.EnumFieldSort | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetSiteSectionsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSiteSectionsGET2Query<TSelectData = Types.GetSiteSectionsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetSiteSectionsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let filters_Id: any = undefined;
  let filters_Name: any = undefined;
  let filters_GameName: any = undefined;
  let filters_Hidden: any = undefined;
  let sorts_Id: any = undefined;
  let sorts_GameName: any = undefined;
  let sorts_Name: any = undefined;
  let sorts_Hidden: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filters_Id, filters_Name, filters_GameName, filters_Hidden, sorts_Id, sorts_GameName, sorts_Name, sorts_Hidden, pageNo, pageSize,  } = params[0] as SiteSectionsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filters_Id, filters_Name, filters_GameName, filters_Hidden, sorts_Id, sorts_GameName, sorts_Name, sorts_Hidden, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetSiteSectionsRespApiRespBase, TError, TSelectData>({
    queryFn: __siteSectionsGET2,
    queryKey: siteSectionsGET2QueryKey(filters_Id, filters_Name, filters_GameName, filters_Hidden, sorts_Id, sorts_GameName, sorts_Name, sorts_Hidden, pageNo, pageSize),
    ...siteSectionsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetSiteSectionsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Site-Sections
 * @param filters_Id (optional) 
 * @param filters_Name (optional) 
 * @param filters_GameName (optional) 
 * @param filters_Hidden (optional) 
 * @param sorts_Id (optional) 
 * @param sorts_GameName (optional) 
 * @param sorts_Name (optional) 
 * @param sorts_Hidden (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setSiteSectionsGET2Data(queryClient: QueryClient, updater: (data: Types.GetSiteSectionsRespApiRespBase | undefined) => Types.GetSiteSectionsRespApiRespBase, filters_Id: number | undefined, filters_Name: string | undefined, filters_GameName: string | undefined, filters_Hidden: boolean | undefined, sorts_Id: Types.EnumFieldSort | undefined, sorts_GameName: Types.EnumFieldSort | undefined, sorts_Name: Types.EnumFieldSort | undefined, sorts_Hidden: Types.EnumFieldSort | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(siteSectionsGET2QueryKey(filters_Id, filters_Name, filters_GameName, filters_Hidden, sorts_Id, sorts_GameName, sorts_Name, sorts_Hidden, pageNo, pageSize),
    updater
  );
}

/**
 * Get Site-Sections
 * @param filters_Id (optional) 
 * @param filters_Name (optional) 
 * @param filters_GameName (optional) 
 * @param filters_Hidden (optional) 
 * @param sorts_Id (optional) 
 * @param sorts_GameName (optional) 
 * @param sorts_Name (optional) 
 * @param sorts_Hidden (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setSiteSectionsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetSiteSectionsRespApiRespBase | undefined) => Types.GetSiteSectionsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function siteSectionsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/sitesections/site-sections";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function siteSectionsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'siteSectionsPOST',
    ]);
}

/**
 * Add Site-Sections
 * @param gameId (optional) 
 * @param name (optional) 
 * @param hidden (optional) 
 * @param position (optional) 
 * @param headerImage (optional) 
 * @param backGroundImage (optional) 
 * @param iconImage (optional) 
 * @param logoImage (optional) 
 * @return Error
 */
export function useSiteSectionsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddSiteSectionsRespApiRespBase, unknown, SiteSectionsPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddSiteSectionsRespApiRespBase, unknown, SiteSectionsPOSTMutationParameters, TContext> {
  const key = siteSectionsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((siteSectionsPOSTMutationParameters: SiteSectionsPOSTMutationParameters) => Client().siteSectionsPOST(siteSectionsPOSTMutationParameters.gameId, siteSectionsPOSTMutationParameters.name, siteSectionsPOSTMutationParameters.hidden, siteSectionsPOSTMutationParameters.position, siteSectionsPOSTMutationParameters.headerImage, siteSectionsPOSTMutationParameters.backGroundImage, siteSectionsPOSTMutationParameters.iconImage, siteSectionsPOSTMutationParameters.logoImage), {...options, mutationKey: key});
}
  
    
export function siteSectionsGET3Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/sitesections/site-sections/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let siteSectionsGET3DefaultOptions: UseQueryOptions<Types.GetSiteSectionRespApiRespBase, unknown, Types.GetSiteSectionRespApiRespBase> = {
  queryFn: __siteSectionsGET3,
};
export function getSiteSectionsGET3DefaultOptions(): UseQueryOptions<Types.GetSiteSectionRespApiRespBase, unknown, Types.GetSiteSectionRespApiRespBase> {
  return siteSectionsGET3DefaultOptions;
};
export function setSiteSectionsGET3DefaultOptions(options: UseQueryOptions<Types.GetSiteSectionRespApiRespBase, unknown, Types.GetSiteSectionRespApiRespBase>) {
  siteSectionsGET3DefaultOptions = options;
}

export function siteSectionsGET3QueryKey(id: number): QueryKey;
export function siteSectionsGET3QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as SiteSectionsGET3QueryParameters;

    return trimArrayEnd([
        'Client',
        'siteSectionsGET3',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'siteSectionsGET3',
        ...params
      ]);
  }
}
function __siteSectionsGET3(context: QueryFunctionContext) {
  return Client().siteSectionsGET3(
      context.queryKey[2] as number    );
}

export function useSiteSectionsGET3Query<TSelectData = Types.GetSiteSectionRespApiRespBase, TError = unknown>(dto: SiteSectionsGET3QueryParameters, options?: UseQueryOptions<Types.GetSiteSectionRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get Site-Section
 * @param id SiteSectionId
 * @return Error
 */
export function useSiteSectionsGET3Query<TSelectData = Types.GetSiteSectionRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetSiteSectionRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSiteSectionsGET3Query<TSelectData = Types.GetSiteSectionRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetSiteSectionRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as SiteSectionsGET3QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetSiteSectionRespApiRespBase, TError, TSelectData>({
    queryFn: __siteSectionsGET3,
    queryKey: siteSectionsGET3QueryKey(id),
    ...siteSectionsGET3DefaultOptions as unknown as UseQueryOptions<Types.GetSiteSectionRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Site-Section
 * @param id SiteSectionId
 * @return Error
 */
export function setSiteSectionsGET3Data(queryClient: QueryClient, updater: (data: Types.GetSiteSectionRespApiRespBase | undefined) => Types.GetSiteSectionRespApiRespBase, id: number) {
  queryClient.setQueryData(siteSectionsGET3QueryKey(id),
    updater
  );
}

/**
 * Get Site-Section
 * @param id SiteSectionId
 * @return Error
 */
export function setSiteSectionsGET3DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetSiteSectionRespApiRespBase | undefined) => Types.GetSiteSectionRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function siteSectionsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/sitesections/site-sections/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function siteSectionsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'siteSectionsPATCH',
      id as any,
    ]);
}

/**
 * Modify Site-Sections
 * @param id SiteSectionId
 * @param id (optional) 
 * @param gameId (optional) 
 * @param name (optional) 
 * @param hidden (optional) 
 * @param position (optional) 
 * @param headerImage (optional) 
 * @param backGroundImage (optional) 
 * @param iconImage (optional) 
 * @param logoImage (optional) 
 * @return Error
 */
export function useSiteSectionsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModSiteSectionsRespApiRespBase, unknown, SiteSectionsPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModSiteSectionsRespApiRespBase, unknown, SiteSectionsPATCHMutationParameters, TContext> {
  const key = siteSectionsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((siteSectionsPATCHMutationParameters: SiteSectionsPATCHMutationParameters) => Client().siteSectionsPATCH(id, siteSectionsPATCHMutationParameters.id, siteSectionsPATCHMutationParameters.gameId, siteSectionsPATCHMutationParameters.name, siteSectionsPATCHMutationParameters.hidden, siteSectionsPATCHMutationParameters.position, siteSectionsPATCHMutationParameters.headerImage, siteSectionsPATCHMutationParameters.backGroundImage, siteSectionsPATCHMutationParameters.iconImage, siteSectionsPATCHMutationParameters.logoImage), {...options, mutationKey: key});
}
  
    
export function siteSectionsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/sitesections/site-sections/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function siteSectionsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'siteSectionsDELETE',
      id as any,
    ]);
}

/**
 * Delete Site-Sections
 * @param id SiteSectionId
 * @return Error
 */
export function useSiteSectionsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelSiteSectionsRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelSiteSectionsRespApiRespBase, unknown, void, TContext> {
  const key = siteSectionsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().siteSectionsDELETE(id), {...options, mutationKey: key});
}
  
    
export function sponsorsGETUrl(name: string | undefined, website: string | undefined, creator: string | undefined, updatedFrom: number | undefined, updatedTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/sponsors?";
if (name === null)
    throw new Error("The parameter 'name' cannot be null.");
else if (name !== undefined)
    url_ += "Name=" + encodeURIComponent("" + name) + "&";
if (website === null)
    throw new Error("The parameter 'website' cannot be null.");
else if (website !== undefined)
    url_ += "Website=" + encodeURIComponent("" + website) + "&";
if (creator === null)
    throw new Error("The parameter 'creator' cannot be null.");
else if (creator !== undefined)
    url_ += "Creator=" + encodeURIComponent("" + creator) + "&";
if (updatedFrom === null)
    throw new Error("The parameter 'updatedFrom' cannot be null.");
else if (updatedFrom !== undefined)
    url_ += "UpdatedFrom=" + encodeURIComponent("" + updatedFrom) + "&";
if (updatedTo === null)
    throw new Error("The parameter 'updatedTo' cannot be null.");
else if (updatedTo !== undefined)
    url_ += "UpdatedTo=" + encodeURIComponent("" + updatedTo) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let sponsorsGETDefaultOptions: UseQueryOptions<Types.GetSponsorsRespApiRespBase, unknown, Types.GetSponsorsRespApiRespBase> = {
  queryFn: __sponsorsGET,
};
export function getSponsorsGETDefaultOptions(): UseQueryOptions<Types.GetSponsorsRespApiRespBase, unknown, Types.GetSponsorsRespApiRespBase> {
  return sponsorsGETDefaultOptions;
};
export function setSponsorsGETDefaultOptions(options: UseQueryOptions<Types.GetSponsorsRespApiRespBase, unknown, Types.GetSponsorsRespApiRespBase>) {
  sponsorsGETDefaultOptions = options;
}

export function sponsorsGETQueryKey(dto: SponsorsGETQueryParameters): QueryKey;
export function sponsorsGETQueryKey(name: string | undefined, website: string | undefined, creator: string | undefined, updatedFrom: number | undefined, updatedTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function sponsorsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { name, website, creator, updatedFrom, updatedTo, pageNo, pageSize,  } = params[0] as SponsorsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'sponsorsGET',
        name as any,
        website as any,
        creator as any,
        updatedFrom as any,
        updatedTo as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'sponsorsGET',
        ...params
      ]);
  }
}
function __sponsorsGET(context: QueryFunctionContext) {
  return Client().sponsorsGET(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as string | undefined,       context.queryKey[4] as string | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as number | undefined,       context.queryKey[7] as number | undefined,       context.queryKey[8] as number | undefined    );
}

export function useSponsorsGETQuery<TSelectData = Types.GetSponsorsRespApiRespBase, TError = unknown>(dto: SponsorsGETQueryParameters, options?: UseQueryOptions<Types.GetSponsorsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get tournaments sponsors by condition
 * @param name (optional) Sponsor Name
 * @param website (optional) Sponsor Url
 * @param creator (optional) Creator
 * @param updatedFrom (optional) Last Updated From
 * @param updatedTo (optional) Last Updated To
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useSponsorsGETQuery<TSelectData = Types.GetSponsorsRespApiRespBase, TError = unknown>(name: string | undefined, website: string | undefined, creator: string | undefined, updatedFrom: number | undefined, updatedTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetSponsorsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSponsorsGETQuery<TSelectData = Types.GetSponsorsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetSponsorsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let name: any = undefined;
  let website: any = undefined;
  let creator: any = undefined;
  let updatedFrom: any = undefined;
  let updatedTo: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ name, website, creator, updatedFrom, updatedTo, pageNo, pageSize,  } = params[0] as SponsorsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [name, website, creator, updatedFrom, updatedTo, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetSponsorsRespApiRespBase, TError, TSelectData>({
    queryFn: __sponsorsGET,
    queryKey: sponsorsGETQueryKey(name, website, creator, updatedFrom, updatedTo, pageNo, pageSize),
    ...sponsorsGETDefaultOptions as unknown as UseQueryOptions<Types.GetSponsorsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get tournaments sponsors by condition
 * @param name (optional) Sponsor Name
 * @param website (optional) Sponsor Url
 * @param creator (optional) Creator
 * @param updatedFrom (optional) Last Updated From
 * @param updatedTo (optional) Last Updated To
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setSponsorsGETData(queryClient: QueryClient, updater: (data: Types.GetSponsorsRespApiRespBase | undefined) => Types.GetSponsorsRespApiRespBase, name: string | undefined, website: string | undefined, creator: string | undefined, updatedFrom: number | undefined, updatedTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(sponsorsGETQueryKey(name, website, creator, updatedFrom, updatedTo, pageNo, pageSize),
    updater
  );
}

/**
 * Get tournaments sponsors by condition
 * @param name (optional) Sponsor Name
 * @param website (optional) Sponsor Url
 * @param creator (optional) Creator
 * @param updatedFrom (optional) Last Updated From
 * @param updatedTo (optional) Last Updated To
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setSponsorsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetSponsorsRespApiRespBase | undefined) => Types.GetSponsorsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function sponsorsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/sponsors";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function sponsorsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'sponsorsPOST',
    ]);
}

/**
 * Add new Tournaments Sponsor
 * @param name (optional) Sponsor Name
 * @param description (optional) Sponsor Description
 * @param imageFile (optional) Sponsor Logo
 * @param url (optional) Sponsor website url
 * @return Error
 */
export function useSponsorsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddSponsorRespApiRespBase, unknown, SponsorsPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddSponsorRespApiRespBase, unknown, SponsorsPOSTMutationParameters, TContext> {
  const key = sponsorsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((sponsorsPOSTMutationParameters: SponsorsPOSTMutationParameters) => Client().sponsorsPOST(sponsorsPOSTMutationParameters.name, sponsorsPOSTMutationParameters.description, sponsorsPOSTMutationParameters.imageFile, sponsorsPOSTMutationParameters.url), {...options, mutationKey: key});
}
  
    
export function sponsorsGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/sponsors/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let sponsorsGET2DefaultOptions: UseQueryOptions<Types.GetSponsorRespApiRespBase, unknown, Types.GetSponsorRespApiRespBase> = {
  queryFn: __sponsorsGET2,
};
export function getSponsorsGET2DefaultOptions(): UseQueryOptions<Types.GetSponsorRespApiRespBase, unknown, Types.GetSponsorRespApiRespBase> {
  return sponsorsGET2DefaultOptions;
};
export function setSponsorsGET2DefaultOptions(options: UseQueryOptions<Types.GetSponsorRespApiRespBase, unknown, Types.GetSponsorRespApiRespBase>) {
  sponsorsGET2DefaultOptions = options;
}

export function sponsorsGET2QueryKey(id: number): QueryKey;
export function sponsorsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as SponsorsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'sponsorsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'sponsorsGET2',
        ...params
      ]);
  }
}
function __sponsorsGET2(context: QueryFunctionContext) {
  return Client().sponsorsGET2(
      context.queryKey[2] as number    );
}

export function useSponsorsGET2Query<TSelectData = Types.GetSponsorRespApiRespBase, TError = unknown>(dto: SponsorsGET2QueryParameters, options?: UseQueryOptions<Types.GetSponsorRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get Tournaments Sponsor
 * @param id Sponsors Id
 * @return Error
 */
export function useSponsorsGET2Query<TSelectData = Types.GetSponsorRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetSponsorRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSponsorsGET2Query<TSelectData = Types.GetSponsorRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetSponsorRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as SponsorsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetSponsorRespApiRespBase, TError, TSelectData>({
    queryFn: __sponsorsGET2,
    queryKey: sponsorsGET2QueryKey(id),
    ...sponsorsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetSponsorRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get Tournaments Sponsor
 * @param id Sponsors Id
 * @return Error
 */
export function setSponsorsGET2Data(queryClient: QueryClient, updater: (data: Types.GetSponsorRespApiRespBase | undefined) => Types.GetSponsorRespApiRespBase, id: number) {
  queryClient.setQueryData(sponsorsGET2QueryKey(id),
    updater
  );
}

/**
 * Get Tournaments Sponsor
 * @param id Sponsors Id
 * @return Error
 */
export function setSponsorsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetSponsorRespApiRespBase | undefined) => Types.GetSponsorRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function sponsorsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/sponsors/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function sponsorsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'sponsorsPATCH',
      id as any,
    ]);
}

/**
 * Modify Tournaments Sponsor
 * @param id Tournaments Sponsor Id
 * @param id (optional) Sponsor Id
 * @param name (optional) Sponsor Name
 * @param description (optional) Sponsor Description
 * @param imageFile (optional) Sponsor Logo
 * @param url (optional) Sponsor website url
 * @return Error
 */
export function useSponsorsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModSponsorRespApiRespBase, unknown, SponsorsPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModSponsorRespApiRespBase, unknown, SponsorsPATCHMutationParameters, TContext> {
  const key = sponsorsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((sponsorsPATCHMutationParameters: SponsorsPATCHMutationParameters) => Client().sponsorsPATCH(id, sponsorsPATCHMutationParameters.id, sponsorsPATCHMutationParameters.name, sponsorsPATCHMutationParameters.description, sponsorsPATCHMutationParameters.imageFile, sponsorsPATCHMutationParameters.url), {...options, mutationKey: key});
}
  
    
export function sponsorsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/sponsors/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function sponsorsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'sponsorsDELETE',
      id as any,
    ]);
}

/**
 * Delete Tournaments Sponsor
 * @param id Tournaments Sponsor Id
 * @return Error
 */
export function useSponsorsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelSponsorRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelSponsorRespApiRespBase, unknown, void, TContext> {
  const key = sponsorsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().sponsorsDELETE(id), {...options, mutationKey: key});
}
  
    
export function teamsGETUrl(teamName: string | undefined, teamId: number | undefined, playerId: number | undefined, gameId: number | undefined, countryId: number | undefined, updatedAtFrom: number | undefined, updatedAtTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/teams?";
if (teamName === null)
    throw new Error("The parameter 'teamName' cannot be null.");
else if (teamName !== undefined)
    url_ += "TeamName=" + encodeURIComponent("" + teamName) + "&";
if (teamId === null)
    throw new Error("The parameter 'teamId' cannot be null.");
else if (teamId !== undefined)
    url_ += "TeamId=" + encodeURIComponent("" + teamId) + "&";
if (playerId === null)
    throw new Error("The parameter 'playerId' cannot be null.");
else if (playerId !== undefined)
    url_ += "PlayerId=" + encodeURIComponent("" + playerId) + "&";
if (gameId === null)
    throw new Error("The parameter 'gameId' cannot be null.");
else if (gameId !== undefined)
    url_ += "GameId=" + encodeURIComponent("" + gameId) + "&";
if (countryId === null)
    throw new Error("The parameter 'countryId' cannot be null.");
else if (countryId !== undefined)
    url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
if (updatedAtFrom === null)
    throw new Error("The parameter 'updatedAtFrom' cannot be null.");
else if (updatedAtFrom !== undefined)
    url_ += "UpdatedAtFrom=" + encodeURIComponent("" + updatedAtFrom) + "&";
if (updatedAtTo === null)
    throw new Error("The parameter 'updatedAtTo' cannot be null.");
else if (updatedAtTo !== undefined)
    url_ += "UpdatedAtTo=" + encodeURIComponent("" + updatedAtTo) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let teamsGETDefaultOptions: UseQueryOptions<Types.GetTeamsRespApiRespBase, unknown, Types.GetTeamsRespApiRespBase> = {
  queryFn: __teamsGET,
};
export function getTeamsGETDefaultOptions(): UseQueryOptions<Types.GetTeamsRespApiRespBase, unknown, Types.GetTeamsRespApiRespBase> {
  return teamsGETDefaultOptions;
};
export function setTeamsGETDefaultOptions(options: UseQueryOptions<Types.GetTeamsRespApiRespBase, unknown, Types.GetTeamsRespApiRespBase>) {
  teamsGETDefaultOptions = options;
}

export function teamsGETQueryKey(dto: TeamsGETQueryParameters): QueryKey;
export function teamsGETQueryKey(teamName: string | undefined, teamId: number | undefined, playerId: number | undefined, gameId: number | undefined, countryId: number | undefined, updatedAtFrom: number | undefined, updatedAtTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function teamsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { teamName, teamId, playerId, gameId, countryId, updatedAtFrom, updatedAtTo, pageNo, pageSize,  } = params[0] as TeamsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'teamsGET',
        teamName as any,
        teamId as any,
        playerId as any,
        gameId as any,
        countryId as any,
        updatedAtFrom as any,
        updatedAtTo as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'teamsGET',
        ...params
      ]);
  }
}
function __teamsGET(context: QueryFunctionContext) {
  return Client().teamsGET(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as number | undefined,       context.queryKey[6] as number | undefined,       context.queryKey[7] as number | undefined,       context.queryKey[8] as number | undefined,       context.queryKey[9] as number | undefined,       context.queryKey[10] as number | undefined    );
}

export function useTeamsGETQuery<TSelectData = Types.GetTeamsRespApiRespBase, TError = unknown>(dto: TeamsGETQueryParameters, options?: UseQueryOptions<Types.GetTeamsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get teams
 * @param teamName (optional) TeamName
 * @param teamId (optional) Team Id
 * @param playerId (optional) Player Id
 * @param gameId (optional) Game Id
 * @param countryId (optional) Country Id
 * @param updatedAtFrom (optional) Created at from
 * @param updatedAtTo (optional) Created at to
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useTeamsGETQuery<TSelectData = Types.GetTeamsRespApiRespBase, TError = unknown>(teamName: string | undefined, teamId: number | undefined, playerId: number | undefined, gameId: number | undefined, countryId: number | undefined, updatedAtFrom: number | undefined, updatedAtTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetTeamsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTeamsGETQuery<TSelectData = Types.GetTeamsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetTeamsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let teamName: any = undefined;
  let teamId: any = undefined;
  let playerId: any = undefined;
  let gameId: any = undefined;
  let countryId: any = undefined;
  let updatedAtFrom: any = undefined;
  let updatedAtTo: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ teamName, teamId, playerId, gameId, countryId, updatedAtFrom, updatedAtTo, pageNo, pageSize,  } = params[0] as TeamsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [teamName, teamId, playerId, gameId, countryId, updatedAtFrom, updatedAtTo, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetTeamsRespApiRespBase, TError, TSelectData>({
    queryFn: __teamsGET,
    queryKey: teamsGETQueryKey(teamName, teamId, playerId, gameId, countryId, updatedAtFrom, updatedAtTo, pageNo, pageSize),
    ...teamsGETDefaultOptions as unknown as UseQueryOptions<Types.GetTeamsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get teams
 * @param teamName (optional) TeamName
 * @param teamId (optional) Team Id
 * @param playerId (optional) Player Id
 * @param gameId (optional) Game Id
 * @param countryId (optional) Country Id
 * @param updatedAtFrom (optional) Created at from
 * @param updatedAtTo (optional) Created at to
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setTeamsGETData(queryClient: QueryClient, updater: (data: Types.GetTeamsRespApiRespBase | undefined) => Types.GetTeamsRespApiRespBase, teamName: string | undefined, teamId: number | undefined, playerId: number | undefined, gameId: number | undefined, countryId: number | undefined, updatedAtFrom: number | undefined, updatedAtTo: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(teamsGETQueryKey(teamName, teamId, playerId, gameId, countryId, updatedAtFrom, updatedAtTo, pageNo, pageSize),
    updater
  );
}

/**
 * Get teams
 * @param teamName (optional) TeamName
 * @param teamId (optional) Team Id
 * @param playerId (optional) Player Id
 * @param gameId (optional) Game Id
 * @param countryId (optional) Country Id
 * @param updatedAtFrom (optional) Created at from
 * @param updatedAtTo (optional) Created at to
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setTeamsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetTeamsRespApiRespBase | undefined) => Types.GetTeamsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function teamsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/teams";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function teamsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'teamsPOST',
    ]);
}

/**
 * Add team
 * @param teamName (optional) 
 * @param teamTag (optional) 
 * @param gameId (optional) 
 * @param countryId (optional) 
 * @param image (optional) 
 * @param description (optional) 
 * @param initialRating (optional) 
 * @param excludeRankings (optional) 
 * @param facebook (optional) 
 * @param twitter (optional) 
 * @param youtube (optional) 
 * @return Error
 */
export function useTeamsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddTeamRespApiRespBase, unknown, TeamsPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddTeamRespApiRespBase, unknown, TeamsPOSTMutationParameters, TContext> {
  const key = teamsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((teamsPOSTMutationParameters: TeamsPOSTMutationParameters) => Client().teamsPOST(teamsPOSTMutationParameters.teamName, teamsPOSTMutationParameters.teamTag, teamsPOSTMutationParameters.gameId, teamsPOSTMutationParameters.countryId, teamsPOSTMutationParameters.image, teamsPOSTMutationParameters.description, teamsPOSTMutationParameters.initialRating, teamsPOSTMutationParameters.excludeRankings, teamsPOSTMutationParameters.facebook, teamsPOSTMutationParameters.twitter, teamsPOSTMutationParameters.youtube), {...options, mutationKey: key});
}
  
    
export function teamsGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/teams/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let teamsGET2DefaultOptions: UseQueryOptions<Types.GetTeamRespApiRespBase, unknown, Types.GetTeamRespApiRespBase> = {
  queryFn: __teamsGET2,
};
export function getTeamsGET2DefaultOptions(): UseQueryOptions<Types.GetTeamRespApiRespBase, unknown, Types.GetTeamRespApiRespBase> {
  return teamsGET2DefaultOptions;
};
export function setTeamsGET2DefaultOptions(options: UseQueryOptions<Types.GetTeamRespApiRespBase, unknown, Types.GetTeamRespApiRespBase>) {
  teamsGET2DefaultOptions = options;
}

export function teamsGET2QueryKey(id: number): QueryKey;
export function teamsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as TeamsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'teamsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'teamsGET2',
        ...params
      ]);
  }
}
function __teamsGET2(context: QueryFunctionContext) {
  return Client().teamsGET2(
      context.queryKey[2] as number    );
}

export function useTeamsGET2Query<TSelectData = Types.GetTeamRespApiRespBase, TError = unknown>(dto: TeamsGET2QueryParameters, options?: UseQueryOptions<Types.GetTeamRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get team
 * @param id TeamId
 * @return Error
 */
export function useTeamsGET2Query<TSelectData = Types.GetTeamRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetTeamRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTeamsGET2Query<TSelectData = Types.GetTeamRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetTeamRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as TeamsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetTeamRespApiRespBase, TError, TSelectData>({
    queryFn: __teamsGET2,
    queryKey: teamsGET2QueryKey(id),
    ...teamsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetTeamRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get team
 * @param id TeamId
 * @return Error
 */
export function setTeamsGET2Data(queryClient: QueryClient, updater: (data: Types.GetTeamRespApiRespBase | undefined) => Types.GetTeamRespApiRespBase, id: number) {
  queryClient.setQueryData(teamsGET2QueryKey(id),
    updater
  );
}

/**
 * Get team
 * @param id TeamId
 * @return Error
 */
export function setTeamsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetTeamRespApiRespBase | undefined) => Types.GetTeamRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function teamsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/teams/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function teamsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'teamsPATCH',
      id as any,
    ]);
}

/**
 * Modify team
 * @param id TeamId
 * @param teamId (optional) 
 * @param teamName (optional) 
 * @param teamTag (optional) 
 * @param ownerId (optional) OwnerId
 * @param captainId (optional) CaptainId
 * @param manageId (optional) ManageId
 * @param excludedRankings (optional) 
 * @param image (optional) 
 * @param isRemoveImage (optional) if IsRemoveImage = true will remove Image and set ImageFilePath = null
 * @param gameId (optional) 
 * @param countryId (optional) 
 * @param description (optional) 
 * @param facebook (optional) 
 * @param twitter (optional) 
 * @param youtube (optional) 
 * @return Error
 */
export function useTeamsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModTeamRespApiRespBase, unknown, TeamsPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModTeamRespApiRespBase, unknown, TeamsPATCHMutationParameters, TContext> {
  const key = teamsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((teamsPATCHMutationParameters: TeamsPATCHMutationParameters) => Client().teamsPATCH(id, teamsPATCHMutationParameters.teamId, teamsPATCHMutationParameters.teamName, teamsPATCHMutationParameters.teamTag, teamsPATCHMutationParameters.ownerId, teamsPATCHMutationParameters.captainId, teamsPATCHMutationParameters.manageId, teamsPATCHMutationParameters.excludedRankings, teamsPATCHMutationParameters.image, teamsPATCHMutationParameters.isRemoveImage, teamsPATCHMutationParameters.gameId, teamsPATCHMutationParameters.countryId, teamsPATCHMutationParameters.description, teamsPATCHMutationParameters.facebook, teamsPATCHMutationParameters.twitter, teamsPATCHMutationParameters.youtube), {...options, mutationKey: key});
}
  
    
export function teamsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/teams/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function teamsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'teamsDELETE',
      id as any,
    ]);
}

/**
 * Delete team
 * @param id TeamId
 * @return Error
 */
export function useTeamsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelTeamRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelTeamRespApiRespBase, unknown, void, TContext> {
  const key = teamsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().teamsDELETE(id), {...options, mutationKey: key});
}
  
    
export function teamPlayersGETUrl(teamid: number, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/teams/{teamid}/team-players?";
if (teamid === undefined || teamid === null)
  throw new Error("The parameter 'teamid' must be defined.");
url_ = url_.replace("{teamid}", encodeURIComponent("" + teamid));
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let teamPlayersGETDefaultOptions: UseQueryOptions<Types.GetTeamPlayersRespApiRespBase, unknown, Types.GetTeamPlayersRespApiRespBase> = {
  queryFn: __teamPlayersGET,
};
export function getTeamPlayersGETDefaultOptions(): UseQueryOptions<Types.GetTeamPlayersRespApiRespBase, unknown, Types.GetTeamPlayersRespApiRespBase> {
  return teamPlayersGETDefaultOptions;
};
export function setTeamPlayersGETDefaultOptions(options: UseQueryOptions<Types.GetTeamPlayersRespApiRespBase, unknown, Types.GetTeamPlayersRespApiRespBase>) {
  teamPlayersGETDefaultOptions = options;
}

export function teamPlayersGETQueryKey(dto: TeamPlayersGETQueryParameters): QueryKey;
export function teamPlayersGETQueryKey(teamid: number, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function teamPlayersGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { teamid, pageNo, pageSize,  } = params[0] as TeamPlayersGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'teamPlayersGET',
        teamid as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'teamPlayersGET',
        ...params
      ]);
  }
}
function __teamPlayersGET(context: QueryFunctionContext) {
  return Client().teamPlayersGET(
      context.queryKey[2] as number,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined    );
}

export function useTeamPlayersGETQuery<TSelectData = Types.GetTeamPlayersRespApiRespBase, TError = unknown>(dto: TeamPlayersGETQueryParameters, options?: UseQueryOptions<Types.GetTeamPlayersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get team players
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useTeamPlayersGETQuery<TSelectData = Types.GetTeamPlayersRespApiRespBase, TError = unknown>(teamid: number, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetTeamPlayersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTeamPlayersGETQuery<TSelectData = Types.GetTeamPlayersRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetTeamPlayersRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let teamid: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ teamid, pageNo, pageSize,  } = params[0] as TeamPlayersGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [teamid, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetTeamPlayersRespApiRespBase, TError, TSelectData>({
    queryFn: __teamPlayersGET,
    queryKey: teamPlayersGETQueryKey(teamid, pageNo, pageSize),
    ...teamPlayersGETDefaultOptions as unknown as UseQueryOptions<Types.GetTeamPlayersRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get team players
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setTeamPlayersGETData(queryClient: QueryClient, updater: (data: Types.GetTeamPlayersRespApiRespBase | undefined) => Types.GetTeamPlayersRespApiRespBase, teamid: number, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(teamPlayersGETQueryKey(teamid, pageNo, pageSize),
    updater
  );
}

/**
 * Get team players
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setTeamPlayersGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetTeamPlayersRespApiRespBase | undefined) => Types.GetTeamPlayersRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function teamPlayersPOSTUrl(teamid: number): string {
  let url_ = getBaseUrl() + "/api/v4/teams/{teamid}/team-players";
if (teamid === undefined || teamid === null)
  throw new Error("The parameter 'teamid' must be defined.");
url_ = url_.replace("{teamid}", encodeURIComponent("" + teamid));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function teamPlayersPOSTMutationKey(teamid: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'teamPlayersPOST',
      teamid as any,
    ]);
}

/**
 * Add team player
 * @param playerId (optional) 
 * @param joinedAt (optional) 
 * @param isHidden (optional) 
 * @return Error
 */
export function useTeamPlayersPOSTMutation<TContext>(teamid: number, options?: Omit<UseMutationOptions<Types.AddTeamPlayerRespApiRespBase, unknown, TeamPlayersPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddTeamPlayerRespApiRespBase, unknown, TeamPlayersPOSTMutationParameters, TContext> {
  const key = teamPlayersPOSTMutationKey(teamid);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((teamPlayersPOSTMutationParameters: TeamPlayersPOSTMutationParameters) => Client().teamPlayersPOST(teamid, teamPlayersPOSTMutationParameters.playerId, teamPlayersPOSTMutationParameters.joinedAt, teamPlayersPOSTMutationParameters.isHidden), {...options, mutationKey: key});
}
  
    
export function teamPlayersGET2Url(teamid: number, teamplayerid: number): string {
  let url_ = getBaseUrl() + "/api/v4/teams/{teamid}/team-players/{teamplayerid}";
if (teamid === undefined || teamid === null)
  throw new Error("The parameter 'teamid' must be defined.");
url_ = url_.replace("{teamid}", encodeURIComponent("" + teamid));
if (teamplayerid === undefined || teamplayerid === null)
  throw new Error("The parameter 'teamplayerid' must be defined.");
url_ = url_.replace("{teamplayerid}", encodeURIComponent("" + teamplayerid));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let teamPlayersGET2DefaultOptions: UseQueryOptions<Types.GetTeamPlayerRespApiRespBase, unknown, Types.GetTeamPlayerRespApiRespBase> = {
  queryFn: __teamPlayersGET2,
};
export function getTeamPlayersGET2DefaultOptions(): UseQueryOptions<Types.GetTeamPlayerRespApiRespBase, unknown, Types.GetTeamPlayerRespApiRespBase> {
  return teamPlayersGET2DefaultOptions;
};
export function setTeamPlayersGET2DefaultOptions(options: UseQueryOptions<Types.GetTeamPlayerRespApiRespBase, unknown, Types.GetTeamPlayerRespApiRespBase>) {
  teamPlayersGET2DefaultOptions = options;
}

export function teamPlayersGET2QueryKey(dto: TeamPlayersGET2QueryParameters): QueryKey;
export function teamPlayersGET2QueryKey(teamid: number, teamplayerid: number): QueryKey;
export function teamPlayersGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { teamid, teamplayerid,  } = params[0] as TeamPlayersGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'teamPlayersGET2',
        teamid as any,
        teamplayerid as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'teamPlayersGET2',
        ...params
      ]);
  }
}
function __teamPlayersGET2(context: QueryFunctionContext) {
  return Client().teamPlayersGET2(
      context.queryKey[2] as number,       context.queryKey[3] as number    );
}

export function useTeamPlayersGET2Query<TSelectData = Types.GetTeamPlayerRespApiRespBase, TError = unknown>(dto: TeamPlayersGET2QueryParameters, options?: UseQueryOptions<Types.GetTeamPlayerRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get team player
 * @return Error
 */
export function useTeamPlayersGET2Query<TSelectData = Types.GetTeamPlayerRespApiRespBase, TError = unknown>(teamid: number, teamplayerid: number, options?: UseQueryOptions<Types.GetTeamPlayerRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTeamPlayersGET2Query<TSelectData = Types.GetTeamPlayerRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetTeamPlayerRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let teamid: any = undefined;
  let teamplayerid: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ teamid, teamplayerid,  } = params[0] as TeamPlayersGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [teamid, teamplayerid, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetTeamPlayerRespApiRespBase, TError, TSelectData>({
    queryFn: __teamPlayersGET2,
    queryKey: teamPlayersGET2QueryKey(teamid, teamplayerid),
    ...teamPlayersGET2DefaultOptions as unknown as UseQueryOptions<Types.GetTeamPlayerRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get team player
 * @return Error
 */
export function setTeamPlayersGET2Data(queryClient: QueryClient, updater: (data: Types.GetTeamPlayerRespApiRespBase | undefined) => Types.GetTeamPlayerRespApiRespBase, teamid: number, teamplayerid: number) {
  queryClient.setQueryData(teamPlayersGET2QueryKey(teamid, teamplayerid),
    updater
  );
}

/**
 * Get team player
 * @return Error
 */
export function setTeamPlayersGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetTeamPlayerRespApiRespBase | undefined) => Types.GetTeamPlayerRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function teamPlayersPATCHUrl(teamid: number, teamplayerid: number): string {
  let url_ = getBaseUrl() + "/api/v4/teams/{teamid}/team-players/{teamplayerid}";
if (teamid === undefined || teamid === null)
  throw new Error("The parameter 'teamid' must be defined.");
url_ = url_.replace("{teamid}", encodeURIComponent("" + teamid));
if (teamplayerid === undefined || teamplayerid === null)
  throw new Error("The parameter 'teamplayerid' must be defined.");
url_ = url_.replace("{teamplayerid}", encodeURIComponent("" + teamplayerid));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function teamPlayersPATCHMutationKey(teamid: number, teamplayerid: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'teamPlayersPATCH',
      teamid as any,
      teamplayerid as any,
    ]);
}

/**
 * Modify team player
 * @param teamPlayerId (optional) TeamPlayerId
 * @param teamId (optional) TeamId
 * @param joinDate (optional) JoinDate
 * @param leaveDate (optional) LeaveDate
 * @param isHidden (optional) IsHidden
 * @return Error
 */
export function useTeamPlayersPATCHMutation<TContext>(teamid: number, teamplayerid: number, options?: Omit<UseMutationOptions<Types.ModTeamPlayerRespApiRespBase, unknown, TeamPlayersPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModTeamPlayerRespApiRespBase, unknown, TeamPlayersPATCHMutationParameters, TContext> {
  const key = teamPlayersPATCHMutationKey(teamid, teamplayerid);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((teamPlayersPATCHMutationParameters: TeamPlayersPATCHMutationParameters) => Client().teamPlayersPATCH(teamid, teamplayerid, teamPlayersPATCHMutationParameters.teamPlayerId, teamPlayersPATCHMutationParameters.teamId, teamPlayersPATCHMutationParameters.joinDate, teamPlayersPATCHMutationParameters.leaveDate, teamPlayersPATCHMutationParameters.isHidden), {...options, mutationKey: key});
}
  
    
export function teamPlayersDELETEUrl(teamid: number, teamplayerid: number): string {
  let url_ = getBaseUrl() + "/api/v4/teams/{teamid}/team-players/{teamplayerid}";
if (teamid === undefined || teamid === null)
  throw new Error("The parameter 'teamid' must be defined.");
url_ = url_.replace("{teamid}", encodeURIComponent("" + teamid));
if (teamplayerid === undefined || teamplayerid === null)
  throw new Error("The parameter 'teamplayerid' must be defined.");
url_ = url_.replace("{teamplayerid}", encodeURIComponent("" + teamplayerid));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function teamPlayersDELETEMutationKey(teamid: number, teamplayerid: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'teamPlayersDELETE',
      teamid as any,
      teamplayerid as any,
    ]);
}

/**
 * Delete team player
 * @return Error
 */
export function useTeamPlayersDELETEMutation<TContext>(teamid: number, teamplayerid: number, options?: Omit<UseMutationOptions<Types.DelTeamPlayerRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelTeamPlayerRespApiRespBase, unknown, void, TContext> {
  const key = teamPlayersDELETEMutationKey(teamid, teamplayerid);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().teamPlayersDELETE(teamid, teamplayerid), {...options, mutationKey: key});
}
  
    
export function fuzzy4Url(fuzzyPrefix: string, maxCount: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/teams/fuzzy?";
  if (fuzzyPrefix === undefined || fuzzyPrefix === null)
    throw new Error("The parameter 'fuzzyPrefix' must be defined and cannot be null.");
  else
    url_ += "FuzzyPrefix=" + encodeURIComponent("" + fuzzyPrefix) + "&";
if (maxCount === null)
    throw new Error("The parameter 'maxCount' cannot be null.");
else if (maxCount !== undefined)
    url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let fuzzy4DefaultOptions: UseQueryOptions<Types.GetFuzzyTeamsRespApiRespBase, unknown, Types.GetFuzzyTeamsRespApiRespBase> = {
  queryFn: __fuzzy4,
};
export function getFuzzy4DefaultOptions(): UseQueryOptions<Types.GetFuzzyTeamsRespApiRespBase, unknown, Types.GetFuzzyTeamsRespApiRespBase> {
  return fuzzy4DefaultOptions;
};
export function setFuzzy4DefaultOptions(options: UseQueryOptions<Types.GetFuzzyTeamsRespApiRespBase, unknown, Types.GetFuzzyTeamsRespApiRespBase>) {
  fuzzy4DefaultOptions = options;
}

export function fuzzy4QueryKey(dto: Fuzzy4QueryParameters): QueryKey;
export function fuzzy4QueryKey(fuzzyPrefix: string, maxCount: number | undefined): QueryKey;
export function fuzzy4QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { fuzzyPrefix, maxCount,  } = params[0] as Fuzzy4QueryParameters;

    return trimArrayEnd([
        'Client',
        'fuzzy4',
        fuzzyPrefix as any,
        maxCount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'fuzzy4',
        ...params
      ]);
  }
}
function __fuzzy4(context: QueryFunctionContext) {
  return Client().fuzzy4(
      context.queryKey[2] as string,       context.queryKey[3] as number | undefined    );
}

export function useFuzzy4Query<TSelectData = Types.GetFuzzyTeamsRespApiRespBase, TError = unknown>(dto: Fuzzy4QueryParameters, options?: UseQueryOptions<Types.GetFuzzyTeamsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get fuzzy teams
 * @param maxCount (optional) 
 * @return Error
 */
export function useFuzzy4Query<TSelectData = Types.GetFuzzyTeamsRespApiRespBase, TError = unknown>(fuzzyPrefix: string, maxCount: number | undefined, options?: UseQueryOptions<Types.GetFuzzyTeamsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFuzzy4Query<TSelectData = Types.GetFuzzyTeamsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuzzyTeamsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let fuzzyPrefix: any = undefined;
  let maxCount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ fuzzyPrefix, maxCount,  } = params[0] as Fuzzy4QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [fuzzyPrefix, maxCount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuzzyTeamsRespApiRespBase, TError, TSelectData>({
    queryFn: __fuzzy4,
    queryKey: fuzzy4QueryKey(fuzzyPrefix, maxCount),
    ...fuzzy4DefaultOptions as unknown as UseQueryOptions<Types.GetFuzzyTeamsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get fuzzy teams
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzy4Data(queryClient: QueryClient, updater: (data: Types.GetFuzzyTeamsRespApiRespBase | undefined) => Types.GetFuzzyTeamsRespApiRespBase, fuzzyPrefix: string, maxCount: number | undefined) {
  queryClient.setQueryData(fuzzy4QueryKey(fuzzyPrefix, maxCount),
    updater
  );
}

/**
 * Get fuzzy teams
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzy4DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuzzyTeamsRespApiRespBase | undefined) => Types.GetFuzzyTeamsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function clearAllMemoryCacheUrl(api_version: string | undefined): string {
  let url_ = getBaseUrl() + "/api/tools/clear-all-memory-cache?";
if (api_version === null)
    throw new Error("The parameter 'api_version' cannot be null.");
else if (api_version !== undefined)
    url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function clearAllMemoryCacheMutationKey(api_version: string | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'clearAllMemoryCache',
      api_version as any,
    ]);
}

/**
 * Clear All Memory Cache
 * @param api_version (optional) 
 * @return Success
 */
export function useClearAllMemoryCacheMutation<TContext>(api_version: string | undefined, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = clearAllMemoryCacheMutationKey(api_version);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().clearAllMemoryCache(api_version), {...options, mutationKey: key});
}
  
    
export function gameAccountsGETUrl(playerId: number, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/tournaments/game-accounts?";
  if (playerId === undefined || playerId === null)
    throw new Error("The parameter 'playerId' must be defined and cannot be null.");
  else
    url_ += "PlayerId=" + encodeURIComponent("" + playerId) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let gameAccountsGETDefaultOptions: UseQueryOptions<Types.GetGameAccountsRespApiRespBase, unknown, Types.GetGameAccountsRespApiRespBase> = {
  queryFn: __gameAccountsGET,
};
export function getGameAccountsGETDefaultOptions(): UseQueryOptions<Types.GetGameAccountsRespApiRespBase, unknown, Types.GetGameAccountsRespApiRespBase> {
  return gameAccountsGETDefaultOptions;
};
export function setGameAccountsGETDefaultOptions(options: UseQueryOptions<Types.GetGameAccountsRespApiRespBase, unknown, Types.GetGameAccountsRespApiRespBase>) {
  gameAccountsGETDefaultOptions = options;
}

export function gameAccountsGETQueryKey(dto: GameAccountsGETQueryParameters): QueryKey;
export function gameAccountsGETQueryKey(playerId: number, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function gameAccountsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { playerId, pageNo, pageSize,  } = params[0] as GameAccountsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'gameAccountsGET',
        playerId as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'gameAccountsGET',
        ...params
      ]);
  }
}
function __gameAccountsGET(context: QueryFunctionContext) {
  return Client().gameAccountsGET(
      context.queryKey[2] as number,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined    );
}

export function useGameAccountsGETQuery<TSelectData = Types.GetGameAccountsRespApiRespBase, TError = unknown>(dto: GameAccountsGETQueryParameters, options?: UseQueryOptions<Types.GetGameAccountsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get GameAccounts
 * @param playerId PlayerId
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useGameAccountsGETQuery<TSelectData = Types.GetGameAccountsRespApiRespBase, TError = unknown>(playerId: number, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetGameAccountsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGameAccountsGETQuery<TSelectData = Types.GetGameAccountsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGameAccountsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let playerId: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ playerId, pageNo, pageSize,  } = params[0] as GameAccountsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [playerId, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGameAccountsRespApiRespBase, TError, TSelectData>({
    queryFn: __gameAccountsGET,
    queryKey: gameAccountsGETQueryKey(playerId, pageNo, pageSize),
    ...gameAccountsGETDefaultOptions as unknown as UseQueryOptions<Types.GetGameAccountsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get GameAccounts
 * @param playerId PlayerId
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setGameAccountsGETData(queryClient: QueryClient, updater: (data: Types.GetGameAccountsRespApiRespBase | undefined) => Types.GetGameAccountsRespApiRespBase, playerId: number, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(gameAccountsGETQueryKey(playerId, pageNo, pageSize),
    updater
  );
}

/**
 * Get GameAccounts
 * @param playerId PlayerId
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setGameAccountsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGameAccountsRespApiRespBase | undefined) => Types.GetGameAccountsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gameAccountsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/tournaments/game-accounts";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function gameAccountsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'gameAccountsPOST',
    ]);
}

/**
 * Add GameAccount
 * @param playerId (optional) PlayerId
 * @param gameId (optional) GameId
 * @param serverId (optional) Server Id
 * @param gameAccountName (optional) GameAccount Name
 * @return Error
 */
export function useGameAccountsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddGameAccountRespApiRespBase, unknown, GameAccountsPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddGameAccountRespApiRespBase, unknown, GameAccountsPOSTMutationParameters, TContext> {
  const key = gameAccountsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((gameAccountsPOSTMutationParameters: GameAccountsPOSTMutationParameters) => Client().gameAccountsPOST(gameAccountsPOSTMutationParameters.playerId, gameAccountsPOSTMutationParameters.gameId, gameAccountsPOSTMutationParameters.serverId, gameAccountsPOSTMutationParameters.gameAccountName), {...options, mutationKey: key});
}
  
    
export function gameAccountsGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/tournaments/game-accounts/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let gameAccountsGET2DefaultOptions: UseQueryOptions<Types.GetGameAccountRespApiRespBase, unknown, Types.GetGameAccountRespApiRespBase> = {
  queryFn: __gameAccountsGET2,
};
export function getGameAccountsGET2DefaultOptions(): UseQueryOptions<Types.GetGameAccountRespApiRespBase, unknown, Types.GetGameAccountRespApiRespBase> {
  return gameAccountsGET2DefaultOptions;
};
export function setGameAccountsGET2DefaultOptions(options: UseQueryOptions<Types.GetGameAccountRespApiRespBase, unknown, Types.GetGameAccountRespApiRespBase>) {
  gameAccountsGET2DefaultOptions = options;
}

export function gameAccountsGET2QueryKey(id: number): QueryKey;
export function gameAccountsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GameAccountsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'gameAccountsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'gameAccountsGET2',
        ...params
      ]);
  }
}
function __gameAccountsGET2(context: QueryFunctionContext) {
  return Client().gameAccountsGET2(
      context.queryKey[2] as number    );
}

export function useGameAccountsGET2Query<TSelectData = Types.GetGameAccountRespApiRespBase, TError = unknown>(dto: GameAccountsGET2QueryParameters, options?: UseQueryOptions<Types.GetGameAccountRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get GameAccount
 * @param id GameAccountId
 * @return Error
 */
export function useGameAccountsGET2Query<TSelectData = Types.GetGameAccountRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetGameAccountRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGameAccountsGET2Query<TSelectData = Types.GetGameAccountRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetGameAccountRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GameAccountsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetGameAccountRespApiRespBase, TError, TSelectData>({
    queryFn: __gameAccountsGET2,
    queryKey: gameAccountsGET2QueryKey(id),
    ...gameAccountsGET2DefaultOptions as unknown as UseQueryOptions<Types.GetGameAccountRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get GameAccount
 * @param id GameAccountId
 * @return Error
 */
export function setGameAccountsGET2Data(queryClient: QueryClient, updater: (data: Types.GetGameAccountRespApiRespBase | undefined) => Types.GetGameAccountRespApiRespBase, id: number) {
  queryClient.setQueryData(gameAccountsGET2QueryKey(id),
    updater
  );
}

/**
 * Get GameAccount
 * @param id GameAccountId
 * @return Error
 */
export function setGameAccountsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetGameAccountRespApiRespBase | undefined) => Types.GetGameAccountRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function gameAccountsPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/tournaments/game-accounts/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function gameAccountsPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'gameAccountsPATCH',
      id as any,
    ]);
}

/**
 * Modify GameAccount
 * @param id PlayerId
 * @param body (optional) Request
 * @return Error
 */
export function useGameAccountsPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModGameAccountRespApiRespBase, unknown, Types.ModGameAccountReq, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModGameAccountRespApiRespBase, unknown, Types.ModGameAccountReq, TContext> {
  const key = gameAccountsPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ModGameAccountReq) => Client().gameAccountsPATCH(id, body), {...options, mutationKey: key});
}
  
    
export function gameAccountsDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/tournaments/game-accounts/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function gameAccountsDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'gameAccountsDELETE',
      id as any,
    ]);
}

/**
 * Delete GameAccount
 * @param id GameAccountId
 * @return Error
 */
export function useGameAccountsDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelGameAccountRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelGameAccountRespApiRespBase, unknown, void, TContext> {
  const key = gameAccountsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().gameAccountsDELETE(id), {...options, mutationKey: key});
}
  
    
export function fuzzy5Url(fuzzyPrefix: string, maxCount: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/tournaments/fuzzy?";
  if (fuzzyPrefix === undefined || fuzzyPrefix === null)
    throw new Error("The parameter 'fuzzyPrefix' must be defined and cannot be null.");
  else
    url_ += "FuzzyPrefix=" + encodeURIComponent("" + fuzzyPrefix) + "&";
if (maxCount === null)
    throw new Error("The parameter 'maxCount' cannot be null.");
else if (maxCount !== undefined)
    url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let fuzzy5DefaultOptions: UseQueryOptions<Types.GetFuzzyTournamentsRespApiRespBase, unknown, Types.GetFuzzyTournamentsRespApiRespBase> = {
  queryFn: __fuzzy5,
};
export function getFuzzy5DefaultOptions(): UseQueryOptions<Types.GetFuzzyTournamentsRespApiRespBase, unknown, Types.GetFuzzyTournamentsRespApiRespBase> {
  return fuzzy5DefaultOptions;
};
export function setFuzzy5DefaultOptions(options: UseQueryOptions<Types.GetFuzzyTournamentsRespApiRespBase, unknown, Types.GetFuzzyTournamentsRespApiRespBase>) {
  fuzzy5DefaultOptions = options;
}

export function fuzzy5QueryKey(dto: Fuzzy5QueryParameters): QueryKey;
export function fuzzy5QueryKey(fuzzyPrefix: string, maxCount: number | undefined): QueryKey;
export function fuzzy5QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { fuzzyPrefix, maxCount,  } = params[0] as Fuzzy5QueryParameters;

    return trimArrayEnd([
        'Client',
        'fuzzy5',
        fuzzyPrefix as any,
        maxCount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'fuzzy5',
        ...params
      ]);
  }
}
function __fuzzy5(context: QueryFunctionContext) {
  return Client().fuzzy5(
      context.queryKey[2] as string,       context.queryKey[3] as number | undefined    );
}

export function useFuzzy5Query<TSelectData = Types.GetFuzzyTournamentsRespApiRespBase, TError = unknown>(dto: Fuzzy5QueryParameters, options?: UseQueryOptions<Types.GetFuzzyTournamentsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get fuzzy users
 * @param maxCount (optional) 
 * @return Error
 */
export function useFuzzy5Query<TSelectData = Types.GetFuzzyTournamentsRespApiRespBase, TError = unknown>(fuzzyPrefix: string, maxCount: number | undefined, options?: UseQueryOptions<Types.GetFuzzyTournamentsRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFuzzy5Query<TSelectData = Types.GetFuzzyTournamentsRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuzzyTournamentsRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let fuzzyPrefix: any = undefined;
  let maxCount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ fuzzyPrefix, maxCount,  } = params[0] as Fuzzy5QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [fuzzyPrefix, maxCount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuzzyTournamentsRespApiRespBase, TError, TSelectData>({
    queryFn: __fuzzy5,
    queryKey: fuzzy5QueryKey(fuzzyPrefix, maxCount),
    ...fuzzy5DefaultOptions as unknown as UseQueryOptions<Types.GetFuzzyTournamentsRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get fuzzy users
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzy5Data(queryClient: QueryClient, updater: (data: Types.GetFuzzyTournamentsRespApiRespBase | undefined) => Types.GetFuzzyTournamentsRespApiRespBase, fuzzyPrefix: string, maxCount: number | undefined) {
  queryClient.setQueryData(fuzzy5QueryKey(fuzzyPrefix, maxCount),
    updater
  );
}

/**
 * Get fuzzy users
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzy5DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuzzyTournamentsRespApiRespBase | undefined) => Types.GetFuzzyTournamentsRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function usersGET4Url(filters_UserName: string | undefined, filters_UserTypeId: number | undefined, filters_FrontEndIds: number[] | undefined, filters_Groups: number[] | undefined, filters_Roles: number[] | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/users?";
if (filters_UserName === null)
    throw new Error("The parameter 'filters_UserName' cannot be null.");
else if (filters_UserName !== undefined)
    url_ += "Filters.UserName=" + encodeURIComponent("" + filters_UserName) + "&";
if (filters_UserTypeId === null)
    throw new Error("The parameter 'filters_UserTypeId' cannot be null.");
else if (filters_UserTypeId !== undefined)
    url_ += "Filters.UserTypeId=" + encodeURIComponent("" + filters_UserTypeId) + "&";
if (filters_FrontEndIds === null)
    throw new Error("The parameter 'filters_FrontEndIds' cannot be null.");
else if (filters_FrontEndIds !== undefined)
    filters_FrontEndIds && filters_FrontEndIds.forEach(item => { url_ += "Filters.FrontEndIds=" + encodeURIComponent("" + item) + "&"; });
if (filters_Groups === null)
    throw new Error("The parameter 'filters_Groups' cannot be null.");
else if (filters_Groups !== undefined)
    filters_Groups && filters_Groups.forEach(item => { url_ += "Filters.Groups=" + encodeURIComponent("" + item) + "&"; });
if (filters_Roles === null)
    throw new Error("The parameter 'filters_Roles' cannot be null.");
else if (filters_Roles !== undefined)
    filters_Roles && filters_Roles.forEach(item => { url_ += "Filters.Roles=" + encodeURIComponent("" + item) + "&"; });
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let usersGET4DefaultOptions: UseQueryOptions<Types.GetUsersRespApiRespBase, unknown, Types.GetUsersRespApiRespBase> = {
  queryFn: __usersGET4,
};
export function getUsersGET4DefaultOptions(): UseQueryOptions<Types.GetUsersRespApiRespBase, unknown, Types.GetUsersRespApiRespBase> {
  return usersGET4DefaultOptions;
};
export function setUsersGET4DefaultOptions(options: UseQueryOptions<Types.GetUsersRespApiRespBase, unknown, Types.GetUsersRespApiRespBase>) {
  usersGET4DefaultOptions = options;
}

export function usersGET4QueryKey(dto: UsersGET4QueryParameters): QueryKey;
export function usersGET4QueryKey(filters_UserName: string | undefined, filters_UserTypeId: number | undefined, filters_FrontEndIds: number[] | undefined, filters_Groups: number[] | undefined, filters_Roles: number[] | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function usersGET4QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { filters_UserName, filters_UserTypeId, filters_FrontEndIds, filters_Groups, filters_Roles, pageNo, pageSize,  } = params[0] as UsersGET4QueryParameters;

    return trimArrayEnd([
        'Client',
        'usersGET4',
        filters_UserName as any,
        filters_UserTypeId as any,
        filters_FrontEndIds as any,
        filters_Groups as any,
        filters_Roles as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'usersGET4',
        ...params
      ]);
  }
}
function __usersGET4(context: QueryFunctionContext) {
  return Client().usersGET4(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number[] | undefined,       context.queryKey[5] as number[] | undefined,       context.queryKey[6] as number[] | undefined,       context.queryKey[7] as number | undefined,       context.queryKey[8] as number | undefined    );
}

export function useUsersGET4Query<TSelectData = Types.GetUsersRespApiRespBase, TError = unknown>(dto: UsersGET4QueryParameters, options?: UseQueryOptions<Types.GetUsersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get users
 * @param filters_UserName (optional) 
 * @param filters_UserTypeId (optional) 
 * @param filters_FrontEndIds (optional) 
 * @param filters_Groups (optional) 
 * @param filters_Roles (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useUsersGET4Query<TSelectData = Types.GetUsersRespApiRespBase, TError = unknown>(filters_UserName: string | undefined, filters_UserTypeId: number | undefined, filters_FrontEndIds: number[] | undefined, filters_Groups: number[] | undefined, filters_Roles: number[] | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetUsersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUsersGET4Query<TSelectData = Types.GetUsersRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetUsersRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let filters_UserName: any = undefined;
  let filters_UserTypeId: any = undefined;
  let filters_FrontEndIds: any = undefined;
  let filters_Groups: any = undefined;
  let filters_Roles: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ filters_UserName, filters_UserTypeId, filters_FrontEndIds, filters_Groups, filters_Roles, pageNo, pageSize,  } = params[0] as UsersGET4QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [filters_UserName, filters_UserTypeId, filters_FrontEndIds, filters_Groups, filters_Roles, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetUsersRespApiRespBase, TError, TSelectData>({
    queryFn: __usersGET4,
    queryKey: usersGET4QueryKey(filters_UserName, filters_UserTypeId, filters_FrontEndIds, filters_Groups, filters_Roles, pageNo, pageSize),
    ...usersGET4DefaultOptions as unknown as UseQueryOptions<Types.GetUsersRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get users
 * @param filters_UserName (optional) 
 * @param filters_UserTypeId (optional) 
 * @param filters_FrontEndIds (optional) 
 * @param filters_Groups (optional) 
 * @param filters_Roles (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setUsersGET4Data(queryClient: QueryClient, updater: (data: Types.GetUsersRespApiRespBase | undefined) => Types.GetUsersRespApiRespBase, filters_UserName: string | undefined, filters_UserTypeId: number | undefined, filters_FrontEndIds: number[] | undefined, filters_Groups: number[] | undefined, filters_Roles: number[] | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(usersGET4QueryKey(filters_UserName, filters_UserTypeId, filters_FrontEndIds, filters_Groups, filters_Roles, pageNo, pageSize),
    updater
  );
}

/**
 * Get users
 * @param filters_UserName (optional) 
 * @param filters_UserTypeId (optional) 
 * @param filters_FrontEndIds (optional) 
 * @param filters_Groups (optional) 
 * @param filters_Roles (optional) 
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setUsersGET4DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetUsersRespApiRespBase | undefined) => Types.GetUsersRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function usersPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/users";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function usersPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'usersPOST',
    ]);
}

/**
 * Add User
 * @param userName (optional) 
 * @param email (optional) 
 * @param password (optional) 
 * @param lastName (optional) 
 * @param firstName (optional) 
 * @param userTypeId (optional) 
 * @param groupIds (optional) 
 * @param roleIds (optional) 
 * @param gender (optional) 
 * @param dateOfBirth (optional) 
 * @param city (optional) 
 * @param countryId (optional) 
 * @param aboutMe (optional) 
 * @param avatarImage (optional) 
 * @return Error
 */
export function useUsersPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddUserRespApiRespBase, unknown, UsersPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddUserRespApiRespBase, unknown, UsersPOSTMutationParameters, TContext> {
  const key = usersPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((usersPOSTMutationParameters: UsersPOSTMutationParameters) => Client().usersPOST(usersPOSTMutationParameters.userName, usersPOSTMutationParameters.email, usersPOSTMutationParameters.password, usersPOSTMutationParameters.lastName, usersPOSTMutationParameters.firstName, usersPOSTMutationParameters.userTypeId, usersPOSTMutationParameters.groupIds, usersPOSTMutationParameters.roleIds, usersPOSTMutationParameters.gender, usersPOSTMutationParameters.dateOfBirth, usersPOSTMutationParameters.city, usersPOSTMutationParameters.countryId, usersPOSTMutationParameters.aboutMe, usersPOSTMutationParameters.avatarImage), {...options, mutationKey: key});
}
  
    
export function usersGET5Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/users/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let usersGET5DefaultOptions: UseQueryOptions<Types.GetUserRespApiRespBase, unknown, Types.GetUserRespApiRespBase> = {
  queryFn: __usersGET5,
};
export function getUsersGET5DefaultOptions(): UseQueryOptions<Types.GetUserRespApiRespBase, unknown, Types.GetUserRespApiRespBase> {
  return usersGET5DefaultOptions;
};
export function setUsersGET5DefaultOptions(options: UseQueryOptions<Types.GetUserRespApiRespBase, unknown, Types.GetUserRespApiRespBase>) {
  usersGET5DefaultOptions = options;
}

export function usersGET5QueryKey(id: number): QueryKey;
export function usersGET5QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as UsersGET5QueryParameters;

    return trimArrayEnd([
        'Client',
        'usersGET5',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'usersGET5',
        ...params
      ]);
  }
}
function __usersGET5(context: QueryFunctionContext) {
  return Client().usersGET5(
      context.queryKey[2] as number    );
}

export function useUsersGET5Query<TSelectData = Types.GetUserRespApiRespBase, TError = unknown>(dto: UsersGET5QueryParameters, options?: UseQueryOptions<Types.GetUserRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get User
 * @param id UserId
 * @return Error
 */
export function useUsersGET5Query<TSelectData = Types.GetUserRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetUserRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUsersGET5Query<TSelectData = Types.GetUserRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetUserRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as UsersGET5QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetUserRespApiRespBase, TError, TSelectData>({
    queryFn: __usersGET5,
    queryKey: usersGET5QueryKey(id),
    ...usersGET5DefaultOptions as unknown as UseQueryOptions<Types.GetUserRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get User
 * @param id UserId
 * @return Error
 */
export function setUsersGET5Data(queryClient: QueryClient, updater: (data: Types.GetUserRespApiRespBase | undefined) => Types.GetUserRespApiRespBase, id: number) {
  queryClient.setQueryData(usersGET5QueryKey(id),
    updater
  );
}

/**
 * Get User
 * @param id UserId
 * @return Error
 */
export function setUsersGET5DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetUserRespApiRespBase | undefined) => Types.GetUserRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function usersPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/users/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function usersPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'usersPATCH',
      id as any,
    ]);
}

/**
 * Modify user
 * @param id UserId
 * @param userId (optional) 
 * @param userName (optional) 
 * @param email (optional) 
 * @param password (optional) 
 * @param lastName (optional) 
 * @param firstName (optional) 
 * @param userTypeId (optional) 
 * @param groupIds (optional) null
 * @param roleIds (optional) null
 * @param gender (optional) 
 * @param dateOfBirth (optional) 
 * @param city (optional) 
 * @param countryId (optional) 
 * @param aboutMe (optional) 
 * @param avatarImage (optional) 
 * @return Error
 */
export function useUsersPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModUserRespApiRespBase, unknown, UsersPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModUserRespApiRespBase, unknown, UsersPATCHMutationParameters, TContext> {
  const key = usersPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((usersPATCHMutationParameters: UsersPATCHMutationParameters) => Client().usersPATCH(id, usersPATCHMutationParameters.userId, usersPATCHMutationParameters.userName, usersPATCHMutationParameters.email, usersPATCHMutationParameters.password, usersPATCHMutationParameters.lastName, usersPATCHMutationParameters.firstName, usersPATCHMutationParameters.userTypeId, usersPATCHMutationParameters.groupIds, usersPATCHMutationParameters.roleIds, usersPATCHMutationParameters.gender, usersPATCHMutationParameters.dateOfBirth, usersPATCHMutationParameters.city, usersPATCHMutationParameters.countryId, usersPATCHMutationParameters.aboutMe, usersPATCHMutationParameters.avatarImage), {...options, mutationKey: key});
}
  
    
export function usersDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/users/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function usersDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'usersDELETE',
      id as any,
    ]);
}

/**
 * Delete user
 * @param id UserId
 * @return Error
 */
export function useUsersDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelUserRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelUserRespApiRespBase, unknown, void, TContext> {
  const key = usersDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().usersDELETE(id), {...options, mutationKey: key});
}
  
    
export function fuzzy6Url(fuzzyPrefix: string, maxCount: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/users/fuzzy?";
  if (fuzzyPrefix === undefined || fuzzyPrefix === null)
    throw new Error("The parameter 'fuzzyPrefix' must be defined and cannot be null.");
  else
    url_ += "FuzzyPrefix=" + encodeURIComponent("" + fuzzyPrefix) + "&";
if (maxCount === null)
    throw new Error("The parameter 'maxCount' cannot be null.");
else if (maxCount !== undefined)
    url_ += "MaxCount=" + encodeURIComponent("" + maxCount) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let fuzzy6DefaultOptions: UseQueryOptions<Types.GetFuzzyUsersRespApiRespBase, unknown, Types.GetFuzzyUsersRespApiRespBase> = {
  queryFn: __fuzzy6,
};
export function getFuzzy6DefaultOptions(): UseQueryOptions<Types.GetFuzzyUsersRespApiRespBase, unknown, Types.GetFuzzyUsersRespApiRespBase> {
  return fuzzy6DefaultOptions;
};
export function setFuzzy6DefaultOptions(options: UseQueryOptions<Types.GetFuzzyUsersRespApiRespBase, unknown, Types.GetFuzzyUsersRespApiRespBase>) {
  fuzzy6DefaultOptions = options;
}

export function fuzzy6QueryKey(dto: Fuzzy6QueryParameters): QueryKey;
export function fuzzy6QueryKey(fuzzyPrefix: string, maxCount: number | undefined): QueryKey;
export function fuzzy6QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { fuzzyPrefix, maxCount,  } = params[0] as Fuzzy6QueryParameters;

    return trimArrayEnd([
        'Client',
        'fuzzy6',
        fuzzyPrefix as any,
        maxCount as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'fuzzy6',
        ...params
      ]);
  }
}
function __fuzzy6(context: QueryFunctionContext) {
  return Client().fuzzy6(
      context.queryKey[2] as string,       context.queryKey[3] as number | undefined    );
}

export function useFuzzy6Query<TSelectData = Types.GetFuzzyUsersRespApiRespBase, TError = unknown>(dto: Fuzzy6QueryParameters, options?: UseQueryOptions<Types.GetFuzzyUsersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get fuzzy users
 * @param maxCount (optional) 
 * @return Error
 */
export function useFuzzy6Query<TSelectData = Types.GetFuzzyUsersRespApiRespBase, TError = unknown>(fuzzyPrefix: string, maxCount: number | undefined, options?: UseQueryOptions<Types.GetFuzzyUsersRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFuzzy6Query<TSelectData = Types.GetFuzzyUsersRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetFuzzyUsersRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let fuzzyPrefix: any = undefined;
  let maxCount: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ fuzzyPrefix, maxCount,  } = params[0] as Fuzzy6QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [fuzzyPrefix, maxCount, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetFuzzyUsersRespApiRespBase, TError, TSelectData>({
    queryFn: __fuzzy6,
    queryKey: fuzzy6QueryKey(fuzzyPrefix, maxCount),
    ...fuzzy6DefaultOptions as unknown as UseQueryOptions<Types.GetFuzzyUsersRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get fuzzy users
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzy6Data(queryClient: QueryClient, updater: (data: Types.GetFuzzyUsersRespApiRespBase | undefined) => Types.GetFuzzyUsersRespApiRespBase, fuzzyPrefix: string, maxCount: number | undefined) {
  queryClient.setQueryData(fuzzy6QueryKey(fuzzyPrefix, maxCount),
    updater
  );
}

/**
 * Get fuzzy users
 * @param maxCount (optional) 
 * @return Error
 */
export function setFuzzy6DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetFuzzyUsersRespApiRespBase | undefined) => Types.GetFuzzyUsersRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function usersessionUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/usersession";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let usersessionDefaultOptions: UseQueryOptions<Types.GetUserSessionRespApiRespBase, unknown, Types.GetUserSessionRespApiRespBase> = {
  queryFn: __usersession,
};
export function getUsersessionDefaultOptions(): UseQueryOptions<Types.GetUserSessionRespApiRespBase, unknown, Types.GetUserSessionRespApiRespBase> {
  return usersessionDefaultOptions;
};
export function setUsersessionDefaultOptions(options: UseQueryOptions<Types.GetUserSessionRespApiRespBase, unknown, Types.GetUserSessionRespApiRespBase>) {
  usersessionDefaultOptions = options;
}

export function usersessionQueryKey(): QueryKey;
export function usersessionQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'usersession',
    ]);
}
function __usersession() {
  return Client().usersession(
    );
}

/**
 * Get user menu and userprofile
 * @return Error
 */
export function useUsersessionQuery<TSelectData = Types.GetUserSessionRespApiRespBase, TError = unknown>(options?: UseQueryOptions<Types.GetUserSessionRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUsersessionQuery<TSelectData = Types.GetUserSessionRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetUserSessionRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetUserSessionRespApiRespBase, TError, TSelectData>({
    queryFn: __usersession,
    queryKey: usersessionQueryKey(),
    ...usersessionDefaultOptions as unknown as UseQueryOptions<Types.GetUserSessionRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get user menu and userprofile
 * @return Error
 */
export function setUsersessionData(queryClient: QueryClient, updater: (data: Types.GetUserSessionRespApiRespBase | undefined) => Types.GetUserSessionRespApiRespBase, ) {
  queryClient.setQueryData(usersessionQueryKey(),
    updater
  );
}

/**
 * Get user menu and userprofile
 * @return Error
 */
export function setUsersessionDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetUserSessionRespApiRespBase | undefined) => Types.GetUserSessionRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function venuesGETUrl(name: string | undefined, countryId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): string {
  let url_ = getBaseUrl() + "/api/v4/venues?";
if (name === null)
    throw new Error("The parameter 'name' cannot be null.");
else if (name !== undefined)
    url_ += "Name=" + encodeURIComponent("" + name) + "&";
if (countryId === null)
    throw new Error("The parameter 'countryId' cannot be null.");
else if (countryId !== undefined)
    url_ += "CountryId=" + encodeURIComponent("" + countryId) + "&";
if (pageNo === null)
    throw new Error("The parameter 'pageNo' cannot be null.");
else if (pageNo !== undefined)
    url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let venuesGETDefaultOptions: UseQueryOptions<Types.GetVenuesRespApiRespBase, unknown, Types.GetVenuesRespApiRespBase> = {
  queryFn: __venuesGET,
};
export function getVenuesGETDefaultOptions(): UseQueryOptions<Types.GetVenuesRespApiRespBase, unknown, Types.GetVenuesRespApiRespBase> {
  return venuesGETDefaultOptions;
};
export function setVenuesGETDefaultOptions(options: UseQueryOptions<Types.GetVenuesRespApiRespBase, unknown, Types.GetVenuesRespApiRespBase>) {
  venuesGETDefaultOptions = options;
}

export function venuesGETQueryKey(dto: VenuesGETQueryParameters): QueryKey;
export function venuesGETQueryKey(name: string | undefined, countryId: number | undefined, pageNo: number | undefined, pageSize: number | undefined): QueryKey;
export function venuesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { name, countryId, pageNo, pageSize,  } = params[0] as VenuesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'venuesGET',
        name as any,
        countryId as any,
        pageNo as any,
        pageSize as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'venuesGET',
        ...params
      ]);
  }
}
function __venuesGET(context: QueryFunctionContext) {
  return Client().venuesGET(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as number | undefined    );
}

export function useVenuesGETQuery<TSelectData = Types.GetVenuesRespApiRespBase, TError = unknown>(dto: VenuesGETQueryParameters, options?: UseQueryOptions<Types.GetVenuesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get venues by condition
 * @param name (optional) Venues Name
 * @param countryId (optional) Venues Country Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function useVenuesGETQuery<TSelectData = Types.GetVenuesRespApiRespBase, TError = unknown>(name: string | undefined, countryId: number | undefined, pageNo: number | undefined, pageSize: number | undefined, options?: UseQueryOptions<Types.GetVenuesRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useVenuesGETQuery<TSelectData = Types.GetVenuesRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetVenuesRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let name: any = undefined;
  let countryId: any = undefined;
  let pageNo: any = undefined;
  let pageSize: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ name, countryId, pageNo, pageSize,  } = params[0] as VenuesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [name, countryId, pageNo, pageSize, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetVenuesRespApiRespBase, TError, TSelectData>({
    queryFn: __venuesGET,
    queryKey: venuesGETQueryKey(name, countryId, pageNo, pageSize),
    ...venuesGETDefaultOptions as unknown as UseQueryOptions<Types.GetVenuesRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get venues by condition
 * @param name (optional) Venues Name
 * @param countryId (optional) Venues Country Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setVenuesGETData(queryClient: QueryClient, updater: (data: Types.GetVenuesRespApiRespBase | undefined) => Types.GetVenuesRespApiRespBase, name: string | undefined, countryId: number | undefined, pageNo: number | undefined, pageSize: number | undefined) {
  queryClient.setQueryData(venuesGETQueryKey(name, countryId, pageNo, pageSize),
    updater
  );
}

/**
 * Get venues by condition
 * @param name (optional) Venues Name
 * @param countryId (optional) Venues Country Id
 * @param pageNo (optional) 
 * @param pageSize (optional) 
 * @return Error
 */
export function setVenuesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetVenuesRespApiRespBase | undefined) => Types.GetVenuesRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function venuesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/v4/venues";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function venuesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'venuesPOST',
    ]);
}

/**
 * Add new tournaments venue
 * @param name (optional) Venues Name
 * @param countryId (optional) Venues Country Id
 * @param city (optional) Venues City
 * @param address (optional) Venues Address
 * @param coordinates (optional) Venues Coordinates
 * @param imageFile (optional) Image file
 * @return Error
 */
export function useVenuesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AddVenueRespApiRespBase, unknown, VenuesPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AddVenueRespApiRespBase, unknown, VenuesPOSTMutationParameters, TContext> {
  const key = venuesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((venuesPOSTMutationParameters: VenuesPOSTMutationParameters) => Client().venuesPOST(venuesPOSTMutationParameters.name, venuesPOSTMutationParameters.countryId, venuesPOSTMutationParameters.city, venuesPOSTMutationParameters.address, venuesPOSTMutationParameters.coordinates, venuesPOSTMutationParameters.imageFile), {...options, mutationKey: key});
}
  
    
export function venuesGET2Url(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/venues/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let venuesGET2DefaultOptions: UseQueryOptions<Types.GetVenueRespApiRespBase, unknown, Types.GetVenueRespApiRespBase> = {
  queryFn: __venuesGET2,
};
export function getVenuesGET2DefaultOptions(): UseQueryOptions<Types.GetVenueRespApiRespBase, unknown, Types.GetVenueRespApiRespBase> {
  return venuesGET2DefaultOptions;
};
export function setVenuesGET2DefaultOptions(options: UseQueryOptions<Types.GetVenueRespApiRespBase, unknown, Types.GetVenueRespApiRespBase>) {
  venuesGET2DefaultOptions = options;
}

export function venuesGET2QueryKey(id: number): QueryKey;
export function venuesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as VenuesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'venuesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'venuesGET2',
        ...params
      ]);
  }
}
function __venuesGET2(context: QueryFunctionContext) {
  return Client().venuesGET2(
      context.queryKey[2] as number    );
}

export function useVenuesGET2Query<TSelectData = Types.GetVenueRespApiRespBase, TError = unknown>(dto: VenuesGET2QueryParameters, options?: UseQueryOptions<Types.GetVenueRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get tournaments venue detail
 * @param id venue Id
 * @return Error
 */
export function useVenuesGET2Query<TSelectData = Types.GetVenueRespApiRespBase, TError = unknown>(id: number, options?: UseQueryOptions<Types.GetVenueRespApiRespBase, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useVenuesGET2Query<TSelectData = Types.GetVenueRespApiRespBase, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.GetVenueRespApiRespBase, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as VenuesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.GetVenueRespApiRespBase, TError, TSelectData>({
    queryFn: __venuesGET2,
    queryKey: venuesGET2QueryKey(id),
    ...venuesGET2DefaultOptions as unknown as UseQueryOptions<Types.GetVenueRespApiRespBase, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get tournaments venue detail
 * @param id venue Id
 * @return Error
 */
export function setVenuesGET2Data(queryClient: QueryClient, updater: (data: Types.GetVenueRespApiRespBase | undefined) => Types.GetVenueRespApiRespBase, id: number) {
  queryClient.setQueryData(venuesGET2QueryKey(id),
    updater
  );
}

/**
 * Get tournaments venue detail
 * @param id venue Id
 * @return Error
 */
export function setVenuesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.GetVenueRespApiRespBase | undefined) => Types.GetVenueRespApiRespBase) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function venuesPATCHUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/venues/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function venuesPATCHMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'venuesPATCH',
      id as any,
    ]);
}

/**
 * Modify tournaments venue
 * @param id tournaments venue Id
 * @param id (optional) Venue Id
 * @param name (optional) Venues Name
 * @param countryId (optional) Venues Country Id
 * @param city (optional) Venues City
 * @param address (optional) Venues Address
 * @param coordinates (optional) Venues Coordinates
 * @param imageFile (optional) Image file
 * @return Error
 */
export function useVenuesPATCHMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.ModVenueRespApiRespBase, unknown, VenuesPATCHMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModVenueRespApiRespBase, unknown, VenuesPATCHMutationParameters, TContext> {
  const key = venuesPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((venuesPATCHMutationParameters: VenuesPATCHMutationParameters) => Client().venuesPATCH(id, venuesPATCHMutationParameters.id, venuesPATCHMutationParameters.name, venuesPATCHMutationParameters.countryId, venuesPATCHMutationParameters.city, venuesPATCHMutationParameters.address, venuesPATCHMutationParameters.coordinates, venuesPATCHMutationParameters.imageFile), {...options, mutationKey: key});
}
  
    
export function venuesDELETEUrl(id: number): string {
  let url_ = getBaseUrl() + "/api/v4/venues/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function venuesDELETEMutationKey(id: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'venuesDELETE',
      id as any,
    ]);
}

/**
 * Delete tournaments venue
 * @param id tournaments venue Id
 * @return Error
 */
export function useVenuesDELETEMutation<TContext>(id: number, options?: Omit<UseMutationOptions<Types.DelVenueRespApiRespBase, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DelVenueRespApiRespBase, unknown, void, TContext> {
  const key = venuesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client().venuesDELETE(id), {...options, mutationKey: key});
}